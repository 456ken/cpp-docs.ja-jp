---
title: サンプル コンテナー クラス
ms.date: 11/04/2016
helpviewer_keywords:
- container classes [C++]
ms.assetid: 5b1451f2-c708-45da-bbf0-9e42fd687a1a
ms.openlocfilehash: 2024574633069cc70f0885fdce63f3afc09227c0
ms.sourcegitcommit: 0dcab746c49f13946b0a7317fc9769130969e76d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/24/2019
ms.locfileid: "68451108"
---
# <a name="sample-container-class"></a>サンプル コンテナー クラス

> [!NOTE]
> このトピックは、 C++ C++標準ライブラリで使用されているコンテナーの非機能例として、Microsoft ドキュメントに記載されています。 詳細については、「[C++ Standard Library Containers (C++ 標準ライブラリ コンテナ―)](../standard-library/stl-containers.md)」をご覧ください。

要素の可変長シーケンス (通常は型`Ty`) を制御するオブジェクトを記述します。 シーケンスは、実際のコンテナーに応じて、さまざまな方法で格納されます。

コンテナーのコンストラクターまたはメンバー関数がコンストラクター **Ty**(**const Ty&** ) または関数 **Ty::operator=** (**const Ty&** ) を呼び出す場合があります。 このような呼び出しで例外がスローされた場合、コンテナー オブジェクトは、その整合性を維持し、すべての例外をキャッチして再スローする必要があります。 コンテナー オブジェクトによっていずれか 1 つの例外がスローされた後に、コンテナー オブジェクトを安全にスワップ、消去、または破棄できます。 ただし、通常、それ以外の場合はコンテナー オブジェクトによって制御されるシーケンスの状態を予測できません。

その他の注意点:

- 式`~Ty`が例外をスローした場合、コンテナーオブジェクトの結果の状態は未定義になります。

- コンテナーがアロケーターオブジェクト*al*を格納し、 *al*がの呼び出し`al.allocate`の結果としてではなく例外をスローした場合、コンテナーオブジェクトの結果の状態は未定義になります。

- コンテナーが被制御シーケンスの順序付け方法を指定する関数オブジェクト *comp* を格納し、*comp* がいずれかの例外をスローする場合、コンテナー オブジェクトの結果の状態は未定義です。

C++ 標準ライブラリで定義されているコンテナー クラスは、次に説明するいくつかの追加要件を満たします。

コンテナーのテンプレート クラス [list](../standard-library/list-class.md) は、上記の例外が存在する場合でも、決定的かつ便利な動作を提供します。 たとえば、1 つまたは複数の要素の挿入時に例外がスローされた場合、コンテナーは変更されず、再度例外がスローされます。

標準ライブラリでC++定義されているすべてのコンテナークラスについて、次の`insert`メンバー `push_back`関数、、、または`push_front`の呼び出し中に例外がスローされた場合、コンテナーは変更されず、例外は再スロー.

標準ライブラリで定義されてC++いるすべてのコンテナークラスについて、、 `pop_front`の各メンバー関数の`pop_back`呼び出し中に例外がスローされることはありません。

メンバー関数 [erase](../standard-library/container-class-erase.md) は、コピー操作 (割り当てまたはコピーの構築) が例外をスローする場合にのみ例外をスローします。

さらに、メンバー関数によって返される反復子のコピー中に例外はスローされません。

メンバー関数 [swap](../standard-library/container-class-swap.md) は、C++ 標準ライブラリで定義されている*すべての*コンテナー クラスに対する追加の確実性を実現します。

- コンテナーがアロケーター オブジェクト al を格納し、`al` がコピーされるときに例外をスローする場合にのみ、メンバー関数が例外をスローします。

- スワップされる被制御シーケンスの要素を指定する参照、ポインター、および反復子は有効なままです。

C++ 標準ライブラリで定義されたコンテナー クラスのオブジェクトが、`Alloc` 型の格納されているオブジェクトによって制御するシーケンスの記憶域の割り当ておよび解放を行います (これは通常、テンプレート パラメーターです)。 このようなアロケーターオブジェクトは、クラス`allocator<Ty>`のオブジェクトと同じ外部インターフェイスを持っている必要があります。 特に、 `Alloc`は、と同じ型である必要があります。`Alloc::rebind<value_type>::other`

このメンバー関数`Alloc get_allocator const;`は、標準C++ライブラリで定義されている*すべて*のコンテナークラスについて、格納されているアロケーターオブジェクトのコピーを返します。 コンテナー オブジェクトを代入しても、格納されているアロケーター オブジェクトはコピー*されない*点に注意してください。 コンストラクターにアロケーターパラメーターが含まれ`allocator`てい`Alloc`ない場合、すべてのコンストラクターは、に格納されている値をに初期化します。

C++ 標準に従って、C++ 標準ライブラリで定義されたコンテナー クラスは次を想定できます。

- クラス `Alloc` のすべてのオブジェクトの比較結果が同じになります。

- 型`Alloc::const_pointer`はと`const Ty *`同じです。

- 型`Alloc::const_reference`はと`const Ty&`同じです。

- 型`Alloc::pointer`はと`Ty *`同じです。

- 型`Alloc::reference`はと`Ty&`同じです。

ただし、この実装では、コンテナーはこのような単純な想定を行いません。 このため、コンテナーはより意欲的なアロケーター オブジェクトと共に適切に動作します。

- クラス `Alloc` のすべてのオブジェクトの比較結果が同じである必要はありません。 (記憶域の複数のプールを維持することができます。)

- 型`Alloc::const_pointer`はと`const Ty *`同じである必要はありません。 (const ポインターには、クラスを指定できます。)

- 型`Alloc::pointer`はと`Ty *`同じである必要はありません。 (ポインターには、クラスを指定できます。)

## <a name="requirements"></a>必要条件

**ヘッダー**: \<sample container>

## <a name="see-also"></a>関連項目

[\<sample container>](../standard-library/sample-container.md)
