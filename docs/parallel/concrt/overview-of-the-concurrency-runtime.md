---
title: コンカレンシー ランタイムの概要
ms.date: 11/19/2018
helpviewer_keywords:
- Concurrency Runtime, requirements
- Concurrency Runtime, architecture
- Concurrency Runtime, overview
- Concurrency Runtime, lambda expressions
ms.assetid: 56237d96-10b0-494a-9cb4-f5c5090436c5
ms.openlocfilehash: 810d77abd37ff2c6f29e980b84645d16526744d8
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/23/2019
ms.locfileid: "62412702"
---
# <a name="overview-of-the-concurrency-runtime"></a>コンカレンシー ランタイムの概要

このドキュメントでは、コンカレンシー ランタイムの概要について説明します。 また、コンカレンシー ランタイムの利点、使用する状況、コンポーネントどうしの対話方法、コンポーネントとオペレーティング システムやアプリケーションとの対話方法について説明します。

##  <a name="top"></a> セクション

このドキュメントは、次のトピックに分かれています。

- [同時実行ランタイムの実装の履歴](#dlls)

- [同時実行ランタイムの重要ながある理由](#runtime)

- [アーキテクチャ](#architecture)

- [C++ のラムダ式](#lambda)

- [必要条件](#requirements)

## <a name="dlls"></a> 同時実行ランタイムの実装の履歴

2013 の Visual Studio 2010 では msvcr120.dll を通じて msvcr100.dll 内で同時実行ランタイムが組み込まれます。  Visual Studio 2015 で、UCRT のリファクタリングが発生したときに、その DLL は、3 つの部分にリファクタリングされました。

- ucrtbase.dll – C API では、Windows 10 に付属してし、下位レベルを使用して Windows Update の処理

- 関数とグローバル EH ランタイム、Visual Studio を使用して出荷に vcruntime140.dll – コンパイラ サポートします。

- Visual Studio を使用して concrt140.dll – 同時実行ランタイムが付属しています。 などの並列コンテナーとアルゴリズムに必要な`concurrency::parallel_for`します。 また、STL では Windows XP に条件変数があるないためにの電源の同期プリミティブを Windows XP では、この DLL が必要。

Visual Studio 2015 以降では、コンカレンシー ランタイムのタスク スケジューラは、ppltasks.h 内の task クラスや関連する型のためのスケジューラではなくなりました。 現在、これらの型では、パフォーマンスや Windows 同期プリミティブとの相互運用性を向上させるために、Windows のスレッド プールが使用されています。

##  <a name="runtime"></a> 同時実行ランタイムの重要ながある理由

コンカレンシー用のランタイムでは、同時に実行されるアプリケーションおよびアプリケーション コンポーネントに統一性と予測可能性が提供されます。 同時実行ランタイムの利点の 2 つの例は*協調タスク スケジューリング*と*協調ブロッキング*します。

コンカレンシー ランタイムで使用される協調タスク スケジューラには、ワーク スティーリング アルゴリズムが実装されており、作業がコンピューティング リソース間に効率的に分散されます。 たとえば、同じランタイムによって管理される 2 つのスレッドを持つアプリケーションがあるとします。 一方のスレッドがスケジュールされたタスクを完了したら、他方のスレッドから作業をオフロードできます。 このメカニズムにより、アプリケーションの全体的な作業負荷のバランスが保たれます。

また、コンカレンシー ランタイムでは、協調ブロッキングを使用して、リソースへのアクセスを同期する同期プリミティブも提供されます。 たとえば、共有リソースへの排他アクセスを必要とするタスクがあるとします。 ランタイムは協調的なブロッキングによって、最初のタスクがリソースを待機しているときに、残りのクォンタムを使用して別のタスクを実行できます。 このメカニズムにより、コンピューティング リソースを最大限に利用できます。

[[トップ](#top)]

##  <a name="architecture"></a> アーキテクチャ

コンカレンシー ランタイムは、並列パターン ライブラリ (PPL)、非同期エージェント ライブラリ、タスク スケジューラ、およびリソース マネージャーの 4 つのコンポーネントで構成されます。 これらのコンポーネントは、オペレーティング システムとアプリケーションの間に配置されます。 次の図は、コンカレンシー ランタイムのコンポーネントがオペレーティング システムおよびアプリケーションとの間でどのようにやり取りするかを示しています。

**同時実行ランタイム アーキテクチャ**

![同時実行ランタイム アーキテクチャ](../../parallel/concrt/media/concurrencyrun.png "同時実行ランタイムのアーキテクチャ")

> [!IMPORTANT]
> タスク スケジューラと Resource Manager のコンポーネントは、ユニバーサル Windows プラットフォーム (UWP) アプリから、または ppltasks.h の task クラスまたはその他の種類を使用するときにご利用いただけません。

同時実行ランタイムが高*コンポーザブル*、つまりより多くの既存の機能を組み合わせることができます。 コンカレンシー ランタイムでは、下位のコンポーネントから、並列アルゴリズムなど多数の機能を構成します。

また、コンカレンシー ランタイムでは、協調ブロッキングを使用して、リソースへのアクセスを同期する同期プリミティブも提供されます。 これらの同期プリミティブの詳細については、次を参照してください。[同期データ構造](../../parallel/concrt/synchronization-data-structures.md)します。

以下のセクションでは、各コンポーネントが備えている機能と使用する場面についての概要を簡単に説明します。

### <a name="parallel-patterns-library"></a>並列パターン ライブラリ

並列パターン ライブラリ (PPL) は、粒度の細かい並列化を実行するための汎用的なコンテナーとアルゴリズムを提供します。 Ppl での*命令型のデータの並列化*計算のコレクションまたはデータのセットでのコンピューティング リソースを分散する並列アルゴリズムを提供することで。 また、*タスクの並列化*コンピューティング リソース間で複数の独立した操作を分散するタスク オブジェクトを提供することで。

ローカルの計算で並列実行の利点を活用できる場合は、並列パターン ライブラリを使用します。 たとえば、使用することができます、 [concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for)既存を変換するアルゴリズム`for`ループを並列で動作します。

並列パターン ライブラリの詳細については、次を参照してください。[並列パターン ライブラリ (PPL)](../../parallel/concrt/parallel-patterns-library-ppl.md)します。

### <a name="asynchronous-agents-library"></a>非同期エージェント ライブラリ

非同期エージェント ライブラリ (または単*エージェント ライブラリ*) アクタベースのプログラミング モデルとメッセージ パッシング インターフェイスの粒度の粗いデータ フローおよびパイプライン処理タスクの両方を提供します。 非同期エージェントを使用すると、他のコンポーネントがデータを待機しているときに作業を実行することにより、待機時間を生産的に活用できます。

相互に非同期通信を行う複数のエンティティがある場合に、エージェント ライブラリを使用します。 たとえば、データをファイルまたはネットワーク接続から読み取って、そのデータをメッセージ パッシング インターフェイスで別のエージェントに送信するエージェントを作成できます。

エージェント ライブラリの詳細については、次を参照してください。 [Asynchronous Agents Library](../../parallel/concrt/asynchronous-agents-library.md)します。

### <a name="task-scheduler"></a>タスク スケジューラ

タスク スケジューラは、実行時にタスクをスケジュールおよび調整します。 タスク スケジューラは他の処理と連携して行われ、ワーク スティーリング アルゴリズムを使用して処理リソースを最大限に活用します。

コンカレンシー ランタイムには既定のスケジューラが用意されているため、インフラストラクチャの詳細を管理する必要はありません。 ただし、アプリケーションの品質ニーズを満たすために、独自のスケジューリング ポリシーを用意したり、特定のスケジューラを特定のタスクに関連付けたりすることもできます。

タスク スケジューラの詳細については、次を参照してください。[タスク スケジューラ](../../parallel/concrt/task-scheduler-concurrency-runtime.md)します。

### <a name="resource-manager"></a>リソース マネージャー

リソース マネージャーの役割は、プロセッサやメモリなどのコンピューティング リソースを管理することです。 リソース マネージャーは、実行時の作業負荷の変更に応答して、効果が最も大きくなる場所にリソースを割り当てます。

リソース マネージャーは、コンピューティング リソースの抽象化として機能し、主にタスク スケジューラとやり取りします。 リソース マネージャーを使用してライブラリおよびアプリケーションのパフォーマンスを微調整できますが、通常は、並列パターン ライブラリ、エージェント ライブラリ、およびタスク スケジューラに備わった機能を使用します。 これらのライブラリでは、リソース マネージャーを使用して、作業負荷の変更に応じてリソースのバランスを直接的に再調整します。

[[トップ](#top)]

##  <a name="lambda"></a> C++ のラムダ式

コンカレンシー ランタイムで定義されている型やアルゴリズムの多くは、C++ テンプレートとして実装されています。 こうした型やアルゴリズムの中には、処理を実行するためのルーチンをパラメーターとして受け取るものがあります。 このパラメーターには、ラムダ関数、関数オブジェクト、または関数ポインターを使用できます。 これらのエンティティとも呼ばれる*処理関数*または*仕事のやり方*します。

ラムダ式は、Visual C++ 言語の重要な新機能の 1 つです。ラムダ式を使用すると、並列処理用の処理関数を簡潔に定義できます。 関数オブジェクトおよび関数ポインターを使用すると、既存のコードでコンカレンシー ランタイムを使用できます。 ただし、新しいコードを記述するときには、安全性や生産性の面で優れたラムダ式を使用することをお勧めします。

次の例では、ラムダ関数、関数オブジェクト、および複数の呼び出しの関数ポインターの構文を比較し、 [concurrency::parallel_for_each](reference/concurrency-namespace-functions.md#parallel_for_each)アルゴリズム。 呼び出しごとに`parallel_for_each`するさまざまな手法を使用して、内の各要素の 2 乗を計算する、 [std::array](../../standard-library/array-class-stl.md)オブジェクト。

[!code-cpp[concrt-comparing-work-functions#1](../../parallel/concrt/codesnippet/cpp/overview-of-the-concurrency-runtime_1.cpp)]

**出力**

```Output
1
256
6561
65536
390625
```

C++ でのラムダ関数の詳細については、次を参照してください。[ラムダ式](../../cpp/lambda-expressions-in-cpp.md)します。

[[トップ](#top)]

##  <a name="requirements"></a> 要件

次の表は、コンカレンシー ランタイムの各コンポーネントに関連付けられているヘッダー ファイルを示しています。

|コンポーネント|ヘッダー ファイル|
|---------------|------------------|
|並列パターン ライブラリ (PPL)|ppl.h<br /><br /> concurrent_queue.h<br /><br /> concurrent_vector.h|
|非同期エージェント ライブラリ|agents.h|
|タスク スケジューラ|concrt.h|
|リソース マネージャー|concrtrm.h|

宣言されている同時実行ランタイム、[同時実行](../../parallel/concrt/reference/concurrency-namespace.md)名前空間。 (使用することも[同時実行](../../parallel/concrt/reference/concurrency-namespace.md)、この名前空間のエイリアスである)。`concurrency::details` 名前空間は、コンカレンシー ランタイム フレームワークをサポートしますが、コードから直接使用することを目的としていません。

コンカレンシー ランタイムは、C ランタイム ライブラリ (CRT) の一部として提供されます。 CRT を使用するアプリケーションを構築する方法の詳細については、次を参照してください。 [CRT ライブラリの機能](../../c-runtime-library/crt-library-features.md)します。

[[トップ](#top)]
