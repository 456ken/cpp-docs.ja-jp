---
title: レコード セット:動的に結びつける方法 (ODBC) のデータ列
ms.date: 11/19/2018
helpviewer_keywords:
- ODBC recordsets [C++], binding columns dynamically
- data binding [C++], recordset columns
- recordsets [C++], binding data
- data binding [C++], columns in recordsets
- columns [C++], binding to recordsets
ms.assetid: bff67254-d953-4ae4-9716-91c348cb840b
ms.openlocfilehash: c2f2a6a6696f46fb5b8f2777c6c911269c9e7a80
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/23/2019
ms.locfileid: "62397906"
---
# <a name="recordset-dynamically-binding-data-columns-odbc"></a>レコード セット:動的に結びつける方法 (ODBC) のデータ列

このトピックの内容は、MFC ODBC クラスに該当します。

レコード セットの管理、デザイン時に指定したテーブル列が不明であったことをデザイン時に列をバインドする場合します。 このトピックでは、次の内容について説明します。

- [レコード セットに列を動的にバインドするときに](#_core_when_you_might_bind_columns_dynamically)します。

- [実行時に列を動的にバインドする方法](#_core_how_to_bind_columns_dynamically)します。

> [!NOTE]
>  このトピックの内容は、バルク行フェッチが実装されていない `CRecordset` の派生オブジェクトを対象にしています。 バルク行フェッチを使用している場合、一般的に説明した手法は推奨されません。 バルク行フェッチの詳細については、次を参照してください。[レコード セット。(ODBC) バルク行フェッチ](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md)します。

##  <a name="_core_when_you_might_bind_columns_dynamically"></a> 列を動的にバインドがありますと

MFC アプリケーション ウィザード、デザイン時にまたは[MFC ODBC コンシューマー ウィザード](../../mfc/reference/adding-an-mfc-odbc-consumer.md)(から**クラスの追加**) 既知のテーブルと、データ ソースの列に基づいてレコード セット クラスを作成します。 データベースは、および実行時にこれらのテーブルと列に、アプリケーションが使用するときに後をデザインするときの間で変更できます。 または別のユーザー可能性があります追加や削除、テーブルまたは追加またはアプリケーションのレコード セットが依存しているテーブルから列を削除します。 これは、可能性に問題がないすべてのデータ アクセス アプリケーションの場合は、お客様にも方法に対応する必要を再設計し、再コンパイルすること以外のデータベース スキーマの変更でしょうか このトピックの目的は、その質問に答えるです。

このトピックで説明する可能性があります列動的に連結する最も一般的なケース: 実行時に追加の列を処理する既知のデータベース スキーマに基づいてレコード セットを開始した、します。 トピックをさらには、追加の列にマップを前提としています。`CString`フィールド データ メンバー、ほとんどのケースのが、他のデータ型の管理に役立つ推奨事項が提供されます。

少量の余分なコードは、次のことができます。

- [実行時にどのような列が使用可能な判断](#_core_how_to_bind_columns_dynamically)します。

- [実行時に動的に、レコード セットに追加の列をバインド](#_core_adding_the_columns)します。

レコード セットには、デザイン時にわかって列のデータ メンバーも含まれています。 少量の追加のコードをターゲット テーブルに新しい列が追加されているかどうかを動的に決定が含まれていて、そうである場合に動的に割り当てられたメモリ (ではなくレコード セットのデータ メンバーに) これらの新しい列をバインドします。

このトピックでは、その他の動的バインドの場合、削除されたテーブルや列などは含まれません。 その場合は、ODBC API 関数を直接使用する必要があります。 については、ODBC SDK を参照してください。*プログラマーズ リファレンス*MSDN ライブラリ CD に収録されています。

##  <a name="_core_how_to_bind_columns_dynamically"></a> 列を動的にバインドする方法

列を動的にバインドするには、追加の列の名前にいる (またはを判断できるように) する必要があります。 記憶域の割り当ての追加のフィールド データ メンバーの、名前と、型を指定、および追加する列の数を指定もする必要があります。

次の説明では、2 つの異なるレコード セットを紹介します。 最初は、対象のテーブルからレコードを選択するメイン レコード セットです。 2 つ目は、特殊な列のレコード セット先のテーブルの列に関する情報を取得するために使用します。

###  <a name="_core_the_general_process"></a> 一般的なプロセス

最も一般的なレベルは、次の手順をに。

1. メイン レコード セット オブジェクトを構築します。

   必要に応じて、開いているへのポインターを渡す`CDatabase`オブジェクトまたはその他の何らかの方法で列のレコード セットへの接続情報を提供できます。

1. 列を動的に追加する手順を実行します。

   次の列を追加で説明されているプロセスを参照してください。

1. メイン レコード セットを開きます。

   レコード セットはレコードを選択し、レコード フィールド エクス (チェンジ RFX) を使用して静的な列 (レコード セットのフィールド データ メンバーにマップされているもの) と動的な列 (余分なストレージを割り当てるにはマップ) の両方にバインドします。

###  <a name="_core_adding_the_columns"></a> 列を追加します。

動的に結びつける方法には、実行時に列には、次の手順が必要ですが追加されます。

1. 実行時に、対象テーブルの列を決定します。 レコード セット クラスのために設計されたため、テーブルに追加された列の一覧からその情報を抽出します。

   列の名前とデータ型) などのターゲット テーブルの列情報のデータ ソースをクエリするように設計列のレコード セット クラスを使用することをお勧めします。

1. 新しいフィールド データ メンバーのストレージを提供します。 メイン レコード セット クラスは不明な列のフィールド データ メンバーがあるないため (列は、さまざまなデータ型) の場合、名前、戻り値、およびデータ型情報を格納する場所を指定する必要があります。

   1 つの方法では、(必要な) 場合、その戻り値、およびそのデータ型の 3 つ目の 1 つ以上の動的リスト、間、新しい列の名前のいずれかをビルドします。 値リスト、特に、これらのリストは、情報とバインディングのために必要なストレージを提供します。 次の図は、リストの構成を示しています。

   ![動的にバインドする列のリスト](../../data/odbc/media/vc37w61.gif "に動的にバインドする列のリスト")<br/>
   動的に結び付ける列のリストを生成する方法

1. メイン レコード セットの RFX 関数の呼び出しを追加`DoFieldExchange`関数の各列を追加します。 これらの rfx 関数の呼び出しでは、レコードをフェッチしています。 追加の列など、それらのレコード セットのデータ メンバーまたは動的に指定されたストレージに、列のバインドの処理を行います。

   メイン レコード セットのループを追加する方法が`DoFieldExchange`リスト内の各列に対して適切なの RFX 関数を呼び出して、新しい列の一覧をループ処理する関数。 各 rfx 関数の呼び出しでは、列名のリストと結果の値リストの対応するメンバーの記憶域の場所から列名を渡します。

###  <a name="_core_lists_of_columns"></a> 列のリスト

使用する必要がある 4 つのリストは、次の表に表示されます。

|||
|-|-|
|**Current-Table-Columns**| (図にはリスト 1)現在のデータ ソースのテーブルの列の一覧。 この一覧は、レコード セットに現在バインドされている列の一覧に一致があります。|
|**レコード セット列のバインド**| (図でリスト 2)列の一覧は、レコード セットにバインドします。 これらの列が既にある RFX ステートメント、`DoFieldExchange`関数。|
|**動的に列のバインド-**| (図でリスト 3)レコード セットではなく、テーブルで列の一覧。 これらは動的にバインドする列です。|
|**動的な列の値**| (図でリスト 4)動的にバインドする列から値の記憶域を含む一覧を取得します。 この一覧の要素は、動的に列のバインドの一対一で対応します。|

###  <a name="_core_building_your_lists"></a> リストの構築

考慮して一般的な戦略では、詳細を有効にできます。 このトピックの残りの部分の手順に示すようにリストを構築する方法を示して[列のリスト](#_core_lists_of_columns)します。 手順する手順を紹介します。

- [レコード セットではなく列の名前を決定する](#_core_determining_which_table_columns_are_not_in_your_recordset)します。

- [動的なストレージ テーブルに新しく追加された列を提供する](#_core_providing_storage_for_the_new_columns)します。

- [RFX を動的に追加する新しい列の呼び出す](#_core_adding_rfx_calls_to_bind_the_columns)します。

###  <a name="_core_determining_which_table_columns_are_not_in_your_recordset"></a> テーブルの列は、レコード セットではなくを決定します。

メイン レコード セットに既にバインドされている列の一覧を含むリスト (バインドのレコード セット列、リスト 2 の図のように) をビルドします。 次はメイン レコード セットではなく、データ ソースのテーブルに列名を含むリストを ("現在のテーブル列とバインドのレコード セット列から派生する、"動的にバインド列") を作成します。

##### <a name="to-determine-the-names-of-columns-not-in-the-recordset-columns-to-bind-dynamically"></a>(動的に列のバインド-)、レコード セットにない列の名前を決定するには

1. メイン レコード セットに既にバインドされている列の一覧 (バインドのレコード セットの列) を作成します。

   1 つの方法では、デザイン時にレコード セット列のバインドを作成します。 レコード セットの RFX 関数の呼び出しを視覚的に調べることができます`DoFieldExchange`これらの名前を取得します。 次に、名前で初期化された配列としてリストを設定します。

   たとえば、図には、3 つの要素にバインドされたレコード セットの列 (リスト 2) を示します。 レコード セット列のバインドには、現在のテーブル列のリスト 1 に示すように、Phone 列がありません。

1. (列のバインド-動的に) メイン レコード セットにバインドされていない列の一覧を作成するには、現在のテーブル列とバインドのレコード セットの列を比較します。

   1 つの方法では、実行時間 (現在のテーブルの列) と並列でレコード セット (バインドのレコード セットの列) に既にバインドされている列の一覧で、テーブル内の列の一覧をループします。 動的に列のバインドには、現在のテーブルの列バインドのレコード セットの列に表示されないに任意の名前を配置します。

   要素が 1 つの図がたとえば、動的にバインド列 (リスト 3) に表示します。 バインドされたレコード セットの列 (リスト 2) ではなく現在のテーブル列のリスト 1 で見つかった Phone 列。

1. それぞれの列名に動的にバインドする列の一覧に格納されている (列のバインド-動的に) に対応するデータ値を格納するための (一覧の図は、4) のように動的な列の値の一覧を構築します。

   このリストの要素は、フィールド データ メンバーに新しいレコード セットの役割を果たします。 動的な列がバインドされている記憶域の場所が表示されます。 リストの説明については、次を参照してください。[列のリスト](#_core_lists_of_columns)します。

###  <a name="_core_providing_storage_for_the_new_columns"></a> 新しい列のストレージを提供します。

次に、動的にバインドする列の記憶域の場所を設定します。 考え方は、各列の値を格納するリストの要素を提供します。 これらの記憶域の場所は並列レコード セットのメンバー変数、通常のバインドされた列を格納します。

#### <a name="to-provide-dynamic-storage-for-new-columns-dynamic-column-values"></a>新しい列 (動的な列の値) の動的な記憶域を提供するには

1. 動的な列の値、列のバインド-動的に、各列のデータの値を格納するには並列をビルドします。

   要素が 1 つの図が動的な列の値 (リスト 4) を表示するなど、:`CString`現在のレコードの実際の電話番号を含むオブジェクト。"555-1212".

   動的な列の値の型の要素が最も一般的なケースで`CString`します。 さまざまなデータ型の列を扱うさまざまな種類の要素を含むことのできる一覧が必要です。

上記の手順の結果は、2 つの主なリストです。列のバインド-動的に列と動的な列の値の現在のレコードの列の値を格納しているの名前を格納しています。

> [!TIP]
> 新しい列がすべて同じデータ型のない場合は、追加の並列何らかの方法で列リストで各要素の型を定義するコンテナーの項目の一覧をする可能性があります。 (リスト、必要に応じての値を使用して、このたいとします。 これらの定数は、AFXDB で定義されます。H.)列のデータ型を表す方法に基づくリストの種類を選択します。

###  <a name="_core_adding_rfx_calls_to_bind_the_columns"></a> 列をバインドする rfx 関数呼び出しの追加

Rfx 関数の呼び出しで、新しい列に配置することによって発生する動的なバインドの最後に、配置、`DoFieldExchange`関数。

##### <a name="to-dynamically-add-rfx-calls-for-new-columns"></a>新しい列の rfx 関数の呼び出しを動的に追加するには

1. メイン レコード セットの`DoFieldExchange`メンバー関数を新しい列 (動的に列のバインド-) の一覧をループ処理するコードを追加します。 各ループからの動的な列の値から列の結果の値と列のバインド-動的に列名を抽出します。 列のデータ型に適した RFX 関数を呼び出す次の項目を渡します。 リストの説明については、次を参照してください。[列のリスト](#_core_lists_of_columns)します。

一般的な場合で、`RFX_Text`関数呼び出しを抽出する`CString`オブジェクトを動的に列のバインドでは、コードの次の行のように、リストから、`CStringList`と呼ばれる`m_listName`動的な列の値であり、 `CStringList`と呼ばれる`m_listValue`:

```cpp
RFX_Text( pFX,
            m_listName.GetNext( posName ),
            m_listValue.GetNext( posValue ));
```

RFX 関数の詳細については、次を参照してください。[マクロとグローバル](../../mfc/reference/mfc-macros-and-globals.md)で、*クラス ライブラリ リファレンス*します。

> [!TIP]
> 新しい列が別のデータ型の場合は、ループで switch ステートメントを使用して、各種類の RFX 関数を呼び出します。

フレームワークを呼び出すと`DoFieldExchange`中に、`Open`静的列は、それらの列をバインドは、rfx 関数の呼び出し、レコード セットに列をバインドするプロセス。 ループは、動的な列の RFX 関数を繰り返し呼び出します。

## <a name="see-also"></a>関連項目

[レコードセット (ODBC)](../../data/odbc/recordset-odbc.md)<br/>
[レコードセット: 大きいデータ項目の処理 (ODBC)](../../data/odbc/recordset-working-with-large-data-items-odbc.md)