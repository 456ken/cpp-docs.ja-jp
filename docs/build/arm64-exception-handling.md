---
title: ARM64 例外処理
ms.date: 11/19/2018
ms.openlocfilehash: 43e43beae5ee02f9ef4537da08a1c9915056b777
ms.sourcegitcommit: 5fc76f5b3c4c3ee49f38f05b37261a324591530b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/02/2019
ms.locfileid: "58870794"
---
# <a name="arm64-exception-handling"></a>ARM64 例外処理

ARM64 の Windows では、同じ構造化例外処理は非同期のハードウェアで生成される例外と同期のソフトウェアで生成される例外メカニズムを使用します。 言語固有の例外ハンドラーは、言語ヘルパー関数を使用することで、Windows 構造化例外処理に付加して構築します。 このドキュメントでは、ARM64、および Microsoft ARM アセンブラーおよび MSVC コンパイラによって生成されるコードで使用する言語ヘルパーでの Windows での例外処理について説明します。

## <a name="goals-and-motivation"></a>目標と動機

例外アンワインド データ規則、およびこの説明を想定しています。

1. アンワインド コードのすべてのケースでプローブを使用せずに許可するための十分な説明を提供します。

   - コードの分析には、ページングするためのコードが必要です。 これにより、アンワインドが役にいくつかの状況では (トレース、サンプリング、デバッグ)。

   - 複雑な; は、コードの分析コンパイラは、アンワインダーがデコードできる命令を生成するだけに注意が必要である必要があります。

   - アンワインドは、アンワインド コードを使用して完全に説明することはできません場合、場合によっては、する必要があります代わりに命令をデコードすること。 これにより、全体の複雑さを向上し、理想的には、回避は。

1. 中間のプロローグのアンワインドと中間のエピローグをサポートします。

   - 例外処理より多くの Windows で使用のアンワインド、プロローグおよびエピローグ コードのシーケンスとも途中で実行できることが重要ですのでの正確なアンワインドします。

1. 最小限の領域を占有します。

   - アンワインド コードは、バイナリのサイズを大幅に増加する集計されない必要があります。

   - アンワインド コードがメモリにロックされる可能性があります、ため、小さなフット プリントにより読み込まれた各バイナリの最小限のオーバーヘッドになります。

## <a name="assumptions"></a>外部からの影響

例外処理の説明で行われる前提条件を次に示します。

1. プロローグとエピローグは、いずれかの他のミラー化する傾向があります。 この共通する特徴を利用では、アンワインドの記述に必要なメタデータのサイズを大幅に減少します。 関数の本体には、プロローグの操作は、元に戻す、または進んでエピローグが行われるかどうかは関係ありません。 両方の場合で同じ結果となります。

1. 関数を比較的小さく全体に傾向があります。 領域のいくつかの最適化は、データの最も効率的なパッキングを実現するために、これに依存します。

1. エピローグに条件付きのコードはありません。

1. 専用のフレーム ポインター レジスタ。Sp が別のレジスタ (r29) を登録すると、プロローグ内に保存されている場合は、元の sp をいつでも回復可能性がありますように、関数全体で変更されません。

1. Sp が別のレジスタに保存しない限り、プロローグおよびエピローグ内でスタック ポインターのすべての操作が厳密に発生します。

1. スタック フレームのレイアウトは、次のセクションで説明されているように構成されています。

## <a name="arm64-stack-frame-layout"></a>ARM64 スタック フレームのレイアウト

![スタック フレームのレイアウト](media/arm64-exception-handling-stack-frame.png "スタック フレームのレイアウト")

フレーム チェーン関数では、最適化に関する考慮事項によって、ローカル変数領域内の任意の位置にある、fp と lr のペアを保存できます。 目標は、フレーム ポインター (r29) またはスタック ポインター (sp) に基づいて 1 つの単一の命令で到達可能なローカル変数の数を最大化します。 ただしの`alloca`関数チェーンを接続する必要があり、r29 はスタックの一番下を指す必要があります。 レジスタのペアのアドレス指定-モード カバレッジを向上できるように、不揮発性レジスタ保存領域は、ローカル領域のスタックの一番上に配置されます。 ここでは、最も効率的なプロローグ シーケンスのいくつかを示す例です。 わかりやすくするため、キャッシュの局所性の向上のためには、呼び出し先保存済みレジスタを格納するすべての標準のプロローグでの順序は、「を増大」順序では。 `#framesz` 以下は、(alloca の領域を除く) スタック全体のサイズを表します。 `#localsz` `#outsz`ローカル領域のサイズを表す (など、保存するための領域、 \<r29、lr > ペア) とそれぞれのパラメーターのサイズを送信します。

1. Chained, #localsz \<= 512

    ```asm
        stp    r19,r20,[sp,-96]!        // pre-indexed, save in 1st FP/INT pair
        stp    d8,d9,[sp,16]            // save in FP regs (optional)
        stp    r0,r1,[sp,32]            // home params (optional)
        stp    r2,r3,[sp, 48]
        stp    r4,r5,[sp,64]
        stp    r6,r7,[sp,72]
        stp    r29, lr, [sp, -#localsz]!    // save <r29,lr> at bottom of local area
        mov    r29,sp                   // r29 points to bottom of local
        sub    sp, #outsz               // (optional for #outsz != 0)
    ```

1. Chained, #localsz > 512

    ```asm
        stp    r19,r20,[sp,-96]!        // pre-indexed, save in 1st FP/INT pair
        stp    d8,d9,[sp,16]            // save in FP regs (optional)
        stp    r0,r1,[sp,32]            // home params (optional)
        stp    r2,r3,[sp, 48]
        stp    r4,r5,[sp,64]
        stp    r6,r7,[sp,72]
        sub    sp,#localsz+#outsz       // allocate remaining frame
        stp    r29, lr, [sp, #outsz]    // save <r29,lr> at bottom of local area
        add    r29,sp, #outsz           // setup r29 points to bottom of local area
    ```

1. (Lr が保存されていない)、チェーンのリーフ関数

    ```asm
        stp    r19,r20,[sp, -72]!       // pre-indexed, save in 1st FP/INT reg-pair
        stp    r21,r22,[sp, 16]
        str    r23 [sp,32]
        stp    d8,d9,[sp,40]            // save FP regs (optional)
        stp    d10,d11,[sp,56]
        sub    sp,#framesz-72           // allocate the remaining local area
    ```

   すべてのローカル変数は、SP のベース \<r29、lr > 前のフレームを指します。 フレームのサイズの\<= 512、"sp、sub…"regs 保存領域がスタックの一番下に移動した場合は、すぐ最適化できます。 その欠点は、上、その他のレイアウトと一貫性がありませんし、保存 regs ペア regs とオフセット前と後にインデックス付きのアドレス指定モードの範囲の一部を取得することは。

1. チェーンは、リーフ以外の機能が (Int 保存領域に lr が保存されます)

    ```asm
        stp    r19,r20,[sp,-80]!        // pre-indexed, save in 1st FP/INT reg-pair
        stp    r21,r22,[sp,16]          // ...
        stp    r23, lr,[sp, 32]         // save last Int reg and lr
        stp    d8,d9,[sp, 48]           // save FP reg-pair (optional)
        stp    d10,d11,[sp,64]          // ...
        sub    sp,#framesz-80           // allocate the remaining local area
    ```

   または、偶数と Int レジスタを保存します

    ```asm
        stp    r19,r20,[sp,-72]!        // pre-indexed, save in 1st FP/INT reg-pair
        stp    r21,r22,[sp,16]          // ...
        str    lr,[sp, 32]              // save lr
        stp    d8,d9,[sp, 40]           // save FP reg-pair (optional)
        stp    d10,d11,[sp,56]          // ...
        sub    sp,#framesz-72           // allocate the remaining local area
    ```

   保存 r19 のみ:

    ```asm
        sub    sp, sp, #16              // reg save area allocation*
        stp    r19,lr,[sp,0]            // save r19, lr
        sub    sp,#framesz-16           // allocate the remaining local area
    ```

   \* 領域の割り当てを保存 reg にアンワインド コードを事前にインデックス付きの reg lr stp を表すことができないため、stp に折りたたむされません。

   すべてのローカル変数は、SP のベース \<r29 > 前のフレームを指します。

1. Chained, #framesz \<= 512, #outsz = 0

    ```asm
        stp    r29, lr, [sp, -#framesz]!    // pre-indexed, save <r29,lr>
        mov    r29,sp                       // r29 points to bottom of stack
        stp    r19,r20,[sp, #framesz -32]   // save INT pair
        stp    d8,d9,[sp, #framesz -16]     // save FP pair
    ```

   上記の 1 プロローグを比較すると、利点は、すべてのレジスタ保存は、手順の命令を割り当て、1 つだけのスタックの直後に実行する準備が整いましたです。 したがってはありませんへの対策を命令レベルの並列処理を妨げる sp に。

1. 連結するには、フレーム サイズ > 512 (alloca なしの関数は省略可能)

    ```asm
        stp    r29, lr, [sp, -80]!          // pre-indexed, save <r29,lr>
        stp    r19,r20,[sp,16]              // save in INT regs
        stp    r21,r22,[sp,32]              // ...
        stp    d8,d9,[sp,48]                // save in FP regs
        stp    d10,d11,[sp,64]
        mov    r29,sp                       // r29 points to top of local area
        sub    sp,#framesz-80               // allocate the remaining local area
    ```

   最適化のために、「reg ペア」および前/後-indexed オフセットでアドレス指定モードより優れたカバレッジを提供するローカル エリア内の任意の位置にある r29 を配置することができます。 フレーム ポインターの下の [ローカル] のアクセスは、SP のベース

1. 連結するには、フレーム サイズ > 4 K、alloca() の有無

    ```asm
        stp    r29, lr, [sp, -80]!          // pre-indexed, save <r29,lr>
        stp    r19,r20,[sp,16]              // save in INT regs
        stp    r21,r22,[sp,32]              // ...
        stp    d8,d9,[sp,48]                // save in FP regs
        stp    d10,d11,[sp,64]
        mov    r29,sp                       // r29 points to top of local area
        mov    r8, #framesz/16
        bl     chkstk
        sub    sp, r8*16                    // allocate remaining frame
                                            // end of prolog
        ...
        sp = alloca                         // more alloca() in body
        ...
                                            // beginning of epilog
        mov    sp,r29                       // sp points to top of local area
        ldp    d10,d11, [sp,64],
        ...
        ldp    r29, lr, [sp], -80           // post-indexed, reload <r29,lr>
    ```

## <a name="arm64-exception-handling-information"></a>ARM64 例外処理情報

### <a name="pdata-records"></a>.pdata レコード

.Pdata レコードは、PE バイナリ内のすべてのスタック操作関数を記述する固定長項目の順序付き配列です。 慎重に、語句「スタック操作」でに注意してください: リーフ関数をローカル ストレージを必要としないと、非 volatile レジスタを保存/復元を必要としないには、.pdata レコードは不要これらは、領域を節約する明示的に省略する必要があります。 これらの関数のいずれかからのアンワインドは、呼び出し元に移動する LR からリターン アドレスを単に取得できます。

ARM64 用には、各 .pdata レコードは、長さは 8 バイトです。 その 1 秒後に、最初の単語で関数の 32 ビットの RVA を開始各レコードの場所の一般的な形式には、いずれかの可変長 .xdata ブロックへのポインターまたは標準関数アンワインド シーケンスを記述するパックされたワードが含まれています。

![.pdata レコードのレイアウト](media/arm64-exception-handling-pdata-record.png ".pdata レコードのレイアウト")

フィールドは次のとおりです。

- **関数の開始の RVA**は関数の先頭の 32 ビットの rva を示します。

- **フラグ**は 2 番目の .pdata ワードの残りの 30 ビットを解釈する方法を示す 2 ビット フィールドです。 場合**フラグ**は 0 です。 その後、残りのビット フォーム、**例外情報 RVA** (下位 2 ビットで暗黙的に 0)。 場合**フラグ**フォーム、残りのビットが 0 以外の場合、**パックされたアンワインド データ**構造体。

- **例外情報 RVA** .xdata セクションに格納された可変長例外情報構造のアドレスです。 このデータは、4 バイトでアラインされている必要があります。

- **アンワインド データをパック**は正規の形式と仮定すると、関数からのアンワインドに必要な操作の圧縮の説明です。 この場合、.xdata レコードは必要ありません。

### <a name="xdata-records"></a>.xdata レコード

パックされたアンワインド形式では関数のアンワインドの記述に十分でない場合、可変長の .xdata レコードを作成する必要があります。 このレコードのアドレスは、.pdata レコードの第 2 ワードに格納されています。 .Xdata の形式は、単語のパックされた可変長セットを示します。

![.xdata レコード レイアウト](media/arm64-exception-handling-xdata-record.png ".xdata レコードのレイアウト")

このデータは、4 つのセクションに分かれています。

1. 1 つまたは 2 ワード ヘッダー構造体の全体的なサイズを記述して、データの重要な機能を提供します。 2 番目の単語が存在するは、両方の場合のみ、**エピローグ カウント**と**ごまかして**フィールドが 0 に設定されます。 これらは、ヘッダー内のビット フィールドです。

   a.  **関数の長さ**は 4 で除算してバイト単位の関数の合計長を示す 18 ビット フィールドです。 関数が 1 M よりも大きい場合は、関数を記述する pdata と xdata の複数のレコードが使用する必要があります。 参照してください、[大きな関数](#large-functions)詳細セクション。

   b.  **バージョン**は残りの xdata のバージョンを示す 2 ビット フィールドです。 、この記事の執筆時点バージョン 0 のみが定義されているし、つまり 1 ~ 3 の値が許可されていません。

   c. **X**は例外データの (0) がない場合、または (1) の存在を示す 1 ビット フィールドです。

   d. **E**は 1 つのビット フィールドは、以降の (0) の単語追加のスコープを必要とするのではなく、ヘッダー (1) に 1 つのエピローグがパックされている情報を記述することを示します。

   e. **エピローグ カウント**の状態に応じて 2 つの意味を持つ 5 ビット フィールドは、 **E**ビット。

      1. 場合**E** 0 に設定されている。 2 番目のセクションで説明されている例外のスコープの総数の数を指定します。 関数で 31 を超えるスコープが存在しない場合、**ごまかして**フィールドは、拡張ワードが必要であることを示す 0 に設定する必要があります。

      2. 場合**E**このフィールドは、1 つとエピローグのみを記述する最初のアンワインド コードのインデックスを指定し、1 に設定されます。

   f. **コード ワード**はすべてのセクション 4 では、アンワインド コードを格納するために必要な 32 ビット ワードの数を示す 5 ビット フィールドです。 31 を超える単語が必要な場合 (つまり、複数の 124 アンワインド コード バイト)、このフィールドは、拡張ワードが必要であることを示す 0 に設定する必要があります。

   g. **エピローグの数を拡張**と**拡張コード ワード**16 ビットと 8 ビットのフィールドは、それぞれ、エピローグの数が異常に多いをエンコードするためのより多くの領域を提供する、または異常に多数のアンワインド コード ワード。 これらのフィールドを含む拡張ワードが存在するは、両方の場合のみ、**エピローグ カウント**と**ごまかして**ヘッダーの最初の単語内のフィールドが 0 に設定されます。

1. 例外データでは、後に場合**エピローグ カウント**、エピローグ スコープに関する情報の一覧が、単語を 1 つにまとめられ、開始オフセットの昇順に格納されているは 0 ではありません。 各スコープには、次のビットが含まれています。

   a.  **エピローグ開始オフセット**関数の先頭からの相対エピローグの 4 で除算してバイト単位のオフセットを記述する 18 ビット フィールド

   b.  **Res** 4 ビット フィールドが将来拡張するために予約されています。 この値は 0 である必要があります。

   c. **エピローグ開始インデックス**10 ビットは、(よりもより多くのビットを 2**拡張コード ワード**) フィールドの最初のバイトのインデックスを示すアンワインド コードをこのエピローグを記述します。

1. エピローグ スコープの一覧では、アンワインド コードを含むバイトの配列に関しては後、は、後のセクションで詳しく説明します。 この配列は、最も近いフルワード境界の末尾に埋め込まれます。 バイトは、リトル エンディアン順で格納され、リトル エンディアン モードで直接フェッチ可能になっています。

1. アンワインド コード バイトより後に最後に、(場合に、 **X**ヘッダー内のビットが 1 に設定された) 例外ハンドラーの情報を取得します。 これは、1 つの**例外ハンドラーの RVA**可変長の例外ハンドラーで必要なデータ量によって直後に自体には、例外ハンドラーのアドレスを指定します。

上記の .xdata レコードでは、最初の 8 バイトをフェッチしてから (マイナス記号に続く可変サイズの例外データの長さ) レコードの完全なサイズを計算することができるように設計されています。 次のコード スニペットは、レコードのサイズを計算します。

```cpp
ULONG ComputeXdataSize(PULONG *Xdata)
{
    ULONG EpilogScopes;
    ULONG Size;
    ULONG UnwindWords;

    if ((Xdata[0] >> 27) != 0) {
        Size = 4;
        EpilogScopes = (Xdata[0] >> 22) & 0x1f;
        UnwindWords = (Xdata[0] >> 27) & 0x0f;
    } else {
        Size = 8;
        EpilogScopes = Xdata[1] & 0xffff;
        UnwindWords = (Xdata[1] >> 16) & 0xff;
    }

    Size += 4 * EpilogScopes;
    Size += 4 * UnwindWords;
    if (Xdata[0] & (1 << 20)) {
        Size += 4;        // exception handler RVA
    }
    return Size;
}
```

プロローグおよび各エピローグ アンワインド コードを独自のインデックスには、テーブルは、それらの間で共有し、可能であり、完全一般的でない) に注意するべきことができますを共有する (例のセクション ベルで例 2 を参照するのと同じコードow)。 コンパイラ ライターが最適化この場合、具体的に指定できる最大のインデックスは 255 ですので、特定の関数のアンワインド コードの合計数を減らしてします。

### <a name="unwind-codes"></a>アンワインド コード

アンワインド コードの配列は、正確なを元に戻す操作が必要な順序で、プロローグの効果を元に戻す方法について説明するシーケンスのプールです。 アンワインド コードは、バイトの文字列としてエンコードし、ミニ命令セットと考えることができます。 実行が完了したらは、呼び出し元の関数の返送先住所は、lr レジスタであり、すべての非 volatile レジスタは、関数が呼び出された時点でその値に復元されます。

場合は、関数本体で、決して干渉し、プロローグまたはエピローグの) を 1 つのシーケンスだけが必要なだけ発生する例外が保証されました。 ただし、Windows アンワインド モデルでは、部分的に実行されたプロローグまたはエピローグからアンワインドするできることが必要です。 この要件を満たすためには、アンワインド コード慎重に設計されて、プロローグとエピローグでは、次の関連オペコードへの 1:1、明確にマップするよう。 これは、次のような結果をもたらします。

1. アンワインド コードの数をカウントすることによって、プロローグとエピローグの長さを計算することができます。

1. エピローグ スコープの開始後の命令の数をカウントすることによって、同等数のアンワインド コードをスキップし、部分的に実行されたを完了するためのシーケンスの残りの部分を実行することは、エピローグが実行していたことをアンワインドします。

1. プロローグの終了前に、の命令の数をカウントすることによって、同等数のアンワインド コードをスキップし、実行が完了したプロローグの部分のみを元に戻す、シーケンスの残りの部分を実行することができます。

アンワインド コードは、次の表に従ってエンコードされます。 すべてのアンワインド コードは大きなスタックによって割り当てられる 1 つを除くの 1 つまたは 2 バイト。 完全には、21 のアンワインド コードがあります。 各アンワインド コード マップ正確に 1 つの命令プロローグとエピローグで部分的に実行されたプロローグとエピローグのアンワインドを許可するために。

|アンワインド コード|Bits と解釈|
|-|-|
|`alloc_s`|000xxxxx: サイズの小さいスタックを割り当てる\<512 (2 ^5 * 16)。|
|`save_r19r20_x`|    001zzzzz: 保存\<r19、r20 > [sp #Z * 8] にあるペア!、事前にインデックス付きのオフセット >-248 を = |
|`save_fplr`|        01zzzzzz: 保存\<r29、lr > ペアで [sp + #Z * 8]、オフセット\<504 を = です。 |
|`save_fplr_x`|        10zzzzzz: 保存\<r29、lr > ペアで [sp-(#Z + 1) * 8]!、事前にインデックス付きのオフセット > -512 を = |
|`alloc_m`|        11000 xxx ' xxxxxxxx: サイズの大きなスタックを割り当てる\<16 k (2 ^11 * 16)。 |
|`save_regp`|        110010xx'xxzzzzzz: ある r(19+#X) ペアを保存する [sp + #Z * 8]、オフセット\<504 を = |
|`save_regp_x`|        110011xx'xxzzzzzz: ペア r(19+#X) での保存 [sp-(#Z + 1) * 8]!、事前にインデックス付きのオフセット > -512 を = |
|`save_reg`|        110100xx'xxzzzzzz: reg r(19+#X) での保存 [sp + #Z * 8]、オフセット\<504 を = |
|`save_reg_x`|        1101010 x'xxxzzzzz: reg r(19+#X) での保存 [sp-(#Z + 1) * 8]!、事前にインデックス付きのオフセット >-256 を = |
|`save_lrpair`|         1101011 x'xxzzzzzz: ペアの保存\<r19 + 2 *#X, lr > で [sp + #Z*8]、オフセット\<504 を = |
|`save_fregp`|        1101100 x'xxzzzzzz: 保存でペア d(8+#X) [sp + #Z * 8]、オフセット\<504 を = |
|`save_fregp_x`|        1101101 x'xxzzzzzz: ペアの d(8+#X) 保存 [sp-(#Z + 1) * 8]!、事前にインデックス付きのオフセット > -512 = |
|`save_freg`|        1101110 x'xxzzzzzz: reg d(8+#X) での保存 [sp + #Z * 8]、オフセット\<504 を = |
|`save_freg_x`|        11011110' xxxzzzzz: reg d(8+#X) での保存 [sp-(#Z + 1) * 8]!、事前にインデックス付きのオフセット >-256 を = |
|`alloc_l`|         11100000' xxxxxxxx 'xxxxxxxx' xxxxxxxx: サイズの大きなスタックを割り当てる\<256 M (2 ^24 * 16) |
|`set_fp`|        11100001: r29 設定: と: mov r29、sp |
|`add_fp`|        11100010' xxxxxxxx: r29 のセットアップ: r29、sp、#x 追加 * 8 |
|`nop`|            11100011: なしのアンワインド操作が必要です。 |
|`end`|            11100100: アンワインド コードの最後。 意味エピローグで廃止します。 |
|`end_c`|        11100101: チェーンの現在のスコープ内でのアンワインド コードの最後。 |
|`save_next`|        11100110: 次の非揮発性 Int を保存または FP はペアを登録します。 |
|`arithmetic(add)`|    11100111' 000zxxxx: cookie reg(z) を lr を追加 (0 = x28、1 = sp)。lr, lr, reg(z) を追加します。 |
|`arithmetic(sub)`|    11100111' 001zxxxx: lr から cookie reg(z) を sub (0 = x28、1 = sp)。lr, lr, reg(z) を sub します。 |
|`arithmetic(eor)`|    11100111' 010zxxxx: cookie reg(z) で eor lr (0 = x28、1 = sp)。eor lr、lr、reg(z) |
|`arithmetic(rol)`|    11100111' 0110xxxx: cookie reg (x28); と lr のシミュレートされた rolxip0 neg x28; を =ror lr、xip0 |
|`arithmetic(ror)`|    11100111' 100zxxxx: cookie reg(z) で ror lr (0 = x28、1 = sp)。ror lr、lr、reg(z) |
| |            11100111: xxxz----: ---- reserved |
| |              11101xxx: asm ルーチンの生成のみカスタム スタック場合次に予約されています |
| |              11101001:カスタム MSFT_OP_TRAP_FRAME スタック |
| |              11101010:カスタム MSFT_OP_MACHINE_FRAME スタック |
| |              11101011:カスタム MSFT_OP_CONTEXT スタック |
| |              1111xxxx: reserved |

複数のバイトをカバーする大きな値を含む手順については、最上位ビットが最初に格納されます。 上記のアンワインド コードは、アンワインド コードのバイト単位の合計サイズを把握することは単純に、コードの最初のバイトを探して、されるように設計されています。 プロローグ/エピローグに指示する命令を正確に各アンワインド コードがマップされている、プロローグまたはエピローグのサイズを計算する実行する必要があるすべてを決定する参照テーブルまたは同様のデバイスを使用して、最後に、シーケンスの先頭から説明しますが、どのくらいの期間 corオペコードの応答は次のとおりです。

プロローグの中で後にインデックス付きのオフセット アドレスを使用できませんに注意してください。 すべてのオフセットの範囲 (#Z) は、STP/STR のアドレス以外のエンコードと一致`save_r19r20_x`どの 248 で十分です (10 Int レジスタ + 8 FP レジスタ + 8 つの入力レジスタ) の領域をすべて保存します。

`save_next` Int の保存に従うか FP 揮発性のペアを登録する必要があります: `save_regp`、 `save_regp_x`、 `save_fregp`、 `save_fregp_x`、 `save_r19r20_x`、もう 1 つまたは`save_next`します。 「成長」の順序で次の 16 バイトのスロットにある [次へ] のレジスタのペアを保存します。 `save-next` 次の`save_next`最後 Int レジスタのペアを指す FP レジスタ ペアの最初を表します。

分離の必要はありませんは、同じ手順をジャンプ通常のサイズを返すので、`end`末尾呼び出しのシナリオのコードをアンワインドします。

`end_c` 最適化のための関数を連続していないフラグメントを処理するために設計されています。 A`end_c`アンワインド コードを現在のスコープの末尾を示す必要がありますが続くの実際の使用が終了したアンワインド コードの別の系列`end`します。 アンワインド コード間`end_c`と`end`(「ファントム」プロローグ) の親領域のプロローグの演算を表します。  詳細と例については、以下のセクションで説明します。

### <a name="packed-unwind-data"></a>パックされたアンワインド データ

正規の形式が以下に示すがプロローグとエピローグのフォローが搭載された関数のアンワインド データを使用して、アンワインド データの完全 .xdata レコードの必要性を排除し、提供するコストを大幅に削減します。 標準のプロローグとエピローグは、例外ハンドラーが不要し、標準的な順序でセットアップと破棄操作を実行する単純な関数の一般的な要件を満たすために設計されています。

パックの .pdata レコードの形式のアンワインドこのようなデータが表示されます。

![.pdata レコードでパックされたアンワインド データ](media/arm64-exception-handling-packed-unwind-data.png ".pdata レコードでパックされたアンワインド データ")

フィールドは次のとおりです。

- **関数の開始の RVA**は関数の先頭の 32 ビットの rva を示します。
- **フラグ**2 ビット フィールドは、次の意味で、上記と。
  - 00 = パックされたアンワインド データは使用されません。残りのビットは .xdata レコードをポイントします。
  - 01 = パックされたアンワインド データの 1 つのプロローグとエピローグ スコープの末尾、先頭にある次のように使用
  - 10 = パックされたアンワインド データの任意のプロローグとエピローグ; なしのコードを以下に示すように使用これは、分離された関数のセグメントを記述するために便利です。
  - 11 = 予約されています。
- **関数の長さ**11 ビット フィールドは 4 で除算してバイト単位で関数全体の長さを提供します。 関数が 8 k より大きい場合は、フル .xdata レコードを代わりに使用する必要があります。
- **フレーム サイズを**はこの関数は、16 で割った値に割り当てられたスタックのバイト数を示す 9 ビット フィールドです。 スタックの (8 k から 16) バイトより大きいを割り当てることが関数には、フル .xdata レコードを使用する必要があります。 これには、ローカル変数領域、パラメーター領域、呼び出し先保存 Int と FP 領域、およびホーム パラメータ エリアで、送信は、動的な割り当て領域を除外が含まれます。
- **CR**関数がフレーム チェーンと戻り値のリンクを設定する追加の命令を含めるかどうかを示す 2 ビット フラグです。
  - 00 = チェーン関数は、 \<r29、lr > ペアのスタックには保存されません。
  - 01 = チェーン関数は、 \<lr > スタックに保存されます
  - 10 = 予約されています。
  - 11 = 連鎖的に呼び出す関数は、プロローグとエピローグでストア/読み込みのペアの命令が使用される\<r29、lr >
- **H**関数の先頭に格納することでは、関数の整数パラメーター ホームかどうかを示す 1 ビット フラグは、(r0 r7) を登録します。 (0 = レジスタに 1 をホームいない元のレジスタを =)。
- **RegI**は正規のスタックの場所に保存された非 volatile INT レジスタ (r19 r28) の数を示す 4 ビット フィールドです。
- **RegF**は正規のスタックの場所に保存された非 volatile FP レジスタ (d8 d15) の数を示す 3 ビット フィールドです。 (RegF = 0: FP レジスタが保存されていません。RegF > 0。RegF + 1 の FP レジスタ保存されます)。 パックされたアンワインド データは FP の 1 つだけのレジスタを保存する関数を使用できません。

上記のセクションでは 1、パラメーター領域の送信) (なし、2、3 および 4 のカテゴリに分類される標準プロローグは、パックされたアンワインド形式で表現できます。  エピローグとよく似ていますフォームでは、以下の正規関数を除く**H** 、影響を与えません、`set_fp`命令を省略すると、およびエピローグ内の手順として各ステップの手順の順序が逆になっています。 パックされた xdata のアルゴリズムでは、次の表に記載された手順に従います。

手順 0:各領域のサイズの事前計算を実行します。

手順 1: Int 呼び出し先保存済みレジスタを保存します。

手順 2: この手順では、前半のセクションでは 4 種類に固有です。 lr が Int の範囲の最後に保存されます。

手順 3: FP 呼び出し先保存済みレジスタを保存します。

手順 4: ホームのパラメータ エリアには、入力引数を保存します。

手順 5: ローカルの領域を含む、残りのスタックを割り当てる\<r29、lr > のペアとパラメーターの領域を送信します。 5a は、正規の種類を 1 に対応します。 5b と 5 c は正規の種類 2 です。 5 d 5 e 3 の両方の種類とは 4」と入力します。

ステップ番号|フラグの値|手順の数|オペコード|アンワインド コード
-|-|-|-|-
0|||`#intsz = RegI * 8;`<br/>`if (CR==01) #intsz += 8; // lr`<br/>`#fpsz = RegF * 8;`<br/>`if(RegF) #fpsz += 8;`<br/>`#savsz=((#intsz+#fpsz+8*8*H)+0xf)&~0xf)`<br/>`#locsz = #famsz - #savsz`|
1|0 < **regI** < = 10|RegI / 2 + **RegI** % 2|`stp r19,r20,[sp,#savsz]!`<br/>`stp r21,r22,[sp,16]`<br/>`...`|`save_regp_x`<br/>`save_regp`<br/>`...`
2|**CR**01 = = *|1|`str lr,[sp, #intsz-8]`\*|`save_reg`
3|0 < **RegF** < = 7|(RegF + 1)/2 +<br/>(RegF + 1) %2)。|`stp d8,d9,[sp, #intsz]`\*\*<br/>`stp d10,d11,[sp, #intsz+16]`<br/>`...`<br/>`str d(8+RegF),[sp, #intsz+#fpsz-8]`|`save_fregp`<br/>`...`<br/>`save_freg`
4|**H** 1 = =|4|`stp r0,r1,[sp, #intsz+#fpsz]`<br/>`stp r2,r3,[sp, #intsz+#fpsz+16]`<br/>`stp r4,r5,[sp, #intsz+#fpsz+32]`<br/>`stp r6,r7,[sp, #intsz+#fpsz+48]`|`nop`<br/>`nop`<br/>`nop`<br/>`nop`
5a|**CR** 11 を = = (& a) (& a) #locsz<br/> <= 512|2|`stp r29,lr,[sp,-#locsz]!`<br/>`mov r29,sp`\*\*\*|`save_fplr_x`<br/>`set_fp`
5b|**CR** 11 を = = (&AMP; A) (&AMP; A)<br/>512 < #locsz <= 4088|3|`sub sp,sp, #locsz`<br/>`stp r29,lr,[sp,0]`<br/>`add r29, sp, 0`|`alloc_m`<br/>`save_fplr`<br/>`set_fp`
c.|**CR** == 11 && #locsz > 4088|4|`sub sp,sp,4088`<br/>`sub sp,sp, (#locsz-4088)`<br/>`stp r29,lr,[sp,0]`<br/>`add r29, sp, 0`|`alloc_m`<br/>`alloc_s`/`alloc_m`<br/>`save_fplr`<br/>`set_fp`
5 d|(**CR** 00 = = \| \| **CR**01 = =) (&AMP; A) (&AMP; A)<br/>#locsz <= 4088|1|`sub sp,sp, #locsz`|`alloc_s`/`alloc_m`
5e|(**CR** 00 = = \| \| **CR**01 = =) (&AMP; A) (&AMP; A)<br/>#locsz > 4088|2|`sub sp,sp,4088`<br/>`sub sp,sp, (#locsz-4088)`|`alloc_m`<br/>`alloc_s`/`alloc_m`

\* 場合**CR** 01 = = と**RegI**奇数、手順 2. と手順 1. で最後の save_rep が 1 つ save_regp にマージされます。

\*\* 場合**RegI** == **CR** 0、= = と**RegF** ! = 0、最初の stp、浮動小数点数は、前置デクリメント。

\*\*\* 対応する命令`mov r29, sp`はエピローグ内に存在します。 パックされたアンワインド データは、関数が r29 から sp の復元が必要な場合に使用できません。

### <a name="unwinding-partial-prologs-and-epilogs"></a>アンワインドの部分的なプロローグとエピローグ

最も一般的なアンワインドの場合は、プロローグとエピローグのすべてから、関数の本体で発生した例外または呼び出し 1 つです。 この場合、アンワインドは簡単です。、アンワインダーが単にアンワインド配列のインデックス 0 から開始と終了オペコードが検出されるまでに、コードの実行を開始します。

場合は、プロローグまたはエピローグの実行中に発生する例外または割り込み正しくアンワインドが発生しにくくなります。 このような場合は、スタック フレームは部分的にのみ構築、および正確に行われたために、正しく元に戻すことを確認することです。

たとえば、このプロローグとエピローグ シーケンスを実行します。

```asm
0000:    stp    r29, lr, [sp, -256]!        // save_fplr_x  256 (pre-indexed store)
0004:    stp    d8,d9,[sp,224]              // save_fregp 0, 224
0008:    stp    r19,r20,[sp,240]            // save_regp 0, 240
000c:    mov    r29,sp                      // set_fp
         ...
0100:    mov    sp,r29                      // set_fp
0104:    ldp    r19,r20,[sp,240]            // save_regp 0, 240
0108:    ldp    d8,d9,[sp,224]              // save_fregp 0, 224
010c:    ldp    r29, lr, [sp, -256]!        // save_fplr_x  256 (post-indexed load)
0110:    ret     lr                         // end
```

各オペコードは、この操作を記述する適切なアンワインド コードを示します。 一連のプロローグのアンワインド コードは、(エピローグの最後の命令は含みません) エピローグのアンワインド コードの正確なミラー イメージを最初に注目するには。 これは一般的な状況とこのため、アンワインドのプロローグ コードは常と見なされます、プロローグの実行順序とは逆の順序で格納します。

したがって、プロローグとエピローグの両方での一般的な一連のアンワインド コードのままは。

`set_fp`, `save_regp 0,240`, `save_fregp,0,224`, `save_fplr_x_256`, `end`

(これは、関数内のオフセット 0x100 で開始する) エピローグ内のオフセット 0 で以降 (詳細は通常の順序であるため簡単です)、エピローグのケースでは、とってい、完全なアンワインド シーケンスを実行するようにクリーンアップがまだ行われていません。 見つかった場合自分たちで 1 つの命令 (エピローグ内のオフセット 2) で、最初のアンワインド コードをスキップしてアンワインドできますが正常にします。 このような状況を一般化し、オペコードの間で 1 対 1 マッピングを想定し、アンワインド コード、おできます状態ことエピローグで命令 n からのアンワインドしますが場合する必要があります最初の n 個のアンワインド コードをスキップし、そこから実行を開始します。

類似するロジックは機能する、プロローグを除く逆の順序でこれがわかります。 プロローグ内のオフセット 0 からのアンワインドしますが場合、何も実行するとします。 オフセット 2 からさかのぼること場合、で、1 つの命令であるし、末尾からのアンワインド シーケンスの 1 つのアンワインド コードの実行を開始すると (コードが逆の順序で格納されていることを忘れないでください)。 ここすぎるでできる一般化命令 n プロローグ内からのアンワインドいますが場合、は、コードの一覧の末尾から n 個のアンワインド コードの実行を開始する必要があります。

ここでは常にプロローグおよびエピローグ コードを正確に一致する場合です。 このため、アンワインド配列をコードのいくつかのシーケンスが含まれる必要があります。 コードの処理を開始する位置のオフセットを決定するには、次のロジックを使用します。

1. 内からのアンワインド、関数の本体が、単にインデックス 0 でアンワインド コードの実行を開始し、"end"オペコードに到達するまで続行します。

1. エピローグ内からのアンワインドの場合は、開始点として、エピローグ スコープで提供されるエピローグ固有の開始インデックスを使用します。 エピローグの開始からのバイト数の対象の PC を計算します。 すべての実行済みの命令に対応するまでは、アンワインド コードをスキップしています、アンワインド コード前進します。 その時点で開始し、実行します。

1. プロローグ内からのアンワインド、インデックス 0 を使用して、開始点として。 シーケンスからプロローグ コードの長さを計算し、プロローグの末尾からのバイト数の対象の PC を計算します。 Not まだ実行手順については、のすべてに対応するまでは、アンワインド コードをスキップしています、アンワインド コード前進します。 その時点で開始し、実行します。

その結果、これらの規則のプロローグのアンワインド コードあり必要があります常に、配列の最初は一般に、本体内からのアンワインドの大文字と小文字をアンワインドするために使用するコードもします。 すべてのエピローグ固有のコード シーケンスは、後すぐに従う必要があります。

### <a name="function-fragments"></a>関数フラグメント

最適化のためのコードとその他の理由は、分離されたフラグメントの (リージョンとも呼ばれます) に関数を分割することをお勧め場合があります。 これが完了したら、結果として得られる各関数フラグメント独自個別の .pdata (と必要可能性がある .xdata) レコード。

分離されたセカンダリを持つ独自のプロローグ、フラグメントのプロローグでスタック調整は行われませんことが期待されます。 すべてのスタック領域が必要なセカンダリ リージョンをその親リージョン (またはと呼ばれるホスト) によって事前割り当てる必要があります。 スタック ポインター操作は、関数の元のプロローグの厳密にこの維持されます。

関数フラグメントの一般的な事例は、そのコンパイラで「コード分離」とそのホストの関数コードの領域が移動します。 コードの分離によって結果が次の 3 つの異常な場合があります。

#### <a name="example"></a>例:

- (リージョン 1: 開始)

    ```asm
        stp     r29, lr, [sp, -256]!    // save_fplr_x  256 (pre-indexed store)
        stp     r19,r20,[sp,240]        // save_regp 0, 240
        mov     r29,sp                  // set_fp
        ...
    ```

- (リージョン 1: 終了)
- (領域 3: 開始)

    ```asm
        ...
    ```

- (領域 3: 終了)
- (リージョン 2: 開始)

    ```asm
    ...
        mov     sp,r29                  // set_fp
        ldp     r19,r20,[sp,240]        // save_regp 0, 240
        ldp     r29, lr, [sp, -256]!    // save_fplr_x  256 (post-indexed load)
        ret     lr                      // end
    ```

- (リージョン 2: 終了)

1. プロローグのみ (リージョン 1: すべてのエピローグが分離されたリージョンでは)。

   プロローグのみを記述する必要があります。 これは、コンパクト .pdata 形式で表されることはできません。 この、フル .xdata の場合、エピローグの数を設定して表すことが 0 を = です。 上記の例では、リージョン 1 を参照してください。

   アンワインド コード: `set_fp`、 `save_regp 0,240`、 `save_fplr_x_256`、`end`します。

1. エピローグのみ (リージョン 2: プロローグは、ホストのリージョン内)

   この領域にジャンプ時のコントロールによってすべてのプロローグ コードが実行されていると見なされます。 部分的なアンワインドは、通常の関数と同様、エピローグで発生します。 リージョンには、この型は、コンパクト .pdata で表すことはできません。 Xdata の完全なレコードには、かっこで囲まれた、「ファントム」プロローグでエンコードできる、`end_c`と`end`アンワインド コードのペア。  先頭`end_c`プロローグのサイズがゼロであることを示します。 エピローグ開始する 1 つのエピローグ ポイントのインデックス`set_fp`します。

   アンワインド コード 2 のリージョンの: `end_c`、 `set_fp`、 `save_regp 0,240`、 `save_fplr_x_256`、`end`します。

1. プロローグまたはエピローグなし (領域 3: プロローグとすべてのエピローグが別のフラグメントには)。

   フラグの設定を使用して、コンパクト .pdata 形式を適用できます = 10。 フル .xdata レコード、エピローグ カウントに 1 を = です。 アンワインド コードは、上記の 2 のリージョンのものと同じ、エピローグの開始インデックスを指す`end_c`します。 コードのこの領域で部分アンワインドは起こりません。

別のより複雑な場合の関数フラグメントは、関数のエントリのプロローグの外になるまでのいくつかの呼び出し先保存済みレジスタの保存を遅延することもできますそのコンパイラで「折り返しを圧縮する」です。

- (リージョン 1: 開始)

    ```asm
        stp     r29, lr, [sp, -256]!    // save_fplr_x  256 (pre-indexed store)
        stp     r19,r20,[sp,240]        // save_regp 0, 240
        mov     r29,sp                  // set_fp
        ...
    ```

- (リージョン 2: 開始)

    ```asm
        stp     r21,r22,[sp,224]        // save_regp 2, 224
        ...
        ldp     r21,r22,[sp,224]        // save_regp 2, 224
    ```

- (リージョン 2: 終了)

    ```asm
        ...
        mov     sp,r29                  // set_fp
        ldp     r19,r20,[sp,240]        // save_regp 0, 240
        ldp     r29, lr, [sp, -256]!    // save_fplr_x  256 (post-indexed load)
        ret     lr                      // end
    ```

- (リージョン 1: 終了)

リージョン 1 のプロローグには、スタック領域が事前に割り当てられます。 そのリージョン 2 がそのホスト関数から移動させる場合でも同じアンワインド コードが必要がありますに注意してください。

リージョン 1: `set_fp`、 `save_regp 0,240`、 `save_fplr_x_256`、`end`エピローグの開始インデックスを持つを指す`set_fp`通常どおりです。

リージョン 2: `save_regp 2, 224`、 `end_c`、 `set_fp`、 `save_regp 0,240`、 `save_fplr_x_256`、`end`します。 エピローグ開始インデックスは、最初のアンワインド コードを指す`save_regp 2, 224`します。

### <a name="large-functions"></a>大きな関数

.Xdata ヘッダー内のビット フィールドが 1 m 分の制限を超える関数を記述するフラグメントを利用できます。 このような非常に大きい関数を記述するには、単純にする必要が 1 M より小さいフラグメントに分割します。 各フラグメントは、エピローグは複数の部分に分割しないように調整する必要があります。

関数の最初のフラグメントのみプロローグ; にはその他のすべてのフラグメントは、プロローグがないものとしてマークされます。 各フラグメントは、存在エピローグの数に応じて、0 個以上のエピローグを含めることができます。 フラグメント内の各エピローグ スコープが関数の先頭ではない、フラグメントの開始からの相対開始オフセットを指定するために留意してください。

ありませんプロローグとエピローグのないフラグメントがある場合独自 .pdata (および場合によって .xdata) がまだ必要です。 レコードが、関数の本体内からアンワィンドする方法について説明します。

## <a name="examples"></a>使用例

### <a name="example-1-frame-chained-compact-form"></a>例 1: フレーム チェーン、compact フォーム

```asm
|Foo|     PROC
|$LN19|
    str     x19,[sp,#-0x10]!        // save_reg_x
    sub     sp,sp,#0x810            // alloc_m
    stp     fp,lr,[sp]              // save_fplr
    mov     fp,sp                   // set_fp
                                    //  end of prolog
    ...

|$pdata$Foo|
    DCD     imagerel     |$LN19|
    DCD     0x416101ed
    ;Flags[SingleProEpi] functionLength[492] RegF[0] RegI[1] H[0] frameChainReturn[Chained] frameSize[2080]
```

### <a name="example-2-frame-chained-full-form-with-mirror-prolog--epilog"></a>例 2:フレーム チェーン、ミラー プロローグとエピローグの完全な形式

```asm
|Bar|     PROC
|$LN19|
    stp     x19,x20,[sp,#-0x10]!    // save_regp_x
    stp     fp,lr,[sp,#-0x90]!      // save_fplr_x
    mov     fp,sp                   // set_fp
                                    // end of prolog
    ...
                                    // begin of epilog, a mirror sequence of Prolog
    mov     sp,fp
    ldp     fp,lr,[sp],#0x90
    ldp     x19,x20,[sp],#0x10
    ret     lr

|$pdata$Bar|
    DCD     imagerel     |$LN19|
    DCD     imagerel     |$unwind$cse2|
|$unwind$Bar|
    DCD     0x1040003d
    DCD     0x1000038
    DCD     0xe42291e1
    DCD     0xe42291e1
    ;Code Words[2], Epilog Count[1], E[0], X[0], Function Length[6660]
    ;Epilog Start Index[0], Epilog Start Offset[56]
    ;set_fp
    ;save_fplr_x
    ;save_r19r20_x
    ;end
```

EpilogStart インデックス [0] は、プロローグのアンワインド コードの同じシーケンスを指すことに注意してください。

### <a name="example-3-variadic-unchained-function"></a>例 3:チェーンの可変個引数関数

```asm
|Delegate| PROC
|$LN4|
    sub     sp,sp,#0x50
    stp     x19,lr,[sp]
    stp     x0,x1,[sp,#0x10]        // save incoming register to home area
    stp     x2,x3,[sp,#0x20]        // ...
    stp     x4,x5,[sp,#0x30]
    stp     x6,x7,[sp,#0x40]        // end of prolog
    ...
    ldp     x19,lr,[sp]             // beginning of epilog
    add     sp,sp,#0x50
    ret     lr

    AREA    |.pdata|, PDATA
|$pdata$Delegate|
    DCD     imagerel |$LN4|
    DCD     imagerel |$unwind$Delegate|

    AREA    |.xdata|, DATA
|$unwind$Delegate|
    DCD     0x18400012
    DCD     0x200000f
    DCD     0xe3e3e3e3
    DCD     0xe40500d6
    DCD     0xe40500d6
    ;Code Words[3], Epilog Count[1], E[0], X[0], Function Length[18]
    ;Epilog Start Index[4], Epilog Start Offset[15]
    ;nop        // nop for saving in home area
    ;nop        // ditto
    ;nop        // ditto
    ;nop        // ditto
    ;save_lrpair
    ;alloc_s
    ;end
```

メモ:EpilogStart インデックス [4] は、プロローグ アンワインド コード (部分的に再利用アンワインド配列) の中間を指します。

## <a name="see-also"></a>関連項目

[ARM64 ABI 規則の概要](arm64-windows-abi-conventions.md)<br/>
[ARM 例外処理](arm-exception-handling.md)
