---
title: DLL と実行形式のリンク
ms.date: 11/04/2016
helpviewer_keywords:
- run time [C++], linking
- dynamic load linking [C++]
- linking [C++], DLLs
- DLLs [C++], linking
- implicit linking [C++]
- explicit linking [C++]
- executable files [C++], linking to DLLs
- loading DLLs [C++]
ms.assetid: 7592e276-dd6e-4a74-90c8-e1ee35598ea3
ms.openlocfilehash: c4f9ea7a3606612189e85401b75a0577896fd90e
ms.sourcegitcommit: fcb48824f9ca24b1f8bd37d647a4d592de1cc925
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/15/2019
ms.locfileid: "69493227"
---
# <a name="link-an-executable-to-a-dll"></a>DLL と実行形式のリンク

実行可能ファイルを DLL とリンクするには、次の 2 つの方法があります。

- *暗黙的なリンク*。オペレーティングシステムが DLL を読み込むときに、それを使用する実行可能ファイルが読み込まれます。 クライアント実行可能ファイルは、関数が静的にリンクされ、実行可能ファイル内に含まれている場合と同様に、DLL のエクスポート関数を呼び出します。 暗黙のリンクは、*静的な読み込み*や*読み込み時の動的リンク*と呼ばれることもあります。

- *明示的なリンク*。オペレーティングシステムが実行時に必要に応じて DLL を読み込みます。 明示的リンクによって DLL を使用する実行可能ファイルは、dll を明示的に読み込んでアンロードし、DLL によってエクスポートされた関数にアクセスするために、関数を呼び出す必要があります。 静的にリンクされたライブラリ内の関数の呼び出しとは異なり、クライアントの実行可能ファイルは、関数ポインターを使用して DLL 内のエクスポートされた関数を呼び出す必要があります。 明示的なリンクは、*動的読み込み*または*実行時の動的リンク*と呼ばれることがあります。

実行可能ファイルは、いずれかのリンク方法を使用して同じ DLL にリンクすることができます。 さらに、これらのメソッドは相互に排他的ではありません。1つの実行可能ファイルは、暗黙的に DLL にリンクすることができ、別の実行可能ファイルに明示的にアタッチできます。

<a name="determining-which-linking-method-to-use"></a>

## <a name="link-an-executable-to-a-dll"></a>DLL と実行形式のリンク

暗黙のリンクと明示的なリンクのどちらを使用するかは、アプリケーションに対して行う必要があるアーキテクチャ上の決定です。 各方法には長所と短所があります。

### <a name="implicit-linking"></a>暗黙的リンク

暗黙のリンクは、アプリケーションのコードがエクスポートされた DLL 関数を呼び出す場合に発生します。 DLL 関数を呼び出す実行形式のソース コードをコンパイルまたはアセンブルすると、オブジェクト コード内に外部関数への参照が生成されます。 この外部参照を解決するには、アプリケーションをインポート ライブラリ (.lib) ファイルとリンクする必要があります。インポート ライブラリは、DLL の作成元が提供します。

インポート ライブラリには、DLL を読み込んで、DLL 内の関数呼び出しを実装するコードが含まれるだけです。 リンカーは、インポート ライブラリ内に外部関数を見つけると、その関数のコードは DLL 内にあるものと認識します。 リンカーは、単に DLL コードの場所を実行可能ファイルに記入することによって、外部参照を解決します。システムはプロセスの起動時にこの情報を利用します。

動的にリンクされた参照を含むプログラムが起動されると、プログラムの実行可能ファイル内の情報に従って、必要な DLL を探します。 DLL が見つからないと、システムは処理を停止し、ダイアログ ボックスを表示して、エラーを報告します。 見つかった場合は、DLL モジュールがプロセスのアドレス空間に割り当てられます。

Dll のいずれかに、のような`DllMain`初期化と終了コードのエントリポイント関数がある場合、オペレーティングシステムは関数を呼び出します。 エントリ ポイント関数に渡されるパラメーターの 1 つは、DLL がプロセスにアタッチされようとしていることを示すコードになります。 エントリ ポイント関数が TRUE を返さない場合、システムは処理を停止し、エラーを報告します。

最後に、システムはプロセスの実行可能コードを変更し、その DLL 関数の開始アドレスをセットします。

プログラム コードの残りの部分と同じように、DLL コードはプロセスの開始時にプロセスのアドレス空間に割り当てられますが、メモリに読み込まれるのはそれが必要とされたときです。 結果として、 `PRELOAD`以前`LOADONCALL`のバージョンの Windows での読み込みを制御するために .def ファイルで使用されるおよびコード属性は、意味がなくなりました。

### <a name="explicit-linking"></a>明示的リンク

暗黙的リンクは最も使いやすい方法なので、多くのアプリケーションは、暗黙的リンクを使います。 ただし、明示的なリンクが必要な場合もあります。 ここでは、明示的リンクを使う一般的な理由について説明します。

- アプリケーションは、実行時まで読み込まれる DLL の名前を認識していません。 たとえば、起動時にアプリケーションによって DLL の名前とエクスポートされた関数が構成ファイルから取得される場合があります。

- プロセスの起動時に DLL が見つからない場合、暗黙的なリンクを使用するプロセスはオペレーティングシステムによって終了されます。 明示的リンクを使用するプロセスは、このような状況では終了せず、エラーからの回復を試みることができます。 たとえば、プロセスがユーザーにエラーを通知して、ユーザーに DLL への別のパスを指定させることができます。

- リンク先の dll に失敗した`DllMain`関数が含まれている場合は、暗黙的なリンクを使用するプロセスも終了します。 この状況では、明示的なリンクを使用するプロセスは終了しません。

- Windows は、アプリケーションの読み込み時にすべての DLL を読み込むため、暗黙的に多くの DLL とリンクするアプリケーションは、起動に時間がかかることがあります。 起動時のパフォーマンスを向上させるために、アプリケーションは、読み込み直後に必要な Dll にのみ暗黙的にリンクし、他の Dll が明示的にリンクする必要があるまで待機します。

- 明示的なリンクを使用すると、インポートライブラリを使用してアプリケーションをリンクする必要がなくなります。 DLL 内の変更によってエクスポート序数が変更された場合、明示的なリンクを使用するアプリケーションは`GetProcAddress` 、序数値ではなく関数名を使用してを呼び出すと再リンクを行う必要はありませんが、暗黙的なリンクを使用するアプリケーションでは、新しいインポートライブラリ。

明示的リンクの欠点は、次の 2 つです。

- DLL に`DllMain`エントリポイント関数がある場合、オペレーティングシステムは、 `LoadLibrary`を呼び出したスレッドのコンテキストで関数を呼び出します。 DLL が既にプロセスにアタッチされている場合、エントリポイント関数は呼び出されません。これ`LoadLibrary`は、に対する以前の呼び出しに`FreeLibrary`よって関数への対応する呼び出しがなかったためです。 (または`DllMain` `LoadLibrary` )が`AfxLoadLibrary`呼び出されたときに既に存在するスレッドが初期化されないため、DLL がプロセスの各スレッドに対して初期化を実行する関数を使用すると、明示的なリンクによって問題が発生する可能性があります。

- DLL が静的エクステントデータをとして`__declspec(thread)`宣言している場合、明示的にリンクされていると、保護エラーが発生する可能性があります。 の呼び出しによって DLL が読み込ま`LoadLibrary`れると、コードがこのデータを参照するたびに保護エラーが発生します。 静的範囲のデータには、グローバル スタティック アイテムとローカル スタティック アイテムの両方が含まれます。そのため、DLL を作成するときは、スレッドローカルストレージを使用しないようにするか、dll を動的に読み込むことによって発生する可能性のある落とし穴について DLL ユーザーに通知する必要があります。 詳細については、「[ダイナミックリンクライブラリでのスレッドローカルストレージの使用」 (Windows SDK)](/windows/win32/Dlls/using-thread-local-storage-in-a-dynamic-link-library)を参照してください。

<a name="linking-implicitly"></a>

## <a name="link-an-executable-to-a-dll"></a>DLL と実行形式のリンク

暗黙的なリンクによって DLL を使用するには、クライアントの実行可能ファイルが DLL のプロバイダーからこれらのファイルを取得する必要があります。

- DLL 内のエクスポートされたデータ、関数、およびC++クラスの宣言を含む1つまたは複数のヘッダーファイル (.h ファイル)。 DLL によってエクスポートされたクラス、関数、およびデータは`__declspec(dllimport)`すべて、ヘッダーファイルでマークされている必要があります。 詳細については、「[dllexport、dllimport](../cpp/dllexport-dllimport.md)」をご覧ください。

- 実行可能ファイルにリンクするインポートライブラリ。 リンカーは、DLL のビルド時にインポートライブラリを作成します。 詳細については、「」を参照してください[。LIB ファイル](reference/dot-lib-files-as-linker-input.md)。

- 実際の DLL ファイル。

暗黙的リンクによって DLL を使用するには、実行可能ファイルに、エクスポートされたデータC++ 、関数、およびクラスの呼び出しを含む各ソースファイルの dll によってエクスポートされたデータ、関数、またはクラスを宣言するヘッダーファイルを含める必要があります。 コーディングの観点からは、エクスポートされた関数の呼び出しは、他の関数呼び出しとまったく同じです。

実行可能ファイルの呼び出しをビルドするには、インポート ライブラリとリンクする必要があります。 外部のメイクファイルまたはビルドシステムを使用する場合は、リンクする他のオブジェクト (.obj) ファイルまたはライブラリを一覧表示するインポートライブラリのファイル名を指定します。

オペレーティング システムは、呼び出し実行形式の読み込み時に、DLL ファイルを配置できる必要があります。 これは、アプリケーションをインストールするときに、アプリケーションが DLL の存在を配置または確認する必要があることを意味します。

<a name="linking-explicitly"></a>

## <a name="how-to-link-explicitly-to-a-dll"></a>DLL に明示的にリンクする方法

明示的リンクによって DLL を使用するには、アプリケーションが実行時に DLL を明示的に読み込むために関数呼び出しを行う必要があります。 DLL と明示的にリンクするには、アプリケーションは、以下の手順を実行します。

- [LoadLibrary](loadlibrary-and-afxloadlibrary.md)、 `LoadLibraryEx`、または同様の関数を呼び出して、DLL を読み込み、モジュールハンドルを取得します。

- [GetProcAddress](getprocaddress.md)を呼び出して、アプリケーションが呼び出す各エクスポート関数への関数ポインターを取得します。 アプリケーションはポインターを使用して DLL 関数を呼び出すため、コンパイラは外部参照を生成しないため、インポートライブラリとリンクする必要はありません。 ただし、呼び出す関数の呼び出し`typedef`シグネチャ`using`を定義するステートメントまたはステートメントが必要です。

- DLL の終了時に[FreeLibrary](freelibrary-and-afxfreelibrary.md)を呼び出します。

たとえば、このサンプル関数`LoadLibrary`は、"mydll.dll" という名前の DLL を読み込み、を呼び出し`GetProcAddress`て "DLLFunc1" という名前の関数へのポインターを取得し、その関数を呼び出し`FreeLibrary`て結果を保存し、を呼び出して dll をアンロードします。

```C
#include "windows.h"

typedef HRESULT (CALLBACK* LPFNDLLFUNC1)(DWORD,UINT*);

HRESULT LoadAndCallSomeFunction(DWORD dwParam1, UINT * puParam2)
{
    HINSTANCE hDLL;               // Handle to DLL
    LPFNDLLFUNC1 lpfnDllFunc1;    // Function pointer
    HRESULT hrReturnVal;

    hDLL = LoadLibrary("MyDLL");
    if (NULL != hDLL)
    {
        lpfnDllFunc1 = (LPFNDLLFUNC1)GetProcAddress(hDLL, "DLLFunc1");
        if (NULL != lpfnDllFunc1)
        {
            // call the function
            hrReturnVal = lpfnDllFunc1(dwParam1, puParam2);
        }
        else
        {
            // report the error
            hrReturnVal = ERROR_DELAY_LOAD_FAILED;
        }
        FreeLibrary(hDLL);
    }
    else
    {
        hrReturnVal = ERROR_DELAY_LOAD_FAILED;
    }
    return hrReturnVal;
}
```

この例の場合とは異なり、ほとんどの場合`LoadLibrary` 、 `FreeLibrary`特定の dll に対してアプリケーションでを1回だけ呼び出す必要があります。特に、dll 内の複数の関数を呼び出したり、dll 関数を繰り返し呼び出したりする場合です。

## <a name="what-do-you-want-to-know-more-about"></a>さらに詳しくは次のトピックをクリックしてください

- [インポート ライブラリとエクスポート ファイル](reference/working-with-import-libraries-and-export-files.md)

- [ダイナミックリンクライブラリの検索順序](/windows/win32/Dlls/dynamic-link-library-search-order)

## <a name="see-also"></a>関連項目

[Visual Studio での C/C++ Dll の作成](dlls-in-visual-cpp.md)
