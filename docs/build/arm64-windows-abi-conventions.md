---
title: ARM64 ABI 規則の概要
ms.date: 03/27/2019
ms.openlocfilehash: 4c0f89f97529d4cd70e1449c90b131d25d30f9ee
ms.sourcegitcommit: ac5c04b347e817eeece6e2c98e60236fc0e307a4
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/29/2019
ms.locfileid: "58639447"
---
# <a name="overview-of-arm64-abi-conventions"></a>ARM64 ABI 規則の概要

コンパイル時に Windows の基本的なアプリケーション バイナリ インターフェイス (ABI) と、ほとんどの 64 ビット モード (ARMv8 またはそれ以降のアーキテクチャ) の ARM プロセッサで実行は、ARM の標準 AArch64 EABI に従います。 この記事には、いくつかの主な前提条件と、EABI で記載するものとからの変更が強調表示されます。 32 ビットの ABI の詳細については、次を参照してください。[概要の ARM ABI 規則](overview-of-arm-abi-conventions.md)します。 標準の ARM EABI の詳細については、次を参照してください。[アプリケーション バイナリ インターフェイス (ABI)、ARM アーキテクチャ用](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.subset.swdev.abi/index.html)(外部リンク)。

## <a name="definitions"></a>定義

64 ビットのサポートの導入に伴い、ARM にはいくつかの用語が定義されています。

- **AArch32** – 従来の 32 ビット命令セットを Thumb モードでの実行を含む、ARM によって定義されるアーキテクチャ (ISA)。
- **AArch64** – 新しい 64 ビット命令は、ARM によって定義されるアーキテクチャ (ISA) を設定します。
- **ARMv7** –「7 生成」の仕様 ARM ハードウェアは、のみ AArch32 のサポートが含まれます。 このバージョンの ARM ハードウェアは、最初のバージョンのサポートされている ARM Windows です。
- **ARMv8** –「1/8/2009 生成」の仕様 ARM ハードウェアは、AArch32 と AArch64 の両方のサポートが含まれています。

Windows では、これらの用語も使用します。

- **ARM** – WoA (ARM 上の Windows) とも呼ば、32 ビット ARM アーキテクチャ (AArch32) を参照します。
- **ARM32** ARM と同じ – 上記; わかりやすくするためには、このドキュメントで使用します。
- **ARM64** – 64 ビット ARM アーキテクチャ (AArch64) を参照します。 WoA64 ようなものはありません。

最後に、データ型を指す場合は、ARM から次の定義が参照されます。

- **Short ベクター** – SIMD、8 バイトまたは 16 バイトの分要素のベクターで直接表現できるデータ型。 これは、サイズ、8 バイトまたは 16 バイト、1、2、4、または 8 バイトの各要素を使用できる場所のいずれかに配置されます。
- **(同種浮動小数点が集計です) HFA** – 2 ~ 4 同一浮動小数点メンバーを持つデータ型をフローティング、または 2 倍になります。
- **HVA の同種 Short ベクター集計**– 同一の Short ベクター メンバーを 2 ~ 4 でのデータ型。

## <a name="base-requirements"></a>基本的な要件

ARM64 の Windows 版は、ARMv8 で実行されていること、またはそれ以降のアーキテクチャを常時を統制します。 両方の浮動小数点と NEON サポートはハードウェアであると見なされます。

ARMv8 仕様により、AArch32 アプリケーションの完全なサポート。 ただし、ARM64 バージョンの Windows で既存の ARM32 アプリケーションに対してサポートされる予定はありません。 (つまりはありません WOW64 のプラン) です。 このサポートは今後、再評価は、現在の作業と想定します。

ARMv8 仕様は、AArch32 と AArch64 の両方の新しい省略可能な暗号と CRC ヘルパー オペコードを説明します。 それらのサポートは、現在省略可、ただし推奨です。 このオペコードに基づいてを利用するには、アプリはその存在のランタイム チェックを最初にする必要があります。

## <a name="endianness"></a>エンディアン

ARM32 として、ARM64 の Windows での Windows のバージョンは、リトル エンディアン モードで実行します。 エンディアンの切り替えは、AArch64 でカーネル モードをサポートせずにできるようを適用しやすくなりますを実現が困難です。

## <a name="alignment"></a>アラインメント

ARM64 で実行されている Windows では、不整合へのアクセスを透過的に処理する CPU ハードウェアを使用できます。 AArch32 から改善、このサポートようになりましたもは (複数の単語へのアクセスを含む) のすべての整数アクセス用と浮動小数点にアクセスできます。

ただし、キャッシュされていない (デバイス) のメモリへのアクセスもする必要があります常に揃えます。 コードの読み取り/キャッシュされていないメモリの不整合のデータを書き込む可能性がありますが場合、配置のすべてのアクセス確認する必要があります。

## <a name="integer-registers"></a>整数レジスタ

AArch64 アーキテクチャには、32 の整数レジスタがサポートされています。

| 登録 | Volatile? | ロール |
| - | - | - |
| x0 | Volatile | 最初のパラメーター/1、登録する結果を登録します。 |
| x1 x7 | Volatile | パラメーター/スクラッチ レジスタ 2 ~ 8 |
| x8 x15 | Volatile | スクラッチ レジスタ |
| x16 x17 | Volatile | 内部プロシージャ呼び出しスクラッチ レジスタ |
| x18 | 非 volatile | プラットフォームの登録: カーネル モードでのポイントを KPCR を現在のプロセッサユーザー モードで TEB をポイントします。 |
| x19 x28 | 非 volatile | スクラッチ レジスタ |
| x29/fp | 非 volatile | フレーム ポインター |
| x30/lr | 非 volatile | リンク レジスタ |

各レジスタは、(x0 x30) を使用して完全な 64 ビット値、または (w0 w30) を使用して 32 ビット値としてアクセスできます。 32 ビット操作ゼロ拡張、その結果最大で 64 ビット。

パラメーターのレジスタの使用方法の詳細については、セクションを渡すパラメーターを参照してください。

AArch32 とは異なり、プログラム カウンター (PC) とスタック ポインター (SP) は、インデックス付きのレジスタをありません。 これらアクセス方法で、制限があります。 X31 がないことに注意してくださいにも登録します。 そのエンコーディングは、特別な目的で使用されます。

フレーム ポインター (x29) がファスト スタック ウォーキング ETW およびその他のサービスで使用される互換性のために必要です。 以前 {x29、30 x} をポイントする必要がありますが、スタック上のペア。

## <a name="floating-pointsimd-registers"></a>浮動小数点または SIMD レジスタ

AArch64 アーキテクチャには、次に示します 32 の浮動小数点または SIMD レジスタもサポートしています。

| 登録 | Volatile? | ロール |
| - | - | - |
| v0 | Volatile | 最初のパラメーター/1、登録する結果を登録します。 |
| v1 v7 | Volatile | パラメーター/ゼロは、2 ~ 8 を登録します。 |
| v8 v15 | 非 volatile | ゼロ (下位 64 ビットは、非揮発性) のみを登録します |
| v16 v31 | Volatile | スクラッチ レジスタ |

各レジスタは、(v0 v31 または q0 q31) 経由で完全な 128 ビット値としてアクセスすることがあります。 アクセス可能 (d0-d31) を使用して 64 ビット値として s0-s31) (32 ビット値として (h0-h31) を使用して、16 ビット値として、または (b0 b31) を使用して、8 ビット値として。 128 ビット未満のアクセスには、完全な 128 ビット レジスタの下位ビットしかアクセスできません。 ままに、残りのビットを指定しない限り変更します。 (AArch64 は AArch32、小規模なレジスタが大容量のレジスタの上に保持されてから異なる) です。

浮動小数点制御レジスタ (FPCR) では、その中のさまざまなビット フィールドで特定の要件があります。

| Bits | 説明 | Volatile? | ロール |
| - | - | - | - |
| 26 | AHP | 非揮発性 | 代替の半制度制御します。 |
| 25 | DN | 非揮発性 | 既定の NaN モード制御します。 |
| 24 | FZ | 非 volatile | フラッシュ対 0 モード コントロール。 |
| 23-22 | RMode | 非 volatile | 丸めモード制御をします。 |
| 15,12-8 | IDE/IXE など | 非揮発性 | 例外は、有効にするビットをトラップ、常に 0 があります。 |

## <a name="system-registers"></a>システムのレジスタ

AArch32 などは、AArch64 仕様は、次の 3 つのシステム管理の対象の「スレッド ID」レジスタを提供します。

| 登録 | ロール |
| - | - |
| TPIDR_EL0 | 予約済み。 |
| TPIDRRO_EL0 | 現在のプロセッサの CPU 数が含まれています。 |
| TPIDR_EL1 | 現在のプロセッサの KPCR 構造体を指します。 |

## <a name="floating-point-exceptions"></a>浮動小数点例外

IEEE 浮動小数点例外のサポートは、AArch64 システムでは省略可能です。 ハードウェアの浮動小数点例外がプロセッサ バリアントでは、Windows カーネルがサイレント モードで例外をキャッチし、暗黙的に FPCR レジスタに無効にします。 このトラップは、プロセッサ バリアント全体で正規化された動作をによりします。 それ以外の場合、例外をサポートしていないプラットフォームで開発されたコードがあります自体のサポートを備えたプラットフォームで実行されているときに予期しない例外を取得します。

## <a name="parameter-passing"></a>パラメーター渡し

非可変個引数関数では、Windows の ABI はパラメーターの引き渡し ARM で指定された規則に従います。 これらの規則は、AArch64 アーキテクチャのプロシージャ呼び出し標準から直接抜粋します。

### <a name="stage-a--initialization"></a>ステージ A: 初期化

この段階では、引数の処理を開始する前に 1 回だけ行われます。

1. [次へ] 汎用登録番号 (NGRN) は、0 に設定されます。

1. [次へ] の SIMD と浮動小数点登録番号 (NSRN) は、0 に設定されます。

1. [次へ] のスタック引数アドレス (NSAA) は、現在のスタック ポインター値 (SP) に設定されます。

### <a name="stage-b--pre-padding-and-extension-of-arguments"></a>ステージ B – 前のパディングと引数の拡張機能

各引数の一覧で、次の一覧から最初の一致する規則が適用されます。 ルールの一致、引数を使用しない場合が変更されていません。

1. 引数の型が、呼び出し元と呼び出し先の両方で、サイズを静的に決定できない複合型の場合は、引数がメモリにコピーされ、引数は、コピーへのポインターによって置き換えられます。 (C および C++ でこのような型はありませんが、他の言語または言語拡張機能に存在する。)

1. 引数の型が、HFA または、HVA としている場合、引数が使用される変更されていません。

1. 引数の型が複合型 16 バイトより大きい場合、呼び出し元が割り当てたメモリへの引数をコピーしと引数は、コピーへのポインターによって置き換えられます。

1. 引数の型に複合型を指定すると、引数のサイズは 8 バイトの倍数に切り上げられます。

### <a name="stage-c--assignment-of-arguments-to-registers-and-stack"></a>ステージ C: レジスタおよびスタックへの引数の割り当て

リスト内の各引数の次の規則は、引数が割り当てられるまでに適用されます。 引数がレジスタに割り当てられると、すべての未使用ビット レジスタに値が指定されません。 引数がスタックのスロットに割り当てられる場合、未使用の埋め込みバイトには値が指定されません。

1. 引数が半分にし、1、2 またはクアッド単精度浮動小数点または Short ベクター型、および、NSRN が 8 未満、引数がレジスタ v の最下位ビットに割り当てられている\[NSRN]。 NSRN は 1 ずつインクリメントされます。 引数が割り当てられましたようになりました。

1. 引数が、HFA または HVA は、十分な未割り当て SIMD と浮動小数点レジスタ (NSRN + メンバー ≤ 8 の数) がある場合は、引数が SIMD と浮動小数点レジスタ、HFA または HVA のメンバーごとの 1 つのレジスタに割り当てられます。 NSRN が使用されるレジスタの数でインクリメントされます。 引数が割り当てられましたようになりました。

1. 引数が、HFA または、HVA の場合、NSRN を 8 に設定しと引数のサイズが 8 バイトの倍数に切り上げられます。

1. HFA、HVA、クアッド精度浮動小数点または短いベクター型に引数があるかどうかは、最大 NSAA が丸められます 8 または引数の型の自然なアラインメントのうち、大きい方。

1. 引数が半分または単精度浮動小数点型の場合、引数のサイズは 8 バイトに設定します。 効果は、引数がある場合、コピーされた、64 ビット レジスタの最下位ビットにし、残りのビットが指定されていない値を格納します。

1. 引数が、HFA の場合、HVA を半分-シングル、2 またはクアッド単精度浮動小数点または Short ベクター型、引数が調整された NSAA でメモリにコピーされます。 NSAA が引数のサイズだけインクリメントされます。 引数が割り当てられましたようになりました。

1. X 内の最下位ビットに引数がコピーされる場合、引数が整数またはポインター型、引数のサイズは 8 バイト未満、NGRN が 8 未満、\[NGRN]。 NGRN は 1 ずつインクリメントされます。 引数が割り当てられましたようになりました。

1. 引数には、アラインメント 16 にされている場合、NGRN は、次の偶数値に切り上げられます。

1. X に引数をコピーする場合は、引数が整数型、引数のサイズが 16 と等しく、NGRN 7 より小さい、\[NGRN] および x\[NGRN + 1] です。 x\[NGRN]、下位アドレス指定された倍のワードの引数のメモリ表現のみが格納されます。 NGRN は 2 でインクリメントされます。 引数が割り当てられましたようになりました。

1. 引数が複合型では、引数のダブル ワードのサイズがマイナス NGRN、8 個しかどうか、引数は x から始まる連続の汎用レジスタにコピー\[NGRN]。 メモリから連続するレジスタの読み込み LDR 命令の適切なシーケンスのダブル ワード境界のアドレスからのレジスタに読み込まれた場合と同様に、引数が渡されます。 この標準では、レジスタの未使用のパーツのコンテンツが指定されていません。 NGRN が使用されるレジスタの数でインクリメントされます。 引数が割り当てられましたようになりました。

1. NGRN は 8 に設定されます。

1. 最大 NSAA が丸められます 8 または引数の型の自然なアラインメントのうち、大きい方。

1. 引数が複合型の場合、引数は、調整された NSAA でメモリにコピーされます。 NSAA が引数のサイズだけインクリメントされます。 引数が割り当てられましたようになりました。

1. 引数のサイズが 8 バイト未満の場合は、引数のサイズを 8 バイトに設定します。 引数が、64 ビット レジスタの最下位ビットにコピーされたし、残りのビットが指定されていない値が入力されたかのようになります。

1. 引数は、調整された NSAA でメモリにコピーされます。 NSAA が引数のサイズだけインクリメントされます。 引数が割り当てられましたようになりました。

### <a name="addendum-variadic-functions"></a>補遺:可変個引数関数

可変個の引数を受け取る関数の処理は異なりますよりも、上記とは、次のように。

1. すべての合成は同じ; 扱われますHFAs または Hva の特別な処理がありません。

1. SIMD と浮動小数点レジスタが使用されません。

実際には、次の規則を割り当てる場所スタックの最初の 64 バイトが x0 x7 に読み込まれ、残りのスタック引数は通常、虚数部のスタック引数 C.12–C.15 と同じです。

## <a name="return-values"></a>戻り値

X0 では、整数値が返されます。

必要に応じて s0、d0/v0 では、浮動小数点値が返されます。

値によって返される型の処理は、特定のプロパティがあるかどうかによって異なります。 これらのプロパティのすべてを保持する型

- いる*集計*c++ 14 標準定義、つまり、あるユーザーが指定したコンス トラクターがない、プライベートまたはプロテクトの非静的データ メンバーのない、基本クラス、および仮想関数、および
- 自明なコピー代入演算子があると
- 自明なデストラクターがあります。

次の戻り値のスタイルを使用します。

- 型が x0 に 8 バイト以下が返されます。
- 型では、x0 と下位の 8 バイトを格納している x0 と x1, 16 バイト以下が返されます。
- 16 バイトより大きい型、呼び出し元のための十分なサイズとアラインメント結果を保持するメモリ ブロックを確保する必要があります。 メモリ ブロックのアドレスは追加の引数として x8 関数に渡されます。 呼び出し先は、サブルーチンの実行中に任意の時点の結果のメモリ ブロックを変更する可能性があります。 呼び出し先は、x8 に格納されている値を保持する必要はありません。

その他のすべての種類は、この規則を使用します。

- 呼び出し元のための十分なサイズとアラインメント結果を保持するメモリ ブロックを予約ものとします。 $ X0 で渡されます場合、メモリ ブロックのアドレスを追加の引数として x0、x1 に関数に渡さものとします。 呼び出し先は、サブルーチンの実行中に任意の時点の結果のメモリ ブロックを変更する可能性があります。 呼び出し先は、x0 でメモリ ブロックのアドレスを返します。

## <a name="stack"></a>Stack

次の ARM によって定め ABI、スタックは、特定でアライン 16 バイトを維持する必要があります。 AArch64 には、SP が 16 バイトでアラインされていないし、SP 相対読み込みまたは格納が実行されるたびに、配置エラーのスタックを生成するハードウェアの機能が含まれています。 Windows は、常に有効になっているこの機能を実行します。

4 k 以上価値のスタックを割り当てる関数は、前の最後のページを順番に接しているを確認してください。 このアクションにより、コードは「飛び越え」ないガード ページ Windows を使用して、スタックを展開します。 通常、手を加えることは、`__chkstk`ヘルパーで、スタックの総割り当て x15 で 16 で割った値を渡すカスタム呼び出し規約。

## <a name="red-zone"></a>赤のゾーン

現在のスタック ポインターのすぐ下の 16 バイトの領域は、分析用に予約し、動的シナリオを修正します。 この領域に 2 つのレジスタを格納する挿入される、慎重に生成されたコードを許可する (sp、# 16) し、一時的にそれらを任意の目的に使用します。 Windows カーネルでは、例外または割り込みが実行された場合、ユーザーとカーネル モードでそれらの 16 バイトが上書きされないことを保証します。

## <a name="kernel-stack"></a>カーネル スタック

Windows での既定のカーネル モード スタックは、6 つのページ (24 k) です。 カーネル モードでスタック バッファーの大きなを持つ関数への特別な注意してください。 タイミングの割り込みは、ほとんどのヘッドルームででしたし、スタック パニック バグチェックを作成します。

## <a name="stack-walking"></a>スタック ウォーク

フレーム ポインターが有効になっている Windows 内のコードがコンパイルされる ([/Oy-](reference/oy-frame-pointer-omission.md)) 高速スタック ウォークを有効にします。 X29 (fp) が {fp、lr} には、チェーン内で次のリンクを指す一般的には、スタック上、戻り値のアドレスは、前のフレームへのポインターを示すペア。 サード パーティのコードは向上プロファイリングおよびトレースのためにフレーム ポインターの場合を有効にすることをお勧めします。

## <a name="exception-unwinding"></a>例外アンワインド

アンワインド コードを使用して、例外処理中にアンワインドが支援します。 アンワインド コードは、実行可能ファイルの .xdata セクションに格納されるバイトのシーケンスです。 呼び出し元のスタック フレームへのバックアップの準備として、関数のプロローグの効果に戻せるように抽象では、プロローグおよびエピローグの操作を記述します。 アンワインド コードの詳細については、次を参照してください。 [ARM64 例外処理](arm64-exception-handling.md)します。

ARM EABI では、アンワインド コードを使用する例外アンワインド モデルも指定します。 ただし、表示された仕様はアンワインドが関数のプロローグまたはエピローグの途中で、PC である場合を処理する必要があります Windows では十分ではありません。

使用して動的関数テーブルを動的に生成されるコードを説明する必要があります`RtlAddFunctionTable`生成されたコードが例外処理に参加できるように、関数を関連付けられているとします。

## <a name="cycle-counter"></a>サイクル カウンター

すべて ARMv8 Cpu サイクル カウンターをサポートするために必要なユーザー モードなど、任意の例外レベルで読めるように Windows を構成する 64 ビット レジスタを登録します。 特別な PMCCNTR_EL0 経由でアクセスできるアセンブリのコードで MSR オペコードを使用して登録します。 または`_ReadStatusReg`C と C++ コードで組み込み。

サイクル カウンターをここでは、実時間ではない、真のサイクル カウンターです。 カウント周波数はプロセッサの頻度によって異なります。 サイクル カウンターの頻度を把握する必要がありますと思われる場合は、サイクル カウンターを使用していることはできません。 使用する必要があります、ウォール クロック時間を測定する代わりに、`QueryPerformanceCounter`します。

## <a name="see-also"></a>関連項目

[Visual C++ の ARM への移行に関する一般的な問題](common-visual-cpp-arm-migration-issues.md)<br/>
[ARM64 例外処理](arm64-exception-handling.md)
