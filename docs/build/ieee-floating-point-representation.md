---
title: IEEE 浮動小数点表現
ms.date: 11/04/2016
helpviewer_keywords:
- float keyword
- real*8 value
- floating-point numbers, IEEE representation
- double data type, floating-point representation
- IEEE floating point representation
- real*10 value
- long double
- real*4 value
ms.assetid: 537833e8-fe05-49fc-8169-55fd0314b195
ms.openlocfilehash: 69686e7e1c8994b799607eebf7e50387ed688272
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/23/2019
ms.locfileid: "62188835"
---
# <a name="ieee-floating-point-representation"></a>IEEE 浮動小数点表現

Microsoft Visual C は、IEEE 数値標準に準拠しています。 IEEE 754 標準では、浮動小数点形式、ハードウェアの実際の数値を表す方法について説明します。 少なくとも 5 つの内部形式は MSVC コンパイラでは、対象となるハードウェアで表現可能な浮動小数点数が、2 つは、コンパイラがのみ使用します。 *単精度*(4 バイト) と*倍精度*(8 バイト) の形式は、Visual C で使用します。 単精度がキーワードで宣言されている**float**します。 倍精度がキーワードで宣言されている**二重**します。 指定して、IEEE 標準*半制度*(2 バイト) と*クオドループル精度*(16 バイト) の形式、および*倍拡張精度*(10 バイト)一部の C および C++ コンパイラの実装として、形式、 **long double**データ型。 MSVC コンパイラで、 **long double**データ型は別個の型として扱われますが、ストレージ型にマップされます**二重**します。 ただし、組み込みとアセンブリ言語サポート、倍拡張精度 (10 バイト) の形式を含む、他の形式を使用して計算のハードウェアによってサポートされている場合。

次のように値が格納されます。

|[値]|として格納されています。|
|-----------|---------------|
|単精度 (single-precision)|符号ビットの 8 ビットの指数部、23 ビット仮数部|
|倍精度|符号ビット、11 ビット指数 52 ビット仮数部|
|倍拡張精度|符号ビット、指数 15 ビット、64 ビットの仮数部|

単精度と倍精度の形式でと呼ばれる、小数部が想定した先頭の 1 は、*仮数*(と呼ばれます、*仮数*)、つまりに格納されていません。メモリのためのみ 23 または 52 ビットが格納されている場合でも、実際には 24 または 53 ビット、有効桁数。 倍拡張精度形式には、このビットが実際には格納されます。

指数は、その最大値の半分でバイアスされます。 これは、実際の指数を取得する格納された指数からバイアス値を減算することを意味します。 格納された指数がバイアス値より小さい場合は、負の指数実際になります。

指数は、次のように、バイアスされます。

|指数|バイアスされます。|
|--------------|---------------|
|8 ビット (単精度)|127|
|11 ビット (倍精度)|1023|
|15 ビット (double 型の拡張-精度)|16383|

これらの指数; 10 の累乗でないです。これらは、2 の累乗です。 つまり、8 ビットで格納される指数は、-127、127 文字で、0 ~ 254 として格納する範囲です。 値 2<sup>127</sup>は 10 にほぼ等しい<sup>38</sup>、単精度の実際の上限であります。

仮数部がバイナリ形式の一部として格納されている 1.XXX...。 この割合は、1 以上 2 未満の値を持ちます。 実際の数値がで常に格納されていることに注意してください。*正規化された形式*; は、仮数部が左シフトされ、仮数の上位ビットは常に 1 です。 このビットが 1 では常にであるためにと見なされます (格納しません)、単精度と倍精度の形式でします。 バイナリ (ない 10 進数) 点は、先頭の 1 の右側にあると見なされます。

この形式では、次に、さまざまなサイズのとおりです。

|形式|1 バイト|2 バイト|3 バイト|バイト 4|...|バイト n|
|------------|------------|------------|------------|------------|---------|------------|
|単精度 (single-precision)| `SXXXXXXX`|`XMMMMMMM`|`MMMMMMMM`|`MMMMMMMM`|||
|倍精度|`SXXXXXXX`|`XXXXMMMM`|`MMMMMMMM`|`MMMMMMMM`|...|`MMMMMMMM`|
|倍拡張精度|`SXXXXXXX`|`XXXXXXXX`|`1MMMMMMM`|`MMMMMMMM`|...|`MMMMMMMM`|

`S` 符号ビット、`X`のバイアスをかけた指数ビット、および`M`の仮数部のビットです。 値のビットが単精度と倍精度の形式の対象読者はなく倍拡張精度形式の 3 バイトでは、「1」として存在であることに注意してください。

バイナリのポイントを正しくシフトするには、最初指数しバイナリのポイントを右に移動したりしたまま適切なビット数。

## <a name="special-values"></a>特殊な値

浮動小数点形式には、特別に扱われるいくつかの値が含まれます。

### <a name="zero"></a>0

これにより、表現で単精度または倍精度値の正規化されたフォーム、0 は標準化できません。 すべてがゼロの特別なビット パターンは、0 を表します。 可能です - を表す記号で 0 として 0 ビット セットがあります - 0 と 0 が常に等しいと比較します。

### <a name="infinities"></a>無限大

+、∞ と −∞ の値はのすべての指数とすべてがゼロの有効桁で表されます。 正と負の無限大は符号ビットを使用して表現できます。

### <a name="subnormals"></a>Subnormals

最小の正規化された数よりも小さい絶対値の数値を表すことになります。 これらの数値と呼ばれる*ある*または*denormal*番号。 指数部はすべてゼロ仮数部が 0 でない場合は、仮数部の先頭の暗黙の型のビットは 0 でないと見なされます。 仮数部の先頭にゼロの数が上がると、ある数値の有効桁数がダウンします。

### <a name="nan---not-a-number"></a>NaN の数ではなく

0 などの実数ではない値を表現することは 0、IEEE 浮動小数点形式でします。 この種類の値と呼ばれる、 *NaN*します。 NaN は、すべて 1 と 0 以外の有効桁の指数によって表されます。 Nan の 2 種類があります*quiet* Nan、または QNaNs、および*シグナル*Nan、または SNaNs します。 静的 Nan には、仮数部の先頭の 1 つがあり、式を一般に反映されます。 これらは、除算の無限大、または、無限値を 0 に乗算の結果など、不確定な値を表します。 信号に Nan の有効桁で、先行ゼロがあります。 これらは、浮動小数点演算ハードウェア例外を通知する、無効な操作のために使用されます。

## <a name="examples"></a>使用例

以下は、単精度の形式の例をいくつかのことです。

- 値 2 では、符号ビットが 0 の場合と格納された指数は、128 またはバイナリ、1000 0000 は 127 に 1 を足した。 ストアドのバイナリの仮数部が (1) です。000 0000 0000 0000 0000 0000 で、暗黙的なトップ レベル 1 およびバイナリのあるポイントの実際の有効桁であるようにします。

   |[値]|計算式|バイナリ表現|16 進数|
   |-|-|-|-|
   |2|1 * 2<sup>1</sup>|0100 0000 0000 0000 0000 0000 0000 0000|0x40000000|

- 値-2 です。 符号ビットが設定される点を除いて、-2 の場合も同じです。 これは、すべての IEEE 形式の浮動小数点数の負の値の場合は true。

   |[値]|計算式|バイナリ表現|16 進数|
   |-|-|-|-|
   |-2|-1 * 2<sup>1</sup>|1100 0000 0000 0000 0000 0000 0000 0000|0xC0000000|

- 4 の値。 同じ仮数は、指数部が (バイアスをかけた値は 129、またはバイナリで 100 0000 1 1 つずつ増加します。

   |[値]|計算式|バイナリ表現|16 進数|
   |-|-|-|-|
   |4|1 * 2<sup>2</sup>|0100 0000 1000 0000 0000 0000 0000 0000|0x40800000|

- 値 6。 同じ指数は、有効桁が半分に大きい-it の (1)。100 0000 ...0000 0000、ので、これは、バイナリの分数は、1 1/2 桁の小数部の値は 1/2、1/4、1/8 などであるためです。

   |[値]|計算式|バイナリ表現|16 進数|
   |-|-|-|-|
   |6|1.5 * 2<sup>2</sup>|0100 0000 1100 0000 0000 0000 0000 0000|0x40C00000|

- 値 1。 2 には、バイアスをかけたの指数部の有効桁を同じ 1 つです 2 未満で 127 文字で、またはバイナリで 011 1111 1。

   |[値]|計算式|バイナリ表現|16 進数|
   |-|-|-|-|
   |1|1 * 2<sup>0</sup>|0011 1111 1000 0000 0000 0000 0000 0000|0x3F800000|

- 0.75 値。 バイアスをかけたの指数部は 126、011 1111、0 のバイナリと仮数部が (1)。100 0000 ...0000 0000 が 1 1/2。

   |[値]|計算式|バイナリ表現|16 進数|
   |-|-|-|-|
   |0.75|1.5 * 2<sup>-1</sup>|0011 1111 0100 0000 0000 0000 0000 0000|0x3F400000|

- 2.5 の値。 いる点を除き、2 つとまったく同じ 1/4 を表すビットが設定の有効桁でします。

   |[値]|計算式|バイナリ表現|16 進数|
   |-|-|-|-|
   |2.5|1.25 * 2<sup>1</sup>|0100 0000 0010 0000 0000 0000 0000 0000|0x40200000|

- 1/10 では、バイナリ内の繰り返しの分数です。 仮数は単に 1.6 よりとバイアスをかけた指数という 1.6 が 16 で除算すること (これはバイナリで、10 進数で 123 011 1101 1 です)。 実際の指数は 123 127 = - 乗算に使用率が 2 であることを意味する 4 は、<sup>-4</sup> = 1/16。 ストアドの仮数部が最後まで切り上げ注 — 表現の数をできる限り正確に表すしようとします。 (理由その 1/10 および 1/100 はバイナリで完全に表現できる理由の 1/3 は 10 進数で完全に表現できることに似ています)。

   |[値]|計算式|バイナリ表現|16 進数|
   |-|-|-|-|
   |0.1|1.6 * 2<sup>-4</sup>|0011 1101 1100 1100 1100 1100 1100 1101|0x3DCCCCCD|

- 0 は、特殊なケースでは、最小表現可能な正の値に対して、すべてゼロである式を使用します。

   |[値]|計算式|バイナリ表現|16 進数|
   |-|-|-|-|
   |0|1 * 2<sup>-128</sup>|0000 0000 0000 0000 0000 0000 0000 0000|0x00000000|

## <a name="see-also"></a>関連項目

[浮動小数点数の精度の低下](why-floating-point-numbers-may-lose-precision.md)