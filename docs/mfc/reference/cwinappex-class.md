---
title: CWinAppEx クラス
ms.date: 11/04/2016
f1_keywords:
- CWinAppEx
- AFXWINAPPEX/CWinAppEx
- AFXWINAPPEX/CWinAppEx::CWinAppEx
- AFXWINAPPEX/CWinAppEx::CleanState
- AFXWINAPPEX/CWinAppEx::EnableLoadWindowPlacement
- AFXWINAPPEX/CWinAppEx::EnableTearOffMenus
- AFXWINAPPEX/CWinAppEx::EnableUserTools
- AFXWINAPPEX/CWinAppEx::ExitInstance
- AFXWINAPPEX/CWinAppEx::GetBinary
- AFXWINAPPEX/CWinAppEx::GetContextMenuManager
- AFXWINAPPEX/CWinAppEx::GetDataVersion
- AFXWINAPPEX/CWinAppEx::GetDataVersionMajor
- AFXWINAPPEX/CWinAppEx::GetDataVersionMinor
- AFXWINAPPEX/CWinAppEx::GetInt
- AFXWINAPPEX/CWinAppEx::GetKeyboardManager
- AFXWINAPPEX/CWinAppEx::GetMouseManager
- AFXWINAPPEX/CWinAppEx::GetObject
- AFXWINAPPEX/CWinAppEx::GetRegSectionPath
- AFXWINAPPEX/CWinAppEx::GetRegistryBase
- AFXWINAPPEX/CWinAppEx::GetSectionBinary
- AFXWINAPPEX/CWinAppEx::GetSectionInt
- AFXWINAPPEX/CWinAppEx::GetSectionObject
- AFXWINAPPEX/CWinAppEx::GetSectionString
- AFXWINAPPEX/CWinAppEx::GetShellManager
- AFXWINAPPEX/CWinAppEx::GetString
- AFXWINAPPEX/CWinAppEx::GetTooltipManager
- AFXWINAPPEX/CWinAppEx::GetUserToolsManager
- AFXWINAPPEX/CWinAppEx::InitContextMenuManager
- AFXWINAPPEX/CWinAppEx::InitKeyboardManager
- AFXWINAPPEX/CWinAppEx::InitMouseManager
- AFXWINAPPEX/CWinAppEx::InitShellManager
- AFXWINAPPEX/CWinAppEx::InitTooltipManager
- AFXWINAPPEX/CWinAppEx::IsResourceSmartUpdate
- AFXWINAPPEX/CWinAppEx::IsStateExists
- AFXWINAPPEX/CWinAppEx::LoadState
- AFXWINAPPEX/CWinAppEx::OnAppContextHelp
- AFXWINAPPEX/CWinAppEx::OnViewDoubleClick
- AFXWINAPPEX/CWinAppEx::OnWorkspaceIdle
- AFXWINAPPEX/CWinAppEx::SaveState
- AFXWINAPPEX/CWinAppEx::SetRegistryBase
- AFXWINAPPEX/CWinAppEx::ShowPopupMenu
- AFXWINAPPEX/CWinAppEx::WriteBinary
- AFXWINAPPEX/CWinAppEx::WriteInt
- AFXWINAPPEX/CWinAppEx::WriteObject
- AFXWINAPPEX/CWinAppEx::WriteSectionBinary
- AFXWINAPPEX/CWinAppEx::WriteSectionInt
- AFXWINAPPEX/CWinAppEx::WriteSectionObject
- AFXWINAPPEX/CWinAppEx::WriteSectionString
- AFXWINAPPEX/CWinAppEx::WriteString
- AFXWINAPPEX/CWinAppEx::LoadCustomState
- AFXWINAPPEX/CWinAppEx::LoadWindowPlacement
- AFXWINAPPEX/CWinAppEx::OnClosingMainFrame
- AFXWINAPPEX/CWinAppEx::PreLoadState
- AFXWINAPPEX/CWinAppEx::PreSaveState
- AFXWINAPPEX/CWinAppEx::ReloadWindowPlacement
- AFXWINAPPEX/CWinAppEx::SaveCustomState
- AFXWINAPPEX/CWinAppEx::StoreWindowPlacement
- AFXWINAPPEX/CWinAppEx::m_bForceImageReset
helpviewer_keywords:
- CWinAppEx [MFC], CWinAppEx
- CWinAppEx [MFC], CleanState
- CWinAppEx [MFC], EnableLoadWindowPlacement
- CWinAppEx [MFC], EnableTearOffMenus
- CWinAppEx [MFC], EnableUserTools
- CWinAppEx [MFC], ExitInstance
- CWinAppEx [MFC], GetBinary
- CWinAppEx [MFC], GetContextMenuManager
- CWinAppEx [MFC], GetDataVersion
- CWinAppEx [MFC], GetDataVersionMajor
- CWinAppEx [MFC], GetDataVersionMinor
- CWinAppEx [MFC], GetInt
- CWinAppEx [MFC], GetKeyboardManager
- CWinAppEx [MFC], GetMouseManager
- CWinAppEx [MFC], GetObject
- CWinAppEx [MFC], GetRegSectionPath
- CWinAppEx [MFC], GetRegistryBase
- CWinAppEx [MFC], GetSectionBinary
- CWinAppEx [MFC], GetSectionInt
- CWinAppEx [MFC], GetSectionObject
- CWinAppEx [MFC], GetSectionString
- CWinAppEx [MFC], GetShellManager
- CWinAppEx [MFC], GetString
- CWinAppEx [MFC], GetTooltipManager
- CWinAppEx [MFC], GetUserToolsManager
- CWinAppEx [MFC], InitContextMenuManager
- CWinAppEx [MFC], InitKeyboardManager
- CWinAppEx [MFC], InitMouseManager
- CWinAppEx [MFC], InitShellManager
- CWinAppEx [MFC], InitTooltipManager
- CWinAppEx [MFC], IsResourceSmartUpdate
- CWinAppEx [MFC], IsStateExists
- CWinAppEx [MFC], LoadState
- CWinAppEx [MFC], OnAppContextHelp
- CWinAppEx [MFC], OnViewDoubleClick
- CWinAppEx [MFC], OnWorkspaceIdle
- CWinAppEx [MFC], SaveState
- CWinAppEx [MFC], SetRegistryBase
- CWinAppEx [MFC], ShowPopupMenu
- CWinAppEx [MFC], WriteBinary
- CWinAppEx [MFC], WriteInt
- CWinAppEx [MFC], WriteObject
- CWinAppEx [MFC], WriteSectionBinary
- CWinAppEx [MFC], WriteSectionInt
- CWinAppEx [MFC], WriteSectionObject
- CWinAppEx [MFC], WriteSectionString
- CWinAppEx [MFC], WriteString
- CWinAppEx [MFC], LoadCustomState
- CWinAppEx [MFC], LoadWindowPlacement
- CWinAppEx [MFC], OnClosingMainFrame
- CWinAppEx [MFC], PreLoadState
- CWinAppEx [MFC], PreSaveState
- CWinAppEx [MFC], ReloadWindowPlacement
- CWinAppEx [MFC], SaveCustomState
- CWinAppEx [MFC], StoreWindowPlacement
- CWinAppEx [MFC], m_bForceImageReset
ms.assetid: a3d3e053-3e22-463f-9444-c73abb1bb9d7
ms.openlocfilehash: c222567703d0e57480c00f6f2bf9e78f16979150
ms.sourcegitcommit: c3093251193944840e3d0a068ecc30e6449624ba
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/04/2019
ms.locfileid: "57288832"
---
# <a name="cwinappex-class"></a>CWinAppEx クラス

`CWinAppEx` アプリケーション状態の処理、レジストリに状態を保存、レジストリから状態を読み込みます、アプリケーション マネージャーの初期化および同じアプリケーション マネージャーへのリンクを提供します。

   詳細についてにあるソース コードを参照してください、 **VC\\atlmfc\\src\\mfc** Visual Studio のインストールのフォルダー。
## <a name="syntax"></a>構文

```
class CWinAppEx : public CWinApp
```

## <a name="members"></a>メンバー

### <a name="public-constructors"></a>パブリック コンストラクター

|名前|説明|
|----------|-----------------|
|[CWinAppEx::CWinAppEx](#cwinappex)|`CWinAppEx` オブジェクトを構築します。|

### <a name="public-methods"></a>パブリック メソッド

|名前|説明|
|----------|-----------------|
|[CWinAppEx::CleanState](#cleanstate)|Windows レジストリからアプリケーションに関する情報を削除します。|
|[CWinAppEx::EnableLoadWindowPlacement](#enableloadwindowplacement)|アプリケーションは、レジストリからメイン フレーム ウィンドウの場所と初期サイズを読み込むかどうかを指定します。|
|[CWinAppEx::EnableTearOffMenus](#enabletearoffmenus)|アプリケーションのメニュー ティアオフできます。|
|[CWinAppEx::EnableUserTools](#enableusertools)|アプリケーションのカスタム メニュー コマンドを作成するユーザーを有効にします。|
|[CWinAppEx::ExitInstance](#exitinstance)|内から、フレームワークによって呼び出されます、`Run`メンバー関数は、アプリケーションのこのインスタンスを終了します。 (上書き[し](../../mfc/reference/cwinapp-class.md#exitinstance))。|
|[CWinAppEx::GetBinary](#getbinary)|指定されたレジストリ値に関連付けられているバイナリ データを読み取ります。|
|[CWinAppEx::GetContextMenuManager](#getcontextmenumanager)|グローバルのポインターを返します[CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md)オブジェクト。|
|[CWinAppEx::GetDataVersion](#getdataversion)||
|[CWinAppEx::GetDataVersionMajor](#getdataversionmajor)|Windows レジストリに保存されているアプリケーションのメジャー バージョンを返します。|
|[CWinAppEx::GetDataVersionMinor](#getdataversionminor)|Windows レジストリに保存されているアプリケーションのマイナー バージョンを返します。|
|[CWinAppEx::GetInt](#getint)|レジストリから指定された値に関連付けられている数値のデータを読み取ります。|
|[CWinAppEx::GetKeyboardManager](#getkeyboardmanager)|グローバルのポインターを返します[CKeyboardManager](../../mfc/reference/ckeyboardmanager-class.md)オブジェクト。|
|[CWinAppEx::GetMouseManager](#getmousemanager)|グローバルのポインターを返します[CMouseManager](../../mfc/reference/cmousemanager-class.md)オブジェクト。|
|[CWinAppEx::GetObject](#getobject)|読み取り`CObject`-レジストリから指定された値に関連付けられているデータを派生します。|
|[CWinAppEx::GetRegSectionPath](#getregsectionpath)|レジストリ キーのパスを表す文字列を返します。 このパスは、アプリケーションのパスで指定された相対パスを連結します。|
|[CWinAppEx::GetRegistryBase](#getregistrybase)|アプリケーションのレジストリ パスを返します。|
|[CWinAppEx::GetSectionBinary](#getsectionbinary)|指定したキーとレジストリからの値に関連付けられているバイナリ データを読み取ります。|
|[CWinAppEx::GetSectionInt](#getsectionint)|数値データを指定したキーと値に関連付けられているレジストリから読み取ります。|
|[CWinAppEx::GetSectionObject](#getsectionobject)|読み取り`CObject`指定したキーとレジストリからの値に関連付けられているデータ。|
|[CWinAppEx::GetSectionString](#getsectionstring)|指定したキーとレジストリからの値に関連付けられている文字列データを読み取ります。|
|[CWinAppEx::GetShellManager](#getshellmanager)|グローバルのポインターを返します[CShellManager](../../mfc/reference/cshellmanager-class.md)オブジェクト。|
|[CWinAppEx::GetString](#getstring)|レジストリから指定された値に関連付けられている文字列データを読み取ります。|
|[CWinAppEx::GetTooltipManager](#gettooltipmanager)|グローバルのポインターを返します[CTooltipManager](../../mfc/reference/ctooltipmanager-class.md)オブジェクト。|
|[CWinAppEx::GetUserToolsManager](#getusertoolsmanager)|グローバルのポインターを返します[CUserToolsManager](../../mfc/reference/cusertoolsmanager-class.md)オブジェクト。|
|[CWinAppEx::InitContextMenuManager](#initcontextmenumanager)|`CContextMenuManager` オブジェクトを初期化します。|
|[CWinAppEx::InitKeyboardManager](#initkeyboardmanager)|`CKeyboardManager` オブジェクトを初期化します。|
|[CWinAppEx::InitMouseManager](#initmousemanager)|`CMouseManager` オブジェクトを初期化します。|
|[CWinAppEx::InitShellManager](#initshellmanager)|初期化します、`CShellManager`クラス|
|[:Inittooltipmanager](#inittooltipmanager)|初期化します、`CTooltipManager`クラス。|
|[CWinAppEx::IsResourceSmartUpdate](#isresourcesmartupdate)||
|[CWinAppEx::IsStateExists](#isstateexists)|指定したキーがレジストリかどうかを示します。|
|[CWinAppEx::LoadState](#loadstate)|レジストリから、アプリケーションの状態を読み込みます。|
|[CWinAppEx::OnAppContextHelp](#onappcontexthelp)|ユーザーのコンテキスト ヘルプを要求するときに、フレームワークによって呼び出されます、**カスタマイズ** ダイアログ ボックス。|
|[CWinAppEx::OnViewDoubleClick](#onviewdoubleclick)|ユーザーがアプリケーションの任意の場所をダブルクリックしたときに、ユーザー定義のコマンドを呼び出します。|
|[CWinAppEx::OnWorkspaceIdle](#onworkspaceidle)||
|[CWinAppEx::SaveState](#savestate)|アプリケーション フレームワークの状態を Windows レジストリに書き込みます。|
|[CWinAppEx::SetRegistryBase](#setregistrybase)|既定のレジストリ キーのパスを設定します。 このキーは、レジストリの後続のすべての呼び出しのルートとして使用されます。|
|[CWinAppEx::ShowPopupMenu](#showpopupmenu)|ポップアップ メニューが表示されます。|
|[CWinAppEx::WriteBinary](#writebinary)|指定されたレジストリ値には、バイナリ データを書き込みます。|
|[CWinAppEx::WriteInt](#writeint)|指定されたレジストリ値を数値データを書き込みます。|
|[CWinAppEx::WriteObject](#writeobject)|派生したデータを書き込む、 [CObject クラス](../../mfc/reference/cobject-class.md)指定されたレジストリ値にします。|
|[CWinAppEx::WriteSectionBinary](#writesectionbinary)|指定されたレジストリ キーの値には、バイナリ データを書き込みます。|
|[CWinAppEx::WriteSectionInt](#writesectionint)|指定されたレジストリ キーの値に数値データを書き込みます。|
|[CWinAppEx::WriteSectionObject](#writesectionobject)|派生したデータを書き込み、`CObject`指定されたレジストリ キーの値にクラス。|
|[CWinAppEx::WriteSectionString](#writesectionstring)|指定されたレジストリ キーの値には、文字列データを書き込みます。|
|[CWinAppEx::WriteString](#writestring)|指定されたレジストリ値を文字列データを書き込みます。|

### <a name="protected-methods"></a>プロテクト メソッド

|名前|説明|
|----------|-----------------|
|[CWinAppEx::LoadCustomState](#loadcustomstate)|アプリケーションの状態が読み込まれたときに、フレームワークによって呼び出されます。|
|[CWinAppEx::LoadWindowPlacement](#loadwindowplacement)|レジストリから、アプリケーションの場所とサイズを読み込むときに、フレームワークによって呼び出されます。 読み込まれたデータには、アプリケーションが最後に閉じられた時にメイン フレームの位置とサイズが含まれます。|
|[CWinAppEx::OnClosingMainFrame](#onclosingmainframe)|メイン フレーム ウィンドウが WM_CLOSE を処理するときに、フレームワークによって呼び出されます。|
|[CWinAppEx::PreLoadState](#preloadstate)|直前に、フレームワークによって呼び出されます、アプリケーションの状態が読み込まれます。|
|[CWinAppEx::PreSaveState](#presavestate)|アプリケーションの状態を保存する直前に、フレームワークによって呼び出されます。|
|[CWinAppEx::ReloadWindowPlacement](#reloadwindowplacement)|指定されたレジストリからウィンドウの位置とサイズを再読み込み|
|[CWinAppEx::SaveCustomState](#savecustomstate)|アプリケーションの状態をレジストリに保存した後に、フレームワークによって呼び出されます。|
|[CWinAppEx::StoreWindowPlacement](#storewindowplacement)|メイン フレームの位置とサイズをレジストリに書き込むために、フレームワークによって呼び出されます。|

### <a name="data-members"></a>データ メンバー

|名前|説明|
|----------|-----------------|
|[CWinAppEx::m_bForceImageReset](#m_bforceimagereset)|ツールバーを含むフレーム ウィンドウが読み込まれるときに、フレームワークがすべてのツール バー イメージをリセットするかどうかを指定します。|

## <a name="remarks"></a>Remarks

MFC フレームワークによって提供される機能の多くによって異なります、`CWinAppEx`クラス。 組み込むことができます、`CWinAppEx`を 2 つの方法のいずれかでアプリケーションにクラス。

- 構築、`CWinAppEx`メイン スレッドでのクラス。

- アプリケーションのメイン クラスを派生`CWinAppEx`します。

組み込む`CWinAppEx`をアプリケーションには、アプリケーション マネージャーのいずれかを初期化できます。 アプリケーション マネージャーを使用する前に、適切な初期化メソッドを呼び出すことで初期化する必要があります。 特定のマネージャーへのポインターを取得するには、関連付けられている get メソッドを呼び出します。 `CWinAppEx`クラスは、次のアプリケーション マネージャーを管理します。[CMouseManager クラス](../../mfc/reference/cmousemanager-class.md)、 [CContextMenuManager クラス](../../mfc/reference/ccontextmenumanager-class.md)、 [CKeyboardManager クラス](../../mfc/reference/ckeyboardmanager-class.md)、 [CUserToolsManager クラス](../../mfc/reference/cusertoolsmanager-class.md)、および[CMenuTearOffManager クラス](../../mfc/reference/cmenutearoffmanager-class.md)します。

## <a name="inheritance-hierarchy"></a>継承階層

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CWinThread](../../mfc/reference/cwinthread-class.md)

[CWinApp](../../mfc/reference/cwinapp-class.md)

[CWinAppEx](../../mfc/reference/cwinappex-class.md)

## <a name="requirements"></a>必要条件

**ヘッダー:** afxwinappex.h

##  <a name="cleanstate"></a>  CWinAppEx::CleanState

Windows レジストリからアプリケーションに関するすべての情報を削除します。

```
virtual BOOL CleanState(LPCTSTR lpszSectionName=NULL);
```

### <a name="parameters"></a>パラメーター

*lpszSectionName*<br/>
[in]レジストリ キーのパスを含む文字列。

### <a name="return-value"></a>戻り値

メソッドが成功した場合、0 以外の場合それ以外の場合 0 を返します。

### <a name="remarks"></a>Remarks

このメソッドは、レジストリの特定のセクションからアプリケーション データをクリアします。 パラメーターを使用してクリアするセクションを指定する*lpszSectionName*します。 場合*lpszSectionName*が null の場合、このメソッドに格納されている既定のレジストリ パスを使用して、`CWinAppEx`オブジェクト。 既定のレジストリ パスを取得する[CWinAppEx::GetRegistryBase](#getregistrybase)します。

##  <a name="cwinappex"></a>  CWinAppEx::CWinAppEx

`CWinAppEx` オブジェクトを構築します。

```
CWinAppEx(BOOL bResourceSmartUpdate = FALSE);
```

### <a name="parameters"></a>パラメーター

*bResourceSmartUpdate*<br/>
[in]ワークスペースのオブジェクトが検出され、リソースの更新を処理するかどうかを指定するブール型パラメーター。

### <a name="remarks"></a>Remarks

`CWinAppEx`クラスの初期化メソッドが、機能の保存と読み込みをレジストリにアプリケーションの情報を提供します、およびアプリケーションのグローバル設定を制御します。 グローバル管理者を使用することもできます、 [CKeyboardManager クラス](../../mfc/reference/ckeyboardmanager-class.md)と[CUserToolsManager クラス](../../mfc/reference/cusertoolsmanager-class.md)します。 各アプリケーション インスタンス 1 つだけでは、`CWinAppEx`クラス。

##  <a name="enableloadwindowplacement"></a>  CWinAppEx::EnableLoadWindowPlacement

アプリケーションは、レジストリからメイン フレーム ウィンドウの場所と初期サイズを読み込むかどうかを指定します。

```
void EnableLoadWindowPlacement(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>パラメーター

*bEnable*<br/>
[in]アプリケーションがレジストリから、メイン フレーム ウィンドウの場所と初期サイズをロードするかどうかを指定します。

### <a name="remarks"></a>Remarks

既定では、メイン フレームの位置とサイズが、他のアプリケーション設定とレジストリから読み込まれます。 中に発生したこの[CWinAppEx::LoadState](#loadstate)します。 レジストリからウィンドウの初期配置をロードしない場合に、このメソッドを呼び出す*bEnable*を FALSE に設定します。

##  <a name="enabletearoffmenus"></a>  CWinAppEx::EnableTearOffMenus

作成し、初期化、 [CMenuTearOffManager](../../mfc/reference/cmenutearoffmanager-class.md)オブジェクト。

```
BOOL EnableTearOffMenus(
    LPCTSTR lpszRegEntry,
    const UINT uiCmdFirst,
    const UINT uiCmdLast);
```

### <a name="parameters"></a>パラメーター

*lpszRegEntry*<br/>
[in]レジストリ キーのパスを含む文字列。 アプリケーションでは、このレジストリ キーを使用して、ティアオフ メニューの情報を格納します。

*uiCmdFirst*<br/>
[in]最初にティアオフ メニュー id。

*uiCmdLast*<br/>
[in]最後にティアオフ メニュー id。

### <a name="return-value"></a>戻り値

TRUE の場合、`CMenuTearOffManager`が作成され、初期化に成功しました。FALSE エラーが発生した場合や、`CMenuTearOffManager`既に存在します。

### <a name="remarks"></a>Remarks

アプリケーションでは、ティアオフ メニューを有効にするのにには、この関数を使用します。 この関数を呼び出す必要があります`InitInstance`します。

##  <a name="enableusertools"></a>  CWinAppEx::EnableUserTools

アプリケーションにキーストロークを減らすカスタム メニュー コマンドを作成するユーザーを有効にします。 このメソッドを作成、 [CUserToolsManager](../../mfc/reference/cusertoolsmanager-class.md)オブジェクト。

```
BOOL EnableUserTools(
    const UINT uiCmdToolsDummy,
    const UINT uiCmdFirst,
    const UINT uiCmdLast,
    CRuntimeClass* pToolRTC = RUNTIME_CLASS(CUserTool),
    UINT uArgMenuID = 0,
    UINT uInitDirMenuID = 0);
```

### <a name="parameters"></a>パラメーター

*uiCmdToolsDummy*<br/>
[in]ユーザーの [ツール] メニューのコマンド ID プレース ホルダーとして、フレームワークを使用して符号なし整数。

*uiCmdFirst*<br/>
[in]最初のユーザー ツールのコマンドのコマンド ID。

*uiCmdLast*<br/>
[in]最後のユーザー ツールのコマンドのコマンド ID。

*pToolRTC*<br/>
[in]クラスを`CUserToolsManager`オブジェクトを使用して新しいユーザー ツールを作成します。

*uArgMenuID*<br/>
[in]引数のメニューの id。

*uInitDirMenuID*<br/>
[in]初期のツール ディレクトリのメニューの ID。

### <a name="return-value"></a>戻り値

メソッドを作成し、初期化する場合は TRUE、`CUserToolsManager`オブジェクト。FALSE、メソッドが失敗した場合、または場合、`CUserToolsManager`オブジェクトは既に存在します。

### <a name="remarks"></a>Remarks

ユーザー定義のツールを有効にすると、フレームワークは自動的に動的メニューをカスタマイズするときに拡張できるをサポートします。 フレームワークは、外部のコマンドを使用して新しい各項目を関連付けます。 フレームワークは、ユーザーから適切な項目を選択すると、これらのコマンドを呼び出す、**ツール**メニュー。

ユーザーは、新しい項目を追加するたびに、フレームワークは、新しいオブジェクトを作成します。 新しいオブジェクトのクラス型によって定義されます*pToolRTC*します。 *PToolRTC*クラス型から派生する必要があります、 [CUserTool クラス](../../mfc/reference/cusertool-class.md)します。

ユーザー ツールとアプリケーションに組み込む方法の詳細については、次を参照してください。[ユーザー定義のツール](../../mfc/user-defined-tools.md)します。

##  <a name="exitinstance"></a>  CWinAppEx::ExitInstance

```
virtual int ExitInstance();
```

### <a name="return-value"></a>戻り値

### <a name="remarks"></a>Remarks

##  <a name="getbinary"></a>  CWinAppEx::GetBinary

指定されたレジストリ キーからバイナリ データを読み取ります。

```
BOOL GetBinary(
    LPCTSTR lpszEntry,
    LPBYTE* ppData,
    UINT* pBytes);
```

### <a name="parameters"></a>パラメーター

*lpszEntry*<br/>
[in]レジストリ キーの名前を含む文字列。

*ppData*<br/>
[out]メソッドがバイナリ データを格納するバッファーへのポインター。

*ペタバイト*<br/>
[out]メソッドを使用して、読み取ったバイト数を記述する符号なし整数へのポインター。

### <a name="return-value"></a>戻り値

成功した場合は TRUE。FALSE それ以外の場合。

### <a name="remarks"></a>Remarks

このメソッドは、レジストリに書き込まれたバイナリ データを読み込みます。 レジストリにデータを記述するメソッドを使用して、 [CWinAppEx::WriteBinary](#writebinary)と[CWinAppEx::WriteSectionBinary](#writesectionbinary)します。

*LpszEntry*パラメーターは、アプリケーションの既定のレジストリ キーの下にあるレジストリ エントリの名前です。 取得または設定の既定のレジストリ キー、メソッドを使用して、 [CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase](#setregistrybase)それぞれします。

##  <a name="getcontextmenumanager"></a>  CWinAppEx::GetContextMenuManager

グローバルのポインターを返します[CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md)オブジェクト。

```
CContextMenuManager* GetContextMenuManager();
```

### <a name="return-value"></a>戻り値

グローバルへのポインター`CContextMenuManager`オブジェクト。

### <a name="remarks"></a>Remarks

この関数を呼び出す CContextMenuManager オブジェクトが初期化されていない場合[CWinAppEx::InitContextMenuManager](#initcontextmenumanager)ポインターを返す前にします。

##  <a name="getdataversion"></a>  CWinAppEx::GetDataVersion

```
int GetDataVersion() const;
```

### <a name="return-value"></a>戻り値

### <a name="remarks"></a>Remarks

##  <a name="getdataversionmajor"></a>  CWinAppEx::GetDataVersionMajor

呼び出すときに、Windows レジストリに保存されているアプリケーションのメジャー バージョンを返します[CWinAppEx::SaveState](#savestate)します。

```
int GetDataVersionMajor() const;
```

### <a name="return-value"></a>戻り値

メジャー バージョン番号を含む整数値。

##  <a name="getdataversionminor"></a>  CWinAppEx::GetDataVersionMinor

呼び出すときに、Windows レジストリに保存されているアプリケーションのマイナー バージョンを返します[CWinAppEx::SaveState](#savestate)します。

```
int GetDataVersionMinor() const;
```

### <a name="return-value"></a>戻り値

マイナー バージョン番号を含む整数値。

##  <a name="getint"></a>  CWinAppEx::GetInt

指定されたレジストリ キーから整数型のデータを読み取ります。

```
int GetInt(
    LPCTSTR lpszEntry,
    int nDefault = 0);
```

### <a name="parameters"></a>パラメーター

*lpszEntry*<br/>
[in]レジストリ エントリの名前を含む文字列。

*nDefault*<br/>
[in]指定されたレジストリ エントリが存在しないかどうかはメソッドによって返される既定値。

### <a name="return-value"></a>戻り値

メソッドが成功した場合は、レジストリ データそれ以外の場合*見つからなかった*します。

### <a name="remarks"></a>Remarks

このメソッドは、レジストリから整数型のデータを読み取ります。 によって示されるレジストリ キーに関連付けられた整数データがないかどうかは*lpszEntry*、このメソッドが戻る*見つからなかった*します。 レジストリにデータを記述するメソッドを使用して、 [CWinAppEx::WriteSectionInt](#writesectionint)と[CWinAppEx::WriteInt](#writeint)します。

*LpszEntry*パラメーターは、アプリケーションの既定のレジストリ キーの下にあるレジストリ エントリの名前です。 取得または設定の既定のレジストリ キー、メソッドを使用して、 [CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase](#setregistrybase)それぞれします。

##  <a name="getkeyboardmanager"></a>  CWinAppEx::GetKeyboardManager

グローバルのポインターを返します[CKeyboardManager](../../mfc/reference/ckeyboardmanager-class.md)オブジェクト。

```
CKeyboardManager* GetKeyboardManager();
```

### <a name="return-value"></a>戻り値

グローバルへのポインター`CKeyboardManager`オブジェクト。

### <a name="remarks"></a>Remarks

この関数を呼び出すキーボード マネージャーが初期化されていない場合[CWinAppEx::InitKeyboardManager](#initkeyboardmanager)ポインターを返す前にします。

##  <a name="getmousemanager"></a>  CWinAppEx::GetMouseManager

グローバルのポインターを返します[CMouseManager](../../mfc/reference/cmousemanager-class.md)オブジェクト。

```
CMouseManager* GetMouseManager();
```

### <a name="return-value"></a>戻り値

グローバルへのポインター`CMouseManager`オブジェクト。

### <a name="remarks"></a>Remarks

この関数を呼び出す場合は、マウスのマネージャーが初期化されていません、および[CWinAppEx::InitMouseManager](#initmousemanager)ポインターを返す前にします。

##  <a name="getobject"></a>  CWinAppEx::GetObject

読み取り[CObject](../../mfc/reference/cobject-class.md)レジストリからデータを派生されたものです。

```
BOOL GetObject(
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>パラメーター

*lpszEntry*<br/>
[in]レジストリ エントリの相対パスを含む文字列。

*obj*<br/>
[out]参照、`CObject`します。 メソッドは、レジストリ データを格納するのに、この参照を使用します。

### <a name="return-value"></a>戻り値

メソッドが成功した場合、0 以外の場合それ以外の場合 0 を返します。

### <a name="remarks"></a>Remarks

このメソッドから派生したレジストリからデータを読み取る`CObject`します。 書き込む`CObject`いずれかを使用するデータ、レジストリを[CWinAppEx::WriteObject](#writeobject)または[CWinAppEx::WriteSectionObject](#writesectionobject)します。

*LpszEntry*パラメーターは、アプリケーションの既定のレジストリ キーの下にあるレジストリ エントリの名前です。 取得または設定の既定のレジストリ キー、メソッドを使用して、 [CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase](#setregistrybase)それぞれします。

##  <a name="getregistrybase"></a>  CWinAppEx::GetRegistryBase

アプリケーションの既定のレジストリ パスを取得します。

```
LPCTSTR GetRegistryBase();
```

### <a name="return-value"></a>戻り値

既定のレジストリの場所のパスを含む文字列。

### <a name="remarks"></a>Remarks

すべてのメソッド、 [CWinAppEx クラス](../../mfc/reference/cwinappex-class.md)既定の場所にレジストリの開始にアクセスします。 既定のレジストリの場所のパスを取得するのにには、このメソッドを使用します。 使用[CWinAppEx::SetRegistryBase](#setregistrybase)レジストリの既定の場所を変更します。

##  <a name="getregsectionpath"></a>  CWinAppEx::GetRegSectionPath

作成してレジストリ キーの絶対パスを返します。

```
CString GetRegSectionPath(LPCTSTR szSectionAdd = _T(""));
```

### <a name="parameters"></a>パラメーター

*szSectionAdd*<br/>
[in]レジストリ キーの相対パスを含む文字列。

### <a name="return-value"></a>戻り値

A`CString`レジストリ キーの絶対パスを格納しています。

### <a name="remarks"></a>Remarks

このメソッドに相対パスを追加して、レジストリ キーの絶対パスを定義します*szSectionAdd*アプリケーションの既定のレジストリの場所にします。 既定のレジストリ キーを取得するメソッドを使用して[CWinAppEx::GetRegistryBase](#getregistrybase)します。

##  <a name="getsectionbinary"></a>  CWinAppEx::GetSectionBinary

レジストリからバイナリ データを読み取ります。

```
BOOL GetSectionBinary(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPBYTE* ppData,
    UINT* pBytes);
```

### <a name="parameters"></a>パラメーター

*lpszSubSection*<br/>
[in]レジストリ キーの相対パスを含む文字列。

*lpszEntry*<br/>
[in]読み取る値を含む文字列。

*ppData*<br/>
[out]メソッドがデータを格納するバッファーへのポインター。

*ペタバイト*<br/>
[out]符号なし整数へのポインター。 サイズを書き込む*ppData*このパラメーターにします。

### <a name="return-value"></a>戻り値

成功した場合は TRUE、それ以外の場合は FALSE。

### <a name="remarks"></a>Remarks

このメソッドは、メソッドを使用してレジストリに書き込まれたバイナリ データを読み取ります[CWinAppEx::WriteBinary](#writebinary)と[CWinAppEx::WriteSectionBinary](#writesectionbinary)します。

*LpszSubSection*パラメーターは、レジストリ エントリの絶対パスではありません。 アプリケーションの既定のレジストリ キーの末尾に追加する相対パスです。 取得または設定の既定のレジストリ キー、メソッドを使用して、 [CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase](#setregistrybase)それぞれします。

##  <a name="getsectionint"></a>  CWinAppEx::GetSectionInt

レジストリから整数型のデータを読み取ります。

```
int GetSectionInt(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    int nDefault = 0);
```

### <a name="parameters"></a>パラメーター

*lpszSubSection*<br/>
[in]レジストリ キーの相対パスを含む文字列。

*lpszEntry*<br/>
[in]読み取る値を含む文字列。

*nDefault*<br/>
[in]指定した値が存在しないかどうかに返す既定値。

### <a name="return-value"></a>戻り値

指定したレジストリの値で格納されている整数データ*見つからなかった*データが存在しない場合。

### <a name="remarks"></a>Remarks

メソッドを使用して[CWinAppEx::WriteInt](#writeint)と[CWinAppEx::WriteSectionInt](#writesectionint)整数データ、レジストリに書き込めません。

*LpszSubSection*パラメーターは、レジストリ エントリの絶対パスではありません。 アプリケーションの既定のレジストリ キーの末尾に追加する相対パスです。 取得または設定の既定のレジストリ キー、メソッドを使用して、 [CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase](#setregistrybase)それぞれします。

##  <a name="getsectionobject"></a>  CWinAppEx::GetSectionObject

読み取り[CObject](../../mfc/reference/cobject-class.md)レジストリからレジストリ データ。

```
BOOL GetSectionObject(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>パラメーター

*lpszSubSection*<br/>
[in]レジストリ キーの相対パスを含む文字列。

*lpszEntry*<br/>
[in]読み取る値を含む文字列。

*obj*<br/>
[out]参照、`CObject`します。 メソッドがこれを使用して`CObject`レジストリ データを格納します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

このメソッドは、レジストリからデータを読み取ります。 データの読み取りが`CObject`データ、またはデータから派生したクラスの`CObject`します。 書き込む`CObject`いずれかを使用するデータ、レジストリを[CWinAppEx::WriteObject](#writeobject)または[CWinAppEx::WriteSectionObject](#writesectionobject)します。

*LpszSubSection*パラメーターは、レジストリ エントリの絶対パスではありません。 アプリケーションの既定のレジストリ キーの末尾に追加する相対パスです。 取得または設定の既定のレジストリ キー、メソッドを使用して、 [CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase](#setregistrybase)それぞれします。

##  <a name="getsectionstring"></a>  CWinAppEx::GetSectionString

文字列のレジストリからデータを読み取ります。

```
CString GetSectionString(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszDefault = _T(""));
```

### <a name="parameters"></a>パラメーター

*lpszSubSection*<br/>
[in]レジストリ キーの相対パスを含む文字列。

*lpszEntry*<br/>
[in]読み取る値を含む文字列。

*から*<br/>
[in]指定した値が存在しないかどうかに返す既定値。

### <a name="return-value"></a>戻り値

データが存在する場合は、指定されたレジストリ値に格納されている文字列データそれ以外の場合*から*します。

### <a name="remarks"></a>Remarks

このメソッドは、レジストリに書き込まれる文字列データを読み込みます。 使用[CWinAppEx::WriteString](#writestring)と[CWinAppEx::WriteSectionString](#writesectionstring)には文字列データをレジストリに書き込めません。

*LpszSubSection*パラメーターは、レジストリ エントリの絶対パスではありません。 アプリケーションの既定のレジストリ キーの末尾に追加する相対パスです。 取得または設定の既定のレジストリ キー、メソッドを使用して、 [CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase](#setregistrybase)それぞれします。

##  <a name="getshellmanager"></a>  CWinAppEx::GetShellManager

グローバルのポインターを返します[CShellManager](../../mfc/reference/cshellmanager-class.md)オブジェクト。

```
CShellManager* GetShellManager();
```

### <a name="return-value"></a>戻り値

グローバルへのポインター`CShellManager`オブジェクト。

### <a name="remarks"></a>Remarks

場合、`CShellManager`オブジェクトが初期化されていません、この関数を呼び出す[CWinAppEx::InitShellManager](#initshellmanager)ポインターを返す前にします。

##  <a name="getstring"></a>  CWinAppEx::GetString

文字列の指定したレジストリ キーからのデータを読み取ります。

```
CString GetString(
    LPCTSTR lpszEntry,
    LPCTSTR lpzDefault= _T(""));
```

### <a name="parameters"></a>パラメーター

*lpszEntry*<br/>
[in]レジストリ キーの名前を含む文字列

*lpzDefault*<br/>
[in]指定されたレジストリ エントリが存在しないかどうかはメソッドによって返される既定値。

### <a name="return-value"></a>戻り値

成功した場合は、レジストリに格納された文字列データ*から*それ以外の場合。

### <a name="remarks"></a>Remarks

このメソッドは、レジストリに書き込まれる文字列データを読み込みます。 レジストリにデータを記述するメソッドを使用して、 [CWinAppEx::WriteString](#writestring)または[CWinAppEx::WriteSectionString](#writesectionstring)します。

*LpszEntry*パラメーターは、アプリケーションの既定のレジストリ キーの下にあるレジストリ エントリの名前です。 取得または設定の既定のレジストリ キー、メソッドを使用して、 [CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase](#setregistrybase)それぞれします。

##  <a name="gettooltipmanager"></a>  CWinAppEx::GetTooltipManager

グローバルのポインターを返します[CTooltipManager](../../mfc/reference/ctooltipmanager-class.md)オブジェクト。

```
CTooltipManager* GetTooltipManager();
```

### <a name="return-value"></a>戻り値

グローバルへのポインター`CTooltipManager`オブジェクト。

### <a name="remarks"></a>Remarks

場合、`CTooltipManager`オブジェクトが初期化されていません、この関数を呼び出す[:inittooltipmanager](#inittooltipmanager)ポインターを返す前にします。

##  <a name="getusertoolsmanager"></a>  CWinAppEx::GetUserToolsManager

グローバルのポインターを返します[CUserToolsManager](../../mfc/reference/cusertoolsmanager-class.md)オブジェクト。

```
CUserToolsManager* GetUserToolsManager();
```

### <a name="return-value"></a>戻り値

グローバルへのポインター`CUserToolsManager`オブジェクト。アプリケーションのユーザー管理のツールの場合は NULL が有効になっていません。

### <a name="remarks"></a>Remarks

ポインターを取得する前に、`CUserToolsManager`オブジェクトを呼び出すことにより、マネージャーを初期化する必要があります[CWinAppEx::EnableUserTools](#enableusertools)します。

##  <a name="initcontextmenumanager"></a>  CWinAppEx::InitContextMenuManager

初期化します、 [CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md)オブジェクト。

```
BOOL InitContextMenuManager();
```

### <a name="return-value"></a>戻り値

メソッドは、CContextMenuManager オブジェクトを作成する場合、0 以外の場合0 の場合、`CContextMenuManager`オブジェクトは既に存在します。

### <a name="remarks"></a>Remarks

呼び出す場合[CWinAppEx::GetContextMenuManager](#getcontextmenumanager)、そのメソッドの既定の実装を呼び出す`InitContextMenuManager`します。

既にアプリケーションがコンテキスト メニューのマネージャーを呼び出す場合`InitContextMenuManager`、アプリケーションがある、 [ASSERT](diagnostic-services.md#assert)エラー。 そのため、呼び出す必要はありません`InitContextMenuManager`を作成する場合、`CContextMenuManager`オブジェクトに直接します。 カスタムを使用していない場合`CContextMenuManager`、使用する必要があります`GetContextMenuManager`を作成する、`CContextMenuManager`オブジェクト。

##  <a name="initkeyboardmanager"></a>  CWinAppEx::InitKeyboardManager

初期化します、 [CKeyboardManager](../../mfc/reference/ckeyboardmanager-class.md)オブジェクト。

```
BOOL InitKeyboardManager();
```

### <a name="return-value"></a>戻り値

メソッドを作成する場合、0 以外の場合、`CKeyboardManager`オブジェクト。 0 の場合、`CKeyboardManager`オブジェクトは既に存在します。

### <a name="remarks"></a>Remarks

呼び出す場合[CWinAppEx::GetKeyboardManager](#getkeyboardmanager)、そのメソッドの既定の実装を呼び出す`InitKeyboardManager`します。

アプリケーションで既にがキーボードのマネージャーを呼び出す場合`InitKeyboardManager`、アプリケーションがある、 [ASSERT](diagnostic-services.md#assert)失敗します。 そのため、呼び出す必要はありません`InitKeyboardManager`を作成する場合、`CKeyboardManager`オブジェクトに直接します。 カスタムを使用していない場合`CKeyboardManager`、使用する必要があります`GetKeyboardManager`を作成する、`CKeyboardManager`オブジェクト。

##  <a name="initmousemanager"></a>  CWinAppEx::InitMouseManager

初期化します、 [CMouseManager](../../mfc/reference/cmousemanager-class.md)オブジェクト。

```
BOOL InitMouseManager();
```

### <a name="return-value"></a>戻り値

メソッドを作成する場合、0 以外の場合、`CMouseManager`オブジェクト。 0 の場合、`CMouseManager`オブジェクトは既に存在します。

### <a name="remarks"></a>Remarks

呼び出す場合[CWinAppEx::GetMouseManager](#getmousemanager)、そのメソッドの既定の実装を呼び出す`InitMouseManager`します。

アプリケーションで既にがマウスのマネージャーを呼び出す場合`InitMouseManager`、アプリケーションがある、 [ASSERT](diagnostic-services.md#assert)失敗します。 呼び出さないでくださいしたがって`InitMouseManager`を作成する場合、`CMouseManager`オブジェクトに直接します。 カスタムを使用していない場合`CMouseManager`、使用する必要があります`GetMouseManager`を作成する、`CMouseManager`オブジェクト。

##  <a name="initshellmanager"></a>  CWinAppEx::InitShellManager

初期化します、 [CShellManager](../../mfc/reference/cshellmanager-class.md)オブジェクト。

```
BOOL InitShellManager();
```

### <a name="return-value"></a>戻り値

メソッドを作成する場合、0 以外の場合、`CShellManager`オブジェクト。 0 の場合、`CShellManager`オブジェクトは既に存在します。

### <a name="remarks"></a>Remarks

呼び出す場合[CWinAppEx::GetShellManager](#getshellmanager)、そのメソッドの既定の実装を呼び出す`InitShellManager`します。

既にアプリケーションにシェル マネージャーを呼び出す場合`InitShellManager`、アプリケーションが、 [ASSERT](diagnostic-services.md#assert)失敗します。 そのため、呼び出さないでください`InitShellManager`を作成する場合、`CShellManager`オブジェクトに直接します。 カスタムを使用していない場合`CShellManager`を使用して、`GetShellManager`を作成する、`CShellManager`オブジェクト。

##  <a name="inittooltipmanager"></a>  :Inittooltipmanager

初期化します、 [CTooltipManager](../../mfc/reference/ctooltipmanager-class.md)オブジェクト。

```
BOOL InitTooltipManager();
```

### <a name="return-value"></a>戻り値

メソッドを作成する場合、0 以外の場合、`CTooltipManager`オブジェクト。 0 の場合、`CTooltipManager`オブジェクトは既に存在します。

### <a name="remarks"></a>Remarks

呼び出す場合[CWinAppEx::GetTooltipManager](#gettooltipmanager)、そのメソッドの既定の実装を呼び出す`InitTooltipManager`します。

アプリケーションで既にがツールヒント マネージャーを呼び出す場合`InitTooltipManager`、アプリケーションがある、 [ASSERT](diagnostic-services.md#assert)失敗します。 そのため、呼び出す必要はありません`InitTooltipManager`を作成する場合、`CTooltipManager`オブジェクトに直接します。 カスタムを使用していない場合`CTooltipManager`、使用する必要があります`GetTooltipManager`を作成する、`CTooltipManager`オブジェクト。

##  <a name="isresourcesmartupdate"></a>  CWinAppEx::IsResourceSmartUpdate

```
BOOL IsResourceSmartUpdate() const;
```

### <a name="return-value"></a>戻り値

### <a name="remarks"></a>Remarks

##  <a name="isstateexists"></a>  CWinAppEx::IsStateExists

指定したキーがレジストリかどうかを示します。

```
BOOL IsStateExists(LPCTSTR lpszSectionName);
```

### <a name="parameters"></a>パラメーター

*lpszSectionName*<br/>
[in]レジストリ キーのパスを含む文字列。

### <a name="return-value"></a>戻り値

キーがレジストリにある場合、0 以外の場合それ以外の場合 0 を返します。

##  <a name="loadcustomstate"></a>  CWinAppEx::LoadCustomState

フレームワークは、レジストリから、アプリケーションの状態を読み込んだ後に、このメソッドを呼び出します。

```
virtual void LoadCustomState();
```

### <a name="remarks"></a>Remarks

アプリケーションがレジストリから状態を読み込んだ後に処理を実行する場合は、このメソッドをオーバーライドします。 既定では、このメソッドは何もしません。

レジストリからカスタム状態情報を読み込むためには、情報する必要がありますまず保存を使用して[CWinAppEx::SaveCustomState](#savecustomstate)します。

##  <a name="loadstate"></a>  CWinAppEx::LoadState

Windows レジストリから、アプリケーションの状態を読み取ります。

```
BOOL LoadState(
    CMDIFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL LoadState(
    CFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL LoadState(
    COleIPFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

virtual BOOL LoadState(
    LPCTSTR lpszSectionName = NULL,
    CFrameImpl* pFrameImpl = NULL);
```

### <a name="parameters"></a>パラメーター

*pFrame*<br/>
[in]フレーム ウィンドウ オブジェクトへのポインター。 メソッドでは、このフレーム ウィンドウに、レジストリ内の状態情報が適用されます。

*lpszSectionName*<br/>
[in]レジストリ キーの相対パスを含む文字列。

*pFrameImpl*<br/>
[in]ポインターを`CFrameImpl`オブジェクト。 メソッドでは、このフレーム ウィンドウに、レジストリ内の状態情報が適用されます。

### <a name="return-value"></a>戻り値

成功した場合、0 以外の場合それ以外の場合は 0 です。

### <a name="remarks"></a>Remarks

このメソッドは、アプリケーションとフレーム ウィンドウの状態情報の状態を読み込みます。 フレーム ウィンドウに読み込まれた情報は、指定したフレーム ウィンドウに適用されます。 フレーム ウィンドウを指定しない場合は、アプリケーションの状態情報のみが読み込まれます。 アプリケーション情報には状態が含まれています、 [CMouseManager クラス](../../mfc/reference/cmousemanager-class.md)、 [CContextMenuManager クラス](../../mfc/reference/ccontextmenumanager-class.md)、 [CKeyboardManager クラス](../../mfc/reference/ckeyboardmanager-class.md)、および[CUserToolsManager クラス](../../mfc/reference/cusertoolsmanager-class.md)します。

既定の実装`CFrameImpl::OnLoadFrame`呼び出し`LoadState`します。

*LpszSectionName*パラメーターは、レジストリ エントリの絶対パスではありません。 アプリケーションの既定のレジストリ キーの末尾に追加する相対パスです。 取得または設定の既定のレジストリ キー、メソッドを使用して、 [CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase](#setregistrybase)それぞれします。

##  <a name="loadwindowplacement"></a>  CWinAppEx::LoadWindowPlacement

メイン フレーム ウィンドウの位置とサイズをレジストリから読み込むときに、フレームワークによって呼び出されます。

```
virtual BOOL LoadWindowPlacement(
    CRect& rectNormalPosition,
    int& nFlags,
    int& nShowCmd);
```

### <a name="parameters"></a>パラメーター

*rectNormalPosition*<br/>
[out]復元された位置にあるときに、メイン フレーム ウィンドウの座標を格納する四角形。

*nFlags*<br/>
[out]最小化されたウィンドウと最小化されたウィンドウと、復元されたウィンドウの間のオペレーティング システムのスイッチの位置を制御するフラグ。

*nShowCmd*<br/>
[out]ウィンドウの表示状態を指定する整数。 使用可能な値の詳細については、次を参照してください。[また](../../mfc/reference/cwnd-class.md#showwindow)します。

### <a name="return-value"></a>戻り値

成功した場合、0 以外の場合それ以外の場合は 0 です。

### <a name="remarks"></a>Remarks

既定では、MFC 自動的に読み込まれます直前の位置と、メイン フレーム ウィンドウの状態、アプリケーションの起動時にします。 この情報をレジストリに格納する方法の詳細については、次を参照してください。 [CWinAppEx::StoreWindowPlacement](#storewindowplacement)します。

メイン フレーム ウィンドウに関する追加情報をロードする場合は、このメソッドをオーバーライドします。

##  <a name="m_bforceimagereset"></a>  CWinAppEx::m_bForceImageReset

ツールバーを含むフレーム ウィンドウを再読み込み時に、フレームワークがすべてのツール バー イメージをリセットするかどうかを指定します。

```
BOOL m_bForceImageReset;
```

### <a name="remarks"></a>Remarks

`m_bForceImageReset`データ メンバーは保護されている変数。

##  <a name="onappcontexthelp"></a>  CWinAppEx::OnAppContextHelp

ユーザーのコンテキスト ヘルプを要求するために、フレームワークはこのメソッドを呼び出して、**カスタマイズ** ダイアログ ボックス。

```
virtual void OnAppContextHelp(
    CWnd* pWndControl,
    const DWORD dwHelpIDArray[]);
```

### <a name="parameters"></a>パラメーター

*pWndControl*<br/>
[in]ユーザーがコンテキスト ヘルプを呼び出したウィンドウ オブジェクトへのポインター。

*dwHelpIDArray[]*<br/>
[in]予約済みの値。

### <a name="remarks"></a>Remarks

このメソッドは、将来使用するため予約されています。 既定の実装は何し、フレームワークがないというは現在。

##  <a name="onclosingmainframe"></a>  CWinAppEx::OnClosingMainFrame

フレームワークは、フレーム ウィンドウが WM_CLOSE を処理するときに、このメソッドを呼び出します。

```
virtual void OnClosingMainFrame(CFrameImpl* pFrameImpl);
```

### <a name="parameters"></a>パラメーター

*pFrameImpl*<br/>
[in]ポインターを`CFrameImpl`オブジェクト。

### <a name="remarks"></a>Remarks

このメソッドの既定の実装の状態を保存する*pFrameImpl*します。

##  <a name="onviewdoubleclick"></a>  CWinAppEx::OnViewDoubleClick

ユーザーがそのビュー内の任意の場所をダブルクリックすると、ビューに関連付けられているユーザー定義のコマンドを呼び出します。

```
virtual BOOL OnViewDoubleClick(
    CWnd* pWnd,
    int iViewId);
```

### <a name="parameters"></a>パラメーター

*我が物*<br/>
[in]派生したオブジェクトへのポインター、 [CView クラス](../../mfc/reference/cview-class.md)します。

*iViewId*<br/>
[in]ビューの id。

### <a name="return-value"></a>戻り値

TRUE の場合、フレームワークは、コマンドを検索します。それ以外の場合は FALSE です。

### <a name="remarks"></a>Remarks

カスタムのマウスの動作をサポートするためにしたメッセージを処理すると、この関数を呼び出す必要があります。 このメソッドでは、によって提供されるビューの ID に関連付けられているコマンドを実行します。 *iViewId*します。 カスタムのマウスの動作の詳細については、次を参照してください。[キーボードとマウスのカスタマイズ](../../mfc/keyboard-and-mouse-customization.md)します。

##  <a name="onworkspaceidle"></a>  CWinAppEx::OnWorkspaceIdle

```
virtual BOOL OnWorkspaceIdle(CWnd*);
```

### <a name="parameters"></a>パラメーター

[in]*CWnd&#38;*<br/>

### <a name="return-value"></a>戻り値

### <a name="remarks"></a>Remarks

##  <a name="preloadstate"></a>  CWinAppEx::PreLoadState

フレームワークは、レジストリから、アプリケーションの状態を読み込む前にすぐに、このメソッドを呼び出します。

```
virtual void PreLoadState();
```

### <a name="remarks"></a>Remarks

フレームワークは、アプリケーションの状態を読み込みますにすぐに処理を実行する場合は、このメソッドをオーバーライドします。

##  <a name="presavestate"></a>  CWinAppEx::PreSaveState

フレームワークは、アプリケーションの状態を保存する直前に、このメソッドを呼び出します。

```
virtual void PreSaveState();
```

### <a name="remarks"></a>Remarks

フレームワークは、アプリケーションの状態を保存する直前に処理を実行する場合は、このメソッドをオーバーライドします。

##  <a name="reloadwindowplacement"></a>  CWinAppEx::ReloadWindowPlacement

レジストリからウィンドウの位置とサイズを再読み込みします。

```
virtual BOOL ReloadWindowPlacement(CFrameWnd* pFrame);
```

### <a name="parameters"></a>パラメーター

*pFrame*<br/>
[in]フレーム ウィンドウへのポインター。

### <a name="return-value"></a>戻り値

メソッドが成功した場合、0 以外の場合失敗した場合または負荷に読み込むデータがない場合は 0。

### <a name="remarks"></a>Remarks

関数を使用して[CWinAppEx::StoreWindowPlacement](#storewindowplacement)には、ウィンドウの位置とサイズ、レジストリに書き込めません。

##  <a name="savecustomstate"></a>  CWinAppEx::SaveCustomState

フレームワークは、レジストリにアプリケーションの状態を保存した後に、このメソッドを呼び出します。

```
virtual void SaveCustomState();
```

### <a name="remarks"></a>Remarks

アプリケーションがレジストリに状態を保存した後に処理を実行する場合は、このメソッドをオーバーライドします。 既定では、このメソッドは何もしません。

##  <a name="savestate"></a>  CWinAppEx::SaveState

アプリケーションの状態を Windows レジストリに書き込みます。

```
virtual BOOL SaveState(
    LPCTSTR lpszSectionName = NULL,
    CFrameImpl* pFrameImpl = NULL);

BOOL SaveState(
    CMDIFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL SaveState(
    CFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL SaveState(
    COleIPFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);
```

### <a name="parameters"></a>パラメーター

*lpszSectionName*<br/>
[in]レジストリ キーの相対パスを含む文字列。

*pFrameImpl*<br/>
[in]ポインターを`CFrameImpl`オブジェクト。 このフレームは、Windows レジストリに保存されます。

*pFrame*<br/>
[in]フレーム ウィンドウ オブジェクトへのポインター。 このフレームは、Windows レジストリに保存されます。

### <a name="return-value"></a>戻り値

成功した場合は TRUE。FALSE それ以外の場合。

### <a name="remarks"></a>Remarks

このメソッドは、アプリケーションと、指定されたフレーム ウィンドウの状態情報の状態を保存します。 フレーム ウィンドウを指定しない場合、メソッドはのみ、アプリケーションの状態を保存します。 アプリケーション情報には状態が含まれています、 [CMouseManager クラス](../../mfc/reference/cmousemanager-class.md)、 [CContextMenuManager クラス](../../mfc/reference/ccontextmenumanager-class.md)、 [CKeyboardManager クラス](../../mfc/reference/ckeyboardmanager-class.md)、および[CUserToolsManager クラス](../../mfc/reference/cusertoolsmanager-class.md)します。

*LpszSectionName*パラメーターは、レジストリ エントリの絶対パスではありません。 アプリケーションの既定のレジストリ キーの末尾に追加する相対パスです。 取得または設定の既定のレジストリ キー、メソッドを使用して、 [CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase](#setregistrybase)それぞれします。

##  <a name="setregistrybase"></a>  CWinAppEx::SetRegistryBase

アプリケーションの既定のレジストリ パスを設定します。

```
LPCTSTR SetRegistryBase(LPCTSTR lpszSectionName = NULL);
```

### <a name="parameters"></a>パラメーター

*lpszSectionName*<br/>
[in]レジストリ キーのパスを含む文字列。

### <a name="return-value"></a>戻り値

既定のレジストリの場所のパスを含む文字列。

### <a name="remarks"></a>Remarks

すべてのメソッド、 [CWinAppEx クラス](../../mfc/reference/cwinappex-class.md)既定の場所にレジストリの開始にアクセスします。 このメソッドを使用すると、その既定のレジストリの場所を変更できます。 使用[CWinAppEx::GetRegistryBase](#getregistrybase)既定レジストリの場所を取得します。

##  <a name="showpopupmenu"></a>  CWinAppEx::ShowPopupMenu

ポップアップ メニューが表示されます。

```
virtual BOOL ShowPopupMenu(
    UINT uiMenuResId,
    const CPoint& point,
    CWnd* pWnd);
```

### <a name="parameters"></a>パラメーター

*uiMenuResId*<br/>
[in]メニュー リソースの id。

*ポイント*<br/>
[in]A [CPoint](../../atl-mfc-shared/reference/cpoint-class.md)画面座標で、メニューの位置を指定します。

*我が物*<br/>
[in]ポップアップ メニューを所有しているウィンドウへのポインター。

### <a name="return-value"></a>戻り値

ポップアップ メニューが正常に表示されている場合、0 以外の場合それ以外の場合は 0 です。

### <a name="remarks"></a>Remarks

このメソッドに関連付けられているメニューを表示*uiMenuResId*します。

ポップアップ メニューをサポートするが必要、 [CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md)オブジェクト。 初期化していない場合、`CContextMenuManager`オブジェクト、`ShowPopupMenu`は失敗します。

##  <a name="storewindowplacement"></a>  CWinAppEx::StoreWindowPlacement

メイン フレーム ウィンドウの位置とサイズをレジストリに書き込むために、フレームワークによって呼び出されます。

```
virtual BOOL StoreWindowPlacement(
    const CRect& rectNormalPosition,
    int nFlags,
    int nShowCmd);
```

### <a name="parameters"></a>パラメーター

*nFlags*<br/>
[in]最小化されたウィンドウと最小化されたウィンドウと、復元されたウィンドウの間のオペレーティング システムのスイッチの位置を制御するフラグ。

*nShowCmd*<br/>
[in]ウィンドウの表示状態を指定する整数。 使用可能な値の詳細については、次を参照してください。[また](../../mfc/reference/cwnd-class.md#showwindow)します。

*rectNormalPosition*<br/>
[in]復元された状態にあるときに、メイン フレーム ウィンドウの座標を格納する四角形。

### <a name="return-value"></a>戻り値

成功した場合、0 以外の場合それ以外の場合は 0 です。

### <a name="remarks"></a>Remarks

MFC では、既定では、位置と、アプリケーションが終了する前に、メイン フレーム ウィンドウの状態が自動的に保存します。 この情報は、アプリケーションの既定のレジストリの場所に WindowPlacement キーの下の Windows レジストリに格納されます。 アプリケーションの既定のレジストリの場所の詳細については、次を参照してください。 [CWinAppEx::GetRegistryBase](#getregistrybase)します。

メイン フレーム ウィンドウに関する追加情報を格納する場合は、このメソッドをオーバーライドします。

##  <a name="writebinary"></a>  CWinAppEx::WriteBinary

バイナリ データをレジストリに書き込みます。

```
BOOL WriteBinary(
    LPCTSTR lpszEntry,
    LPBYTE pData,
    UINT nBytes);
```

### <a name="parameters"></a>パラメーター

*lpszEntry*<br/>
[in]レジストリ キーの名前を含む文字列。

*pData*<br/>
[in]格納するデータ。

*nBytes*<br/>
[in]サイズ*pData* (バイト単位)。

### <a name="return-value"></a>戻り値

このメソッドが成功した場合は TRUE。それ以外の場合は FALSE です。

### <a name="remarks"></a>Remarks

*LpszEntry*パラメーターは、アプリケーションの既定のレジストリ キーの下にあるレジストリ エントリの名前です。 取得または設定の既定のレジストリ キー、メソッドを使用して、 [CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase](#setregistrybase)それぞれします。

キーを指定して場合*lpszEntry*が存在しないこのメソッドが作成されます。

##  <a name="writeint"></a>  CWinAppEx::WriteInt

数値データをレジストリに書き込みます。

```
BOOL WriteInt(
    LPCTSTR lpszEntry,
    int nValue);
```

### <a name="parameters"></a>パラメーター

*lpszEntry*<br/>
[in]レジストリ キーの名前を含む文字列。

*nValue*<br/>
[in]格納するデータ。

### <a name="return-value"></a>戻り値

このメソッドが成功した場合は TRUE。それ以外の場合は FALSE です。

### <a name="remarks"></a>Remarks

*LpszEntry*パラメーターは、アプリケーションの既定のレジストリ キーの下にあるレジストリ エントリの名前です。 取得または設定の既定のレジストリ キー、メソッドを使用して、 [CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase](#setregistrybase)それぞれします。

キーを指定して場合*lpszEntry*が存在しないこのメソッドが作成されます。

##  <a name="writeobject"></a>  CWinAppEx::WriteObject

派生したデータを書き込み、 [CObject クラス](../../mfc/reference/cobject-class.md)をレジストリにします。

```
BOOL WriteObject(
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>パラメーター

*lpszEntry*<br/>
[in]設定する値を含む文字列。

*obj*<br/>
[in]参照を`CObject`メソッドを格納するデータ。

### <a name="return-value"></a>戻り値

このメソッドが成功した場合は TRUE。それ以外の場合は FALSE です。

### <a name="remarks"></a>Remarks

このメソッドは書き込みます、 *obj*既定のレジストリ キーで指定された値のデータ。 使用[CWinAppEx::GetRegistryBase](#getregistrybase)を現在のレジストリ キーを確認します。

##  <a name="writesectionbinary"></a>  CWinAppEx::WriteSectionBinary

バイナリ データ、レジストリの値を書き込みます。

```
BOOL WriteSectionBinary(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPBYTE pData,
    UINT nBytes);
```

### <a name="parameters"></a>パラメーター

*lpszSubSection*<br/>
[in]レジストリ キーの名前を含む文字列

*lpszEntry*<br/>
[in]設定する値を含む文字列。

*pData*<br/>
[in]レジストリに書き込むデータ。

*nBytes*<br/>
[in]サイズ*pData* (バイト単位)。

### <a name="return-value"></a>戻り値

このメソッドが成功した場合は TRUE。それ以外の場合は FALSE です。

### <a name="remarks"></a>Remarks

*LpszSubSection*パラメーターは、レジストリ エントリの絶対パスではありません。 アプリケーションの既定のレジストリ キーの末尾に追加する相対パスです。 取得または設定の既定のレジストリ キー、メソッドを使用して、 [CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase](#setregistrybase)それぞれします。

キーを指定して場合*lpszEntry*が存在しないこのメソッドが作成されます。

##  <a name="writesectionint"></a>  CWinAppEx::WriteSectionInt

数値データをレジストリに書き込みます。

```
BOOL WriteSectionInt(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    int nValue);
```

### <a name="parameters"></a>パラメーター

*lpszSubSection*<br/>
[in]レジストリ キーの相対パスを含む文字列。

*lpszEntry*<br/>
[in]設定する値を含む文字列。

*nValue*<br/>
[in]レジストリに書き込むデータ。

### <a name="return-value"></a>戻り値

このメソッドが成功した場合は TRUE。それ以外の場合は FALSE です。

### <a name="remarks"></a>Remarks

*LpszSubSection*パラメーターは、レジストリ エントリの絶対パスではありません。 アプリケーションの既定のレジストリ キーに追加する相対パスです。 取得または設定の既定のレジストリ キー、メソッドを使用して、 [CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase](#setregistrybase)それぞれします。

キーを指定して場合*lpszEntry*が存在しないこのメソッドが作成されます。

##  <a name="writesectionobject"></a>  CWinAppEx::WriteSectionObject

派生したデータを書き込み、 [CObject クラス](../../mfc/reference/cobject-class.md)特定のレジストリ値にします。

```
BOOL WriteSectionObject(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>パラメーター

*lpszSubSection*<br/>
[in]レジストリ キーの名前を含む文字列。

*lpszEntry*<br/>
[in]設定する値の名前を含む文字列。

*obj*<br/>
[in]格納するデータ。

### <a name="return-value"></a>戻り値

このメソッドが成功した場合は TRUE。それ以外の場合は FALSE です。

### <a name="remarks"></a>Remarks

*LpszSubSection*パラメーターは、レジストリ エントリの絶対パスではありません。 アプリケーションの既定のレジストリ キーの末尾に追加する相対パスです。 取得または設定の既定のレジストリ キー、メソッドを使用して、 [CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase](#setregistrybase)、それぞれします。

場合は、値を指定して*lpszEntry*で指定されたレジストリ キーが存在しない*lpszSubSection*、このメソッドはその値を作成します。

##  <a name="writesectionstring"></a>  CWinAppEx::WriteSectionString

レジストリの値を文字列データを書き込みます。

```
BOOL WriteSectionString(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>パラメーター

*lpszSubSection*<br/>
[in]レジストリ キーの名前を含む文字列。

*lpszEntry*<br/>
[in]設定する値を含む文字列。

*lpszValue*<br/>
[in]レジストリに書き込む文字列データ。

### <a name="return-value"></a>戻り値

このメソッドが成功した場合は TRUE。それ以外の場合は FALSE です。

### <a name="remarks"></a>Remarks

*LpszSubSection*パラメーターは、レジストリ エントリの絶対パスではありません。 アプリケーションの既定のレジストリ キーの末尾に追加する相対パスです。 取得または設定の既定のレジストリ キー、メソッドを使用して、 [CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase](#setregistrybase)、それぞれします。

場合は、値を指定して*lpszEntry*が存在しない*lpszSubSection*、このメソッドが作成されます。

##  <a name="writestring"></a>  CWinAppEx::WriteString

文字列をレジストリにデータを書き込みます。

```
BOOL WriteString(
    LPCTSTR lpszEntry,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>パラメーター

*lpszEntry*<br/>
[in]レジストリ キーの名前を含む文字列。

*lpszValue*<br/>
[in]格納するデータ。

### <a name="return-value"></a>戻り値

このメソッドが成功した場合は TRUE。それ以外の場合は FALSE です。

### <a name="remarks"></a>Remarks

*LpszEntry*パラメーターは、アプリケーションの既定のレジストリ キーの下にあるレジストリ エントリの名前です。 取得または設定の既定のレジストリ キー、メソッドを使用して、 [CWinAppEx::GetRegistryBase](#getregistrybase)と[CWinAppEx::SetRegistryBase](#setregistrybase)それぞれします。

キーを指定して場合*lspzEntry*が存在しないこのメソッドが作成されます。

## <a name="see-also"></a>関連項目

[階層図](../../mfc/hierarchy-chart.md)<br/>
[クラス](../../mfc/reference/mfc-classes.md)<br/>
[CWinApp クラス](../../mfc/reference/cwinapp-class.md)<br/>
[CMouseManager クラス](../../mfc/reference/cmousemanager-class.md)<br/>
[CContextMenuManager クラス](../../mfc/reference/ccontextmenumanager-class.md)<br/>
[CKeyboardManager クラス](../../mfc/reference/ckeyboardmanager-class.md)<br/>
[CUserToolsManager クラス](../../mfc/reference/cusertoolsmanager-class.md)
