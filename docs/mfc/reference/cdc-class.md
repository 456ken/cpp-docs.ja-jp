---
title: CDC クラス
ms.date: 11/19/2018
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
ms.openlocfilehash: fc5d41221ab0f9679e7d38a399464efc1a38dd52
ms.sourcegitcommit: c3093251193944840e3d0a068ecc30e6449624ba
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/04/2019
ms.locfileid: "57305082"
---
# <a name="cdc-class"></a>CDC クラス

デバイス コンテキスト オブジェクトのクラスを定義します。

## <a name="syntax"></a>構文

```
class CDC : public CObject
```

## <a name="members"></a>メンバー

### <a name="public-constructors"></a>パブリック コンストラクター

|名前|説明|
|----------|-----------------|
|[CDC::CDC](#cdc)|`CDC` オブジェクトを構築します。|

### <a name="public-methods"></a>パブリック メソッド

|名前|説明|
|----------|-----------------|
|[CDC::AbortDoc](#abortdoc)|現在の印刷ジョブの最後に呼び出した後、アプリケーションがデバイスに書き込みますがすべて消去を終了、`StartDoc`メンバー関数。|
|[CDC::AbortPath](#abortpath)|閉じ、デバイス コンテキストの任意のパスを破棄します。|
|[CDC::AddMetaFileComment](#addmetafilecomment)|指定された拡張形式メタファイルにバッファーからのコメントをコピーします。|
|[CDC::AlphaBlend](#alphablend)|透明または半透明ピクセルのビットマップを表示します。|
|[CDC::AngleArc](#anglearc)|線分と円弧を描画し、現在の位置を円弧の終点に移動します。|
|[CDC::Arc](#arc)|楕円の円弧を描画します。|
|[CDC::ArcTo](#arcto)|楕円の円弧を描画します。この機能に似ています`Arc`, 現在の位置が更新される点が異なります。|
|[CDC::Attach](#attach)|これに Windows デバイス コンテキストをアタッチします`CDC`オブジェクト。|
|[CDC::BeginPath](#beginpath)|デバイス コンテキストでは、パスの角かっこを開きます。|
|[CDC::BitBlt](#bitblt)|指定したデバイス コンテキストからビットマップをコピーします。|
|[CDC::Chord](#chord)|コード (楕円と直線セグメントで囲まれる閉じた図) を描画します。|
|[CDC::CloseFigure](#closefigure)|パス内の開いている図を閉じます。|
|[CDC::CreateCompatibleDC](#createcompatibledc)|別のデバイス コンテキストと互換性があるメモリ デバイス コンテキストを作成します。 メモリ内のイメージを準備するのにには、これを使用できます。|
|[CDC::CreateDC](#createdc)|特定のデバイスのデバイス コンテキストを作成します。|
|[CDC::CreateIC](#createic)|特定のデバイスの情報コンテキストを作成します。 これは、高速デバイス コンテキストを作成することがなく、デバイスに関する情報を取得する方法を提供します。|
|[CDC::DeleteDC](#deletedc)|これに関連付けられている Windows デバイス コンテキストを削除します。`CDC`オブジェクト。|
|[CDC::DeleteTempMap](#deletetempmap)|メソッドを呼び出して、`CWinApp`一時を削除するアイドル処理ハンドラー`CDC`によって作成されたオブジェクト`FromHandle`します。 また、デバイス コンテキストをデタッチします。|
|[CDC::Detach](#detach)|これから Windows デバイス コンテキストを切り離します`CDC`オブジェクト。|
|[CDC::DPtoHIMETRIC](#dptohimetric)|デバイス単位を HIMETRIC 単位に変換します。|
|[CDC::DPtoLP](#dptolp)|デバイス単位を論理単位に変換します。|
|[CDC::Draw3dRect](#draw3drect)|3 次元の四角形を描画します。|
|[CDC::DrawDragRect](#drawdragrect)|消去し、ドラッグされると、四角形を再描画します。|
|[CDC::DrawEdge](#drawedge)|四角形の辺を描画します。|
|[CDC::DrawEscape](#drawescape)|描画は、グラフィックス デバイス インターフェイス (GDI) から直接使用できないビデオ ディスプレイの機能にアクセスします。|
|[CDC::DrawFocusRect](#drawfocusrect)|フォーカスを示すために使用するスタイルでは、四角形を描画します。|
|[CDC::DrawFrameControl](#drawframecontrol)|Frame コントロールを描画します。|
|[CDC::DrawIcon](#drawicon)|アイコンを描画します。|
|[CDC::DrawState](#drawstate)|イメージを表示し、状態を示すために視覚効果を適用します。|
|[CDC::DrawText](#drawtext)|書式設定された指定した四角形内のテキストを描画します。|
|[CDC::DrawTextEx](#drawtextex)|書式設定された追加の形式を使用して指定した四角形内のテキストを描画します。|
|[CDC::Ellipse](#ellipse)|楕円を描きます。|
|[CDC::EndDoc](#enddoc)|によって開始された印刷ジョブを終了、`StartDoc`メンバー関数。|
|[CDC::EndPage](#endpage)|ページを終了するデバイス ドライバーに通知します。|
|[CDC::EndPath](#endpath)|パスの角かっこを終了し、デバイス コンテキストに、角かっこで定義されているパスを選択します。|
|[CDC::EnumObjects](#enumobjects)|ペンを列挙し、デバイス コンテキストで使用できるブラシします。|
|[CDC::Escape](#escape)|アプリケーションでは GDI を介して特定のデバイスから直接使用できない機能にアクセスできます。 Windows エスケープ関数へのアクセスができます。 アプリケーションによって行われた呼び出しをエスケープは変換され、デバイス ドライバーに送信します。|
|[CDC::ExcludeClipRect](#excludecliprect)|指定した四角形から既存のクリッピング領域で構成される新しいクリップ領域を作成します。|
|[CDC::ExcludeUpdateRgn](#excludeupdatergn)|クリッピング領域から更新されたウィンドウ領域を除外することで、ウィンドウの無効な領域での描画をできないようにします。|
|[CDC::ExtFloodFill](#extfloodfill)|現在のブラシで領域を塗りつぶします。 も柔軟性、 [CDC::FloodFill](#floodfill)メンバー関数。|
|[CDC::ExtTextOut](#exttextout)|現在選択されているフォントを使用して四角形領域内の文字の文字列を書き込みます。|
|[CDC::FillPath](#fillpath)|現在のパス内の開いている図形を閉じ、現在のブラシと多角形の塗りつぶしモードを使用してパスの内部を塗りつぶします。|
|[CDC::FillRect](#fillrect)|特定のブラシを使用して、指定した四角形を塗りつぶします。|
|[CDC::FillRgn](#fillrgn)|ブラシを指定して、特定のリージョンを設定します。|
|[CDC::FillSolidRect](#fillsolidrect)|純色で四角形を塗りつぶします。|
|[CDC::FlattenPath](#flattenpath)|現在のデバイス コンテキストに選択したパス内の任意の曲線に変換し、行のシーケンスに、各曲線。|
|[CDC::FloodFill](#floodfill)|現在のブラシで領域を塗りつぶします。|
|[CDC::FrameRect](#framerect)|四角形の境界線を描画します。|
|[CDC::FrameRgn](#framergn)|境界線を描画ブラシを使用して、特定のリージョン。|
|[CDC::FromHandle](#fromhandle)|ポインターを返します、`CDC`デバイス コンテキストを識別するハンドルが指定されるとします。 
  `CDC` オブジェクトがハンドルに関連付けられていない場合は、一時的な `CDC` オブジェクトが生成され、関連付けられます。|
|[CDC::GetArcDirection](#getarcdirection)|デバイス コンテキストの現在の円弧の方向を取得します。|
|[CDC::GetAspectRatioFilter](#getaspectratiofilter)|現在の縦横比のフィルターの設定を取得します。|
|[CDC::GetBkColor](#getbkcolor)|現在の背景色を取得します。|
|[CDC::GetBkMode](#getbkmode)|バック グラウンド モードを取得します。|
|[CDC::GetBoundsRect](#getboundsrect)|現在までの累積外接する四角形の指定したデバイス コンテキストを返します。|
|[CDC::GetBrushOrg](#getbrushorg)|現在のブラシの原点を取得します。|
|[CDC::GetCharABCWidths](#getcharabcwidths)|論理ユニットは、現在のフォントから特定の範囲内の連続する文字の幅を取得します。|
|[CDC::GetCharABCWidthsI](#getcharabcwidthsi)|現在の TrueType フォントを指定の範囲内で連続したグリフのインデックスの論理単位の幅を取得します。|
|[CDC::GetCharacterPlacement](#getcharacterplacement)|文字列に関するさまざまな情報を取得します。|
|[CDC::GetCharWidth](#getcharwidth)|現在のフォントから特定の範囲内の連続する文字の小数部の幅を取得します。|
|[CDC::GetCharWidthI](#getcharwidthi)|現在のフォントを指定の範囲内で連続したグリフのインデックスの論理座標、幅を取得します。|
|[CDC::GetClipBox](#getclipbox)|現在のクリップ領域を最小の外接する四角形の寸法を取得します。|
|[CDC::GetColorAdjustment](#getcoloradjustment)|デバイス コンテキストの色の調整値を取得します。|
|[CDC::GetCurrentBitmap](#getcurrentbitmap)|現在選択されているポインターを返します`CBitmap`オブジェクト。|
|[CDC::GetCurrentBrush](#getcurrentbrush)|現在選択されているポインターを返します`CBrush`オブジェクト。|
|[CDC::GetCurrentFont](#getcurrentfont)|現在選択されているポインターを返します`CFont`オブジェクト。|
|[CDC::GetCurrentPalette](#getcurrentpalette)|現在選択されているポインターを返します`CPalette`オブジェクト。|
|[CDC::GetCurrentPen](#getcurrentpen)|現在選択されているポインターを返します`CPen`オブジェクト。|
|[CDC::GetCurrentPosition](#getcurrentposition)|(論理座標) で、ペンの現在の位置を取得します。|
|[CDC::GetDCBrushColor](#getdcbrushcolor)|現在のブラシの色を取得します。|
|[CDC::GetDCPenColor](#getdcpencolor)|現在のペンの色を取得します。|
|[CDC::GetDeviceCaps](#getdevicecaps)|指定した特定のディスプレイ デバイスの機能については、デバイスに固有の種類を取得します。|
|[CDC::GetFontData](#getfontdata)|スケーラブルなフォント ファイルからフォント メトリック情報を取得します。 取得する情報は、フォント ファイルに返される情報の長さのオフセットを指定することによって識別されます。|
|[CDC::GetFontLanguageInfo](#getfontlanguageinfo)|現在選択されているフォントを指定した表示コンテキストに関する情報を返します。|
|[CDC::GetGlyphOutline](#getglyphoutline)|曲線のアウトラインまたはビットマップでは、現在のフォントをアウトライン文字を取得します。|
|[CDC::GetGraphicsMode](#getgraphicsmode)|指定したデバイス コンテキストの現在のグラフィックス モードを取得します。|
|[CDC::GetHalftoneBrush](#gethalftonebrush)|ハーフトーン ブラシを取得します。|
|[CDC::GetKerningPairs](#getkerningpairs)|指定したデバイス コンテキストで現在選択されているフォントのペアをカーニング文字を取得します。|
|[CDC::GetLayout](#getlayout)|デバイス コンテキスト (DC) のレイアウトを取得します。 (既定値) を右または右から左に、レイアウトでいずれかのおくことができます (ミラー)。|
|[CDC::GetMapMode](#getmapmode)|現在のマップ モードを取得します。|
|[CDC::GetMiterLimit](#getmiterlimit)|デバイス コンテキストのマイタ制限値を返します。|
|[CDC::GetNearestColor](#getnearestcolor)|特定のデバイスを表すことができる指定された論理色に最も近い論理色を取得します。|
|[CDC::GetOutlineTextMetrics](#getoutlinetextmetrics)|TrueType フォントのフォント メトリック情報を取得します。|
|[CDC::GetOutputCharWidth](#getoutputcharwidth)|出力デバイス コンテキストを使用して現在のフォントの文字の隣接するグループの個々 の文字の幅を取得します。|
|[CDC::GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|幅と、出力デバイス コンテキストの文字の文字列の高さを計算します。|
|[CDC::GetOutputTextExtent](#getoutputtextextent)|大きさを現在のフォントを使用して、出力デバイス コンテキストでのテキストの行の高さと幅を計算します。|
|[CDC::GetOutputTextMetrics](#getoutputtextmetrics)|出力デバイス コンテキストから現在のフォント メトリックを取得します。|
|[CDC::GetPath](#getpath)|行の端点と、デバイス コンテキストに選択されているパスに曲線の制御点を定義する座標を取得します。|
|[CDC::GetPixel](#getpixel)|指定したポイントにピクセルの RGB 色の値を取得します。|
|[CDC::GetPolyFillMode](#getpolyfillmode)|現在の多角形の塗りつぶしモードを取得します。|
|[CDC::GetROP2](#getrop2)|現在の描画モードを取得します。|
|[CDC::GetSafeHdc](#getsafehdc)|返します[CDC::m_hDC](#m_hdc)、出力デバイス コンテキスト。|
|[CDC::GetStretchBltMode](#getstretchbltmode)|現在のビットマップの伸縮モードを取得します。|
|[CDC::GetTabbedTextExtent](#gettabbedtextextent)|幅と高さの属性のデバイス コンテキストでの文字列を計算します。|
|[CDC::GetTextAlign](#gettextalign)|テキストの配置フラグを取得します。|
|[CDC::GetTextCharacterExtra](#gettextcharacterextra)|現在の文字間隔の設定を取得します。|
|[CDC::GetTextColor](#gettextcolor)|現在のテキストの色を取得します。|
|[CDC::GetTextExtent](#gettextextent)|幅と現在のフォントを使用して、ディメンションを決定する属性のデバイス コンテキストでのテキストの行の高さを計算します。|
|[CDC::GetTextExtentExPointI](#gettextextentexpointi)|指定した領域内に収まるし、それらの各文字の配列をテキスト範囲で設定を指定した文字列の文字数を取得します。|
|[CDC::GetTextExtentPointI](#gettextextentpointi)|幅と高さのグリフのインデックスの指定した配列を取得します。|
|[CDC::GetTextFace](#gettextface)|Null で終わる文字列として、バッファーに現在のフォントのタイプフェイス名をコピーします。|
|[CDC::GetTextMetrics](#gettextmetrics)|属性のデバイス コンテキストから現在のフォント メトリックを取得します。|
|[CDC::GetViewportExt](#getviewportext)|ビューポートの x 範囲と y 範囲を取得します。|
|[CDC::GetViewportOrg](#getviewportorg)|ビューポートの原点の x 座標と y 座標を取得します。|
|[CDC::GetWindow](#getwindow)|ディスプレイ デバイス コンテキストに関連付けられているウィンドウを返します。|
|[CDC::GetWindowExt](#getwindowext)|関連付けられているウィンドウの x 範囲と y 範囲を取得します。|
|[CDC::GetWindowOrg](#getwindoworg)|関連付けられているウィンドウの原点の x 座標と y 座標を取得します。|
|[CDC::GetWorldTransform](#getworldtransform)|ページ領域の変換を現在のワールド空間を取得します。|
|[CDC::GradientFill](#gradientfill)|四角形と三角形の構造を gradating 色で塗りつぶします。|
|[CDC::GrayString](#graystring)|描画には、指定した位置に (灰色) のテキストが淡色表示されます。|
|[CDC::HIMETRICtoDP](#himetrictodp)|デバイス単位 HIMETRIC 単位に変換します。|
|[CDC::HIMETRICtoLP](#himetrictolp)|HIMETRIC 単位を論理単位に変換します。|
|[CDC::IntersectClipRect](#intersectcliprect)|現在のリージョンと四角形の交差部分を形成して、新しいクリップ領域を作成します。|
|[CDC::InvertRect](#invertrect)|四角形の内容を反転します。|
|[CDC::InvertRgn](#invertrgn)|領域内の色を反転します。|
|[CDC::IsPrinting](#isprinting)|印刷デバイス コンテキストが使用されているかどうかを判断します。|
|[CDC::LineTo](#lineto)|現在の位置が、ポイント、線を描画します。|
|[CDC::LPtoDP](#lptodp)|論理ユニットをデバイス単位に変換します。|
|[CDC::LPtoHIMETRIC](#lptohimetric)|論理ユニットを HIMETRIC 単位に変換します。|
|[CDC::MaskBlt](#maskblt)|指定したマスクとラスター オペレーションを使用してソースと変換先のビットマップのカラー データを結合します。|
|[CDC::ModifyWorldTransform](#modifyworldtransform)|指定されたモードを使用してデバイス コンテキストのワールド変換を変更します。|
|[CDC::MoveTo](#moveto)|現在の位置に移動します。|
|[CDC::OffsetClipRgn](#offsetcliprgn)|特定のデバイスのクリッピング領域に移動します。|
|[CDC::OffsetViewportOrg](#offsetviewportorg)|現在のビューポートの原点の座標に対して相対的ビューポートの原点を変更します。|
|[CDC::OffsetWindowOrg](#offsetwindoworg)|現在のウィンドウの原点の座標に対するウィンドウの原点を変更します。|
|[CDC::PaintRgn](#paintrgn)|選択したブラシで領域を塗りつぶします。|
|[CDC::PatBlt](#patblt)|ビット パターンを作成します。|
|[CDC::Pie](#pie)|扇形を描画します。|
|[CDC::PlayMetaFile](#playmetafile)|特定のデバイスでは、指定されたメタファイルのコンテンツを再生します。 強化されたバージョンの`PlayMetaFile`特定の拡張形式メタファイルに格納されている画像が表示されます。 メタファイルを何度でも再生できます。|
|[CDC::PlgBlt](#plgblt)|指定されたデバイス コンテキストの指定した平行四辺形に元のデバイス コンテキストで指定した四角形から色データのビットのビット ブロック転送を実行します。|
|[CDC::PolyBezier](#polybezier)|1 つまたは複数のベジエ スプラインを描画します。 現在の位置が使用も更新します。|
|[CDC::PolyBezierTo](#polybezierto)|1 つまたは複数のベジエ スプラインを描画し、最後のベジエ スプラインの終了ポイントに現在の位置を移動します。|
|[CDC::PolyDraw](#polydraw)|一連の線分とベジエ スプラインを描画します。 この関数は、現在の位置を更新します。|
|[CDC::Polygon](#polygon)|2 つ以上の点 (頂点) の線で接続されているので構成される多角形を描画します。|
|[CDC::Polyline](#polyline)|一連の指定した点を結ぶ線分を描画します。|
|[CDC::PolylineTo](#polylineto)|1 つまたは複数の直線を描画し、最後の行の終了ポイントに現在の位置を移動します。|
|[CDC::PolyPolygon](#polypolygon)|現在の多角形の塗りつぶしモードを使用して入力が 2 つ以上の多角形を作成します。 多角形は、不整合である可能性があります。 または重なる可能性があります。|
|[CDC::PolyPolyline](#polypolyline)|接続された線分の複数の系列を描画します。 現在の位置が使用も、この関数によって更新します。|
|[CDC::PtVisible](#ptvisible)|指定したポイントはクリップ領域内がかどうかを指定します。|
|[CDC::RealizePalette](#realizepalette)|システム パレットには、現在の論理パレットのパレット エントリをマップします。|
|[CDC::Rectangle](#rectangle)|現在のペンを使用して四角形を描画し、現在のブラシを使用してを塗りつぶします。|
|[CDC::RectVisible](#rectvisible)|指定した四角形の任意の部分がクリップ領域内にあるかどうかを判断します。|
|[CDC::ReleaseAttribDC](#releaseattribdc)|リリース`m_hAttribDC`属性のデバイス コンテキスト。|
|[CDC::ReleaseOutputDC](#releaseoutputdc)|リリース`m_hDC`、出力デバイス コンテキスト。|
|[CDC::ResetDC](#resetdc)|更新プログラム、`m_hAttribDC`デバイス コンテキスト。|
|[CDC::RestoreDC](#restoredc)|デバイス コンテキストを以前の状態を保存する復元`SaveDC`します。|
|[CDC::RoundRect](#roundrect)|現在のペンを使用して、現在のブラシを使用して入力の角が丸い四角形を描画します。|
|[CDC::SaveDC](#savedc)|デバイス コンテキストの現在の状態を保存します。|
|[CDC::ScaleViewportExt](#scaleviewportext)|ビューポートの範囲を現在の値を基準を変更します。|
|[CDC::ScaleWindowExt](#scalewindowext)|現在の値を基準としたウィンドウの範囲を変更します。|
|[CDC::ScrollDC](#scrolldc)|Bits の四角形は、水平および垂直にスクロールします。|
|[CDC::SelectClipPath](#selectclippath)|指定されたモードを使用して、既存のクリッピング領域で新しい地域を組み合わせて、デバイス コンテキストのクリッピング領域として、現在のパスを選択します。|
|[CDC::SelectClipRgn](#selectcliprgn)|指定されたモードを使用して、現在のクリップ領域と指定された領域を結合します。|
|[CDC::SelectObject](#selectobject)|ペンなど、GDI 描画オブジェクトを選択します。|
|[CDC::SelectPalette](#selectpalette)|論理パレットを選択します。|
|[CDC::SelectStockObject](#selectstockobject)|定義済みのストック ペン、ブラシ、または Windows によって提供されるフォントのいずれかを選択します。|
|[CDC::SetAbortProc](#setabortproc)|Windows を呼び出す場合は、印刷ジョブを中止する必要がありますプログラマが指定したコールバック関数を設定します。|
|[CDC::SetArcDirection](#setarcdirection)|円弧と四角形の関数に使用する描画方向を設定します。|
|[CDC::SetAttribDC](#setattribdc)|セット`m_hAttribDC`属性のデバイス コンテキスト。|
|[CDC::SetBkColor](#setbkcolor)|現在の背景色を設定します。|
|[CDC::SetBkMode](#setbkmode)|バック グラウンド モードを設定します。|
|[CDC::SetBoundsRect](#setboundsrect)|指定したデバイス コンテキストの境界の四角形の情報の蓄積を制御します。|
|[CDC::SetBrushOrg](#setbrushorg)|選択したデバイス コンテキスト ブラシの次の配信元を指定します。|
|[CDC::SetColorAdjustment](#setcoloradjustment)|指定した値を使用してデバイス コンテキストの色の調整値を設定します。|
|[CDC::SetDCBrushColor](#setdcbrushcolor)|現在のブラシの色を設定します。|
|[CDC::SetDCPenColor](#setdcpencolor)|現在のペンの色を設定します。|
|[CDC::SetGraphicsMode](#setgraphicsmode)|指定したデバイス コンテキストの現在のグラフィックス モードを設定します。|
|[CDC::SetLayout](#setlayout)|デバイス コンテキスト (DC) のレイアウトを変更します。|
|[CDC::SetMapMode](#setmapmode)|現在のマップ モードを設定します。|
|[CDC::SetMapperFlags](#setmapperflags)|物理フォントの論理フォントをマップ フォント マッパーが使用するアルゴリズムを変更します。|
|[CDC::SetMiterLimit](#setmiterlimit)|デバイス コンテキストのマイター結合の長さの制限を設定します。|
|[CDC::SetOutputDC](#setoutputdc)|セット`m_hDC`、出力デバイス コンテキスト。|
|[CDC::SetPixel](#setpixel)|指定した位置に指定した色の最も近いピクセルに設定します。|
|[CDC::SetPixelV](#setpixelv)|指定した色の最も近いものを指定した座標のピクセルを設定します。 `SetPixelV` 高速`SetPixel`を実際に描画するポイントの色の値を返す必要はないためです。|
|[CDC::SetPolyFillMode](#setpolyfillmode)|多角形の塗りつぶしモードを設定します。|
|[CDC::SetROP2](#setrop2)|現在の描画モードを設定します。|
|[CDC::SetStretchBltMode](#setstretchbltmode)|ビットマップの伸縮モードを設定します。|
|[CDC::SetTextAlign](#settextalign)|テキストの配置フラグを設定します。|
|[CDC::SetTextCharacterExtra](#settextcharacterextra)|文字間隔の量を設定します。|
|[CDC::SetTextColor](#settextcolor)|テキストの色を設定します。|
|[CDC::SetTextJustification](#settextjustification)|文字列の区切り文字にスペースを追加します。|
|[CDC::SetViewportExt](#setviewportext)|ビューポートの x 範囲と y 範囲を設定します。|
|[CDC::SetViewportOrg](#setviewportorg)|ビューポートの原点を設定します。|
|[CDC::SetWindowExt](#setwindowext)|関連付けられているウィンドウの x 範囲と y 範囲を設定します。|
|[CDC::SetWindowOrg](#setwindoworg)|デバイス コンテキストのウィンドウの原点を設定します。|
|[CDC::SetWorldTransform](#setworldtransform)|ページ領域の変換には、現在のワールド空間を設定します。|
|[CDC::StartDoc](#startdoc)|新しい印刷ジョブが開始されるデバイス ドライバーに通知します。|
|[CDC::StartPage](#startpage)|新しいページが開始されるデバイス ドライバーに通知します。|
|[CDC::StretchBlt](#stretchblt)|変換先四角形を拡大または変換先の四角形の寸法に合わせて必要な場合、ビットマップの圧縮に元の四角形とデバイスからビットマップに移動します。|
|[CDC::StrokeAndFillPath](#strokeandfillpath)|パスの任意の開いている図形を閉じて、現在のペンを使用して、パスのアウトラインが取れて現在のブラシを使用してその内部を塗りつぶします。|
|[CDC::StrokePath](#strokepath)|現在のペンを使用して、指定されたパスを表示します。|
|[CDC::TabbedTextOut](#tabbedtextout)|指定の場所にタブ ストップの位置の配列の指定した値にタブを展開する、文字の文字列を書き込みます。|
|[CDC::TextOut](#textout)|現在選択されているフォントを使用して指定の位置にある文字の文字列を書き込みます。|
|[CDC::TransparentBlt](#transparentblt)|指定した色を転送に透過的な表示、コピー先デバイス コンテキストに指定された元のデバイス コンテキストからカラー データのビット ブロックを転送します。|
|[CDC::UpdateColors](#updatecolors)|更新プログラム現在を照合することによって、デバイス コンテキストのクライアント領域は、システム パレットをピクセル単位でのクライアント領域の色します。|
|[CDC::WidenPath](#widenpath)|パスがデバイス コンテキストに現在選択されているペンを使用して描画された場合に描画される領域として、現在のパスを再定義します。|

### <a name="public-operators"></a>パブリック演算子

|名前|説明|
|----------|-----------------|
|[CDC::operator HDC](#operator_hdc)|デバイス コンテキストのハンドルを取得します。|

### <a name="public-data-members"></a>パブリック データ メンバー

|名前|説明|
|----------|-----------------|
|[CDC::m_hAttribDC](#m_hattribdc)|これで使用される属性デバイス コンテキスト`CDC`オブジェクト。|
|[CDC::m_hDC](#m_hdc)|これで使用される出力デバイス コンテキスト`CDC`オブジェクト。|

## <a name="remarks"></a>Remarks

`CDC`オブジェクトに関連付けられたウィンドウのクライアント領域のディスプレイ コンテキストを操作するためのディスプレイまたはプリンター、メンバーなどのデバイス コンテキストを操作するためのメンバー関数を提供します。

関数メンバーを介してすべての描画を行う、`CDC`オブジェクト。 クラスでは、メンバー関数が描画ツール、タイプ セーフなグラフィックス デバイス インターフェイス (GDI) オブジェクトの選択、色とパレットを使用すると、デバイス コンテキストの操作を提供します。 メンバー関数を取得および設定の描画属性、マッピング、リージョン、クリッピング、線を描画、および描画の単純な図形、楕円、操作、座標変換、ウィンドウの範囲の操作、ビューポートの操作も提供し、多角形です。 メンバー関数は、テキストを描画、フォントの操作、プリンター エスケープを使用して、スクロール、およびメタファイルの再生も提供されます。

使用する、`CDC`オブジェクトで、その構築し、そのメンバーにデバイス コンテキストを使用する Windows 関数に相当する関数を呼び出します。

> [!NOTE]
>  Windows 95/98 では、すべての画面座標で 16 ビットに制限されます。 そのため、 **int**に渡される、`CDC`メンバー関数は、-32768 ~ 32767 の範囲でなければなりません。

派生したいくつかのクラスを提供する、Microsoft Foundation Class ライブラリ、特定の用途に`CDC`します。 `CPaintDC` 呼び出しをカプセル化`BeginPaint`と`EndPaint`します。 `CClientDC` ウィンドウのクライアント領域に関連付けられているディスプレイ コンテキストを管理します。 `CWindowDC` フレームのコントロールを含むウィンドウ全体に関連付けられているディスプレイ コンテキストを管理します。 `CMetaFileDC` メタファイル デバイス コンテキストに関連付けます。

`CDC` 2 つのメンバー関数は、 [GetLayout](#getlayout)と[SetLayout](#setlayout)、ウィンドウからそのレイアウトを継承していないデバイス コンテキストのレイアウトの反転の。 このような右から左方向は、アラビア語やヘブライ語文字のレイアウトがヨーロッパの標準などのカルチャ用に記述されたアプリケーションの必要があります。

`CDC` 2 つのデバイス コンテキストを含む[m_hDC](#m_hdc)と[は](#m_hattribdc)でありの作成時に、`CDC`オブジェクト、同じデバイスを参照してください。 `CDC` すべての出力 GDI 呼び出しを指示`m_hDC`呼び出しをほとんど属性 GDI と`m_hAttribDC`します。 (属性、呼び出しの例は、 `GetTextColor`、中に`SetTextColor`出力、呼び出しのことです)。

フレームワークがこれらの 2 つのデバイス コンテキストを使用して実装するなど、`CMetaFileDC`メタファイルに物理デバイスからの属性の読み取り中に出力を送信するオブジェクト。 印刷プレビューは、同様の方法で、フレームワークに実装されます。 同様の方法で、アプリケーション固有のコードで 2 つのデバイス コンテキストを使用することもできます。

ときに両方のテキスト メトリック情報が必要な場合がありますが、`m_hDC`と`m_hAttribDC`デバイス コンテキスト。 次の関数のペアは、この機能を提供します。

|使用します。|M_hDC を使用します。|
|-----------------------|-----------------|
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|
|[GetTextMetrics](#gettextmetrics)|[GetOutputTextMetrics](#getoutputtextmetrics)|
|[GetCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|

詳細については`CDC`を参照してください[デバイス コンテキスト](../../mfc/device-contexts.md)します。

## <a name="inheritance-hierarchy"></a>継承階層

[CObject](../../mfc/reference/cobject-class.md)

`CDC`

## <a name="requirements"></a>要件

**ヘッダー:** afxwin.h

##  <a name="abortdoc"></a>  CDC::AbortDoc

現在の印刷ジョブを終了し、アプリケーションが最後の呼び出し以降に、デバイスに書き込まれたすべての消去、 [StartDoc](#startdoc)メンバー関数。

```
int AbortDoc();
```

### <a name="return-value"></a>戻り値

成功した場合、0 以上の値または負の値を使用している場合は、エラーが発生しました。 一般的なエラーの値とその意味を次に示します。

- SP_ERROR の一般的なエラー。

- させることでよりいない十分なディスク領域がスプールされている、現在使用できると、空き領域が使用可能になります。

- SP_OUTOFMEMORY いない十分なメモリがスプールのために使用できます。

- SP_USERABORT ユーザーは、プリント マネージャーを使ってジョブを終了します。

### <a name="remarks"></a>Remarks

このメンバー関数は、ABORTDOC のプリンター エスケープを置き換えます。

`AbortDoc` 次の終了を使用する必要があります。

- 印刷操作を中止関数を使用して指定されていない[SetAbortProc](#setabortproc)します。

- まだ達していないの最初の NEWFRAME または NEXTBAND 印刷操作は、呼び出しをエスケープします。

いずれかを使用して、操作を終了する、読み取ろうとしないで、アプリケーションには、印刷のミスや印刷操作の中止が発生すると、 [EndDoc](#enddoc)または`AbortDoc`クラスのメンバー関数`CDC`します。 GDI は、エラー値を返す前に、操作を自動的に終了します。

呼び出す必要がありますが、アプリケーションでは、印刷操作をキャンセルするユーザーを許可する ダイアログ ボックスを表示する場合`AbortDoc` ダイアログ ボックスを破棄する前にします。

印刷ジョブを開始するプリント マネージャーを使用した場合は、呼び出す`AbortDoc`全体スプール ジョブが消去されます-プリンターが何も受信します。 以前に印刷ジョブを開始するプリント マネージャーを使用しない場合、データに送信された前に、プリンター`AbortDoc`が呼び出されました。 ここでは、プリンター ドライバーでは、(可能な) 場合、プリンタをリセットし、印刷ジョブを終了します。

### <a name="example"></a>例

  例をご覧ください[CDC::StartDoc](#startdoc)します。

##  <a name="abortpath"></a>  CDC::AbortPath

閉じ、デバイス コンテキストの任意のパスを破棄します。

```
BOOL AbortPath();
```

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

デバイス コンテキストでパスを開くの角かっこがある場合は、パスの角かっこは閉じられ、パスが破棄されます。 デバイス コンテキストに閉じたパスがある場合、パスは破棄されます。

##  <a name="addmetafilecomment"></a>  CDC::AddMetaFileComment

指定された拡張形式メタファイルにバッファーからのコメントをコピーします。

```
BOOL AddMetaFileComment(
    UINT nDataSize,
    const BYTE* pCommentData);
```

### <a name="parameters"></a>パラメーター

*nDataSize*<br/>
コメントのバッファーの長さをバイト単位で指定します。

*pCommentData*<br/>
コメントが含まれているバッファーへのポインター。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

コメントは、プライベートな情報を含めることができます-など、日付と、画像のソースが作成されました。 コメントは、後に、データ、アプリケーションの署名で開始する必要があります。 コメントは、位置に固有のデータを含めることはできません。 位置に固有のデータは、レコードの場所を指定および使用しないで含まれるため、別のメタファイル内で 1 つのメタファイルを埋め込むことができます。 この関数は、拡張メタファイルでのみ使用できます。

##  <a name="alphablend"></a>  CDC::AlphaBlend

透明または半透明ピクセルのビットマップを表示するには、このメンバー関数を呼び出します。

```
BOOL AlphaBlend(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    BLENDFUNCTION blend);
```

### <a name="parameters"></a>パラメーター

*xDest*<br/>
論理ユニットは、先の四角形の左上隅の x 座標を指定します。

*yDest*<br/>
論理ユニットは、先の四角形の左上隅の y 座標を指定します。

*nDestWidth*<br/>
論理ユニットは、先の四角形の幅を指定します。

*nDestHeight*<br/>
論理ユニットは、先の四角形の高さを指定します。

*pSrcDC*<br/>
元のデバイス コンテキストへのポインター。

*xSrc*<br/>
論理ユニットは、元の四角形の左上隅の x 座標を指定します。

*ySrc*<br/>
論理ユニットは、元の四角形の左上隅の y 座標を指定します。

*nSrcWidth*<br/>
論理ユニットは、元の四角形の幅を指定します。

*nSrcHeight*<br/>
論理ユニットは、元の四角形の高さを指定します。

*blend*<br/>
指定します、 [BLENDFUNCTION](/windows/desktop/api/wingdi/ns-wingdi-_blendfunction)構造体。

### <a name="return-value"></a>戻り値

成功した場合は TRUE、それ以外の場合は FALSE。

### <a name="remarks"></a>Remarks

参照してください[AlphaBlend](/windows/desktop/api/wingdi/nf-wingdi-alphablend)詳細については、Windows SDK に含まれています。

##  <a name="anglearc"></a>  CDC::AngleArc

線分と円弧を描画します。

```
BOOL AngleArc(
    int x,
    int y,
    int nRadius,
    float fStartAngle,
    float fSweepAngle);
```

### <a name="parameters"></a>パラメーター

*x*<br/>
円の中心の x の論理座標を指定します。

*y*<br/>
論理で円の中心の y 座標を指定します。

*nRadius*<br/>
論理ユニットでは、円の半径を指定します。 この値は正である必要があります。

*fStartAngle*<br/>
X 軸からの角度で、開始角度を指定します。

*fSweepAngle*<br/>
開始角度からの角度で掃引角度を指定します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

直線セグメントは、現在の位置から円弧の始点に描画されます。指定した半径と中心の円の境界に沿って、円弧が描画されます。 円弧の長さは、特定の開始および掃引角度によって定義されます。

`AngleArc` 円弧の終点には、現在の位置を移動します。現在の変換およびマッピング モードによっては楕円には、この関数によって描画される円弧が表示されます。 円弧を描画する前に、この関数は、現在の位置から円弧の始点に直線セグメントを描画します。指定した中心点を基準として指定した半径と虚数部の円を作成することによって、円弧が描画されます。 円弧の開始点は、開始角度で度数で、円の x 軸から反時計回りに計測によって決定されます。 掃引角度で度数で開始点から反時計回りに計測して終点に同様にあります。

掃引角度が 360 度より大きい場合、円弧は複数回です。 この関数は、現在のペンを使用して線を描画します。 図が入力されていません。

##  <a name="arc"></a>  CDC::Arc

楕円の円弧を描画します。

```
BOOL Arc(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Arc(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>パラメーター

*x1*<br/>
(論理単位) に外接する四角形の左上隅の x 座標を指定します。

*y1*<br/>
(論理単位) に外接する四角形の左上隅の y 座標を指定します。

*x2*<br/>
(論理単位) に外接する四角形の右上隅の x 座標を指定します。

*y2*<br/>
(論理単位) に外接する四角形の右上隅の y 座標を指定します。

*x3*<br/>
円弧を定義するポイントの x 座標の始点 (論理単位) を指定します。 このポイントは、円弧上正確にする必要はありません。

*y3*<br/>
円弧を定義するポイントの y 座標の始点 (論理単位) を指定します。 このポイントは、円弧上正確にする必要はありません。

*x4*<br/>
(論理単位) での円弧の終点を定義するポイントの x 座標を指定します。 このポイントは、円弧上正確にする必要はありません。

*y4*<br/>
(論理単位) での円弧の終点を定義するポイントの y 座標を指定します。 このポイントは、円弧上正確にする必要はありません。

*lpRect*<br/>
(論理単位) に外接する四角形を指定します。 いずれか、LPRECT を渡すことができます、 [CRect](../../atl-mfc-shared/reference/crect-class.md)このパラメーターのオブジェクト。

*ptStart*<br/>
円弧を定義する点の x 座標と y 座標の始点 (論理単位) を指定します。 このポイントは、円弧上正確にする必要はありません。いずれかを渡すことができます、[ポイント](/windows/desktop/api/windef/ns-windef-tagpoint)構造または[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)このパラメーターのオブジェクト。

*ptEnd*<br/>
(論理単位) で、円弧の終点を定義する点の x 座標と y 座標を指定します。 このポイントは、円弧上正確にする必要はありません。いずれかを渡すことができます、`POINT`構造または`CPoint`このパラメーターのオブジェクト。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

関数を使用して描画された円弧は、指定した外接する四角形によって定義される楕円のセグメントです。

円弧の実際の開始点は、位置指定された開始位置を外接する四角形の中心から描画された射線は楕円と交差するポイントです。 円弧の実際の終了点は、位置指定の終了点を外接する四角形の中心から描画された射線は楕円と交差するポイントです。 円弧が反時計回りの方向に描画されます。 円弧が閉じた図ではないため、これが入力されていません。 四角形の高さと幅は、2 つのユニットと 32,767 より小さい単位より大きくなければなりません。

### <a name="example"></a>例

[!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]

##  <a name="arcto"></a>  CDC::ArcTo

楕円の円弧を描画します。

```
BOOL ArcTo(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL ArcTo(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>パラメーター

*x1*<br/>
(論理単位) に外接する四角形の左上隅の x 座標を指定します。

*y1*<br/>
(論理単位) に外接する四角形の左上隅の y 座標を指定します。

*x2*<br/>
(論理単位) に外接する四角形の右上隅の x 座標を指定します。

*y2*<br/>
(論理単位) に外接する四角形の右上隅の y 座標を指定します。

*x3*<br/>
円弧を定義するポイントの x 座標の始点 (論理単位) を指定します。 このポイントは、円弧上正確にする必要はありません。

*y3*<br/>
円弧を定義するポイントの y 座標の始点 (論理単位) を指定します。 このポイントは、円弧上正確にする必要はありません。

*x4*<br/>
(論理単位) での円弧の終点を定義するポイントの x 座標を指定します。 このポイントは、円弧上正確にする必要はありません。

*y4*<br/>
(論理単位) での円弧の終点を定義するポイントの y 座標を指定します。 このポイントは、円弧上正確にする必要はありません。

*lpRect*<br/>
(論理単位) に外接する四角形を指定します。 ポインターを渡すことができます、 [RECT](/windows/desktop/api/windef/ns-windef-tagrect)データ構造体または[CRect](../../atl-mfc-shared/reference/crect-class.md)このパラメーターのオブジェクト。

*ptStart*<br/>
円弧を定義する点の x 座標と y 座標の始点 (論理単位) を指定します。 このポイントは、円弧上正確にする必要はありません。いずれかを渡すことができます、[ポイント](/windows/desktop/api/windef/ns-windef-tagpoint)データ構造体または[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)このパラメーターのオブジェクト。

*ptEnd*<br/>
(論理単位) で、円弧の終点を定義する点の x 座標と y 座標を指定します。 このポイントは、円弧上正確にする必要はありません。いずれかを渡すことができます、`POINT`データ構造体または`CPoint`このパラメーターのオブジェクト。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

この機能に似ています`CDC::Arc`, 現在の位置が更新される点が異なります。 点 ( *x1*、 *y1*) と ( *x2*、 *y2*) 外接する四角形を指定します。 指定した外接する四角形によって形成される楕円の円弧、曲線を定義します。外接する四角形の中心から放射状の行が交差するポイントから円弧に (既定の円弧の方向) は反時計回り ( *x3*、 *y3*)。 外接する四角形の中心から放射状の行が交差する、円弧の終了 ( *x4*、 *y4*)。 開始点と終点が同じ場合は、完全な楕円を描画します。

行は、現在の位置から円弧の始点に描画されます。エラーが発生しない場合、現在の位置は、円弧の終点に設定されます。現在のペンを使用して、円弧の描画します。これが入力されていません。

##  <a name="attach"></a>  CDC::Attach

このメンバー関数を使用して、アタッチ、 *hDC*を`CDC`オブジェクト。

```
BOOL Attach(HDC hDC);
```

### <a name="parameters"></a>パラメーター

*hDC*<br/>
Windows デバイス コンテキスト。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

*HDC*両方に格納されて`m_hDC`、出力デバイス コンテキスト、および`m_hAttribDC`属性のデバイス コンテキスト。

##  <a name="beginpath"></a>  CDC::BeginPath

デバイス コンテキストでは、パスの角かっこを開きます。

```
BOOL BeginPath();
```

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

パスの角かっこを開いた後、パス内にある点を定義する GDI 描画関数を呼び出すアプリケーションを開始できます。 アプリケーションが呼び出すことによって、パスを開く bracket を閉じることができます、`EndPath`メンバー関数。 アプリケーションを呼び出すと`BeginPath`、前のパスは破棄されます。

参照してください[アプリケーション](/windows/desktop/api/wingdi/nf-wingdi-beginpath)パス ポイントを定義する描画関数の一覧の Windows SDK に含まれています。

### <a name="example"></a>例

[!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]

##  <a name="bitblt"></a>  CDC::BitBlt

現在のデバイス コンテキストを元のデバイス コンテキストからビットマップをコピーします。

```
BOOL BitBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    DWORD dwRop);
```

### <a name="parameters"></a>パラメーター

*x*<br/>
先の四角形の左上隅の x の論理座標を指定します。

*y*<br/>
先の四角形の左上隅の y の論理座標を指定します。

*nWidth*<br/>
コピー先の四角形と元のビットマップの幅を (論理単位) で指定します。

*nHeight*<br/>
コピー先の四角形と元のビットマップの高さを (論理単位) で指定します。

*pSrcDC*<br/>
ポインターを`CDC`ビットマップのコピー元デバイス コンテキストを識別するオブジェクト。 場合は NULL にする必要があります*dwRop*ソースが含まれていないラスター オペレーションを指定します。

*xSrc*<br/>
ソース ビットマップの左上隅の x の論理座標を指定します。

*ySrc*<br/>
ソース ビットマップの左上隅の y の論理座標を指定します。

*dwRop*<br/>
実行するラスター オペレーションを指定します。 ラスター オペレーション コードは、GDI による色、現在のブラシ、転送元のビットマップとコピー先ビットマップに関連する出力操作での結合方法を定義します。 参照してください[BitBlt](/windows/desktop/api/wingdi/nf-wingdi-bitblt)のラスター オペレーション コードの一覧については、Windows sdk *dwRop*とその説明

ラスター オペレーション コードの完全な一覧を参照してください。[ラスター オペレーション コードに関する](/windows/desktop/gdi/raster-operation-codes)Windows SDK に含まれています。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

アプリケーションは、windows またはことを確認するバイト境界上のクライアント領域を揃えることができます、`BitBlt`バイト境界の四角形の操作が行われます。 (設定 CS_BYTEALIGNWINDOW またはによりフラグ ウィンドウ クラスを登録する場合)。

`BitBlt` 四角形のバイト境界での操作がよりかなり速く`BitBlt`はバイトでアラインされる四角形を操作します。 デバイス コンテキストのバイトのアラインメントなどのクラスのスタイルを指定するには、ウィンドウ クラスを登録する必要がありますが行う Microsoft Foundation classes に頼ることがなく。 グローバル関数を使用して[AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)します。

Gdi は*nWidth*と*パラメーター nHeight*コピー先デバイス コンテキストを使用して、1 回、および元のデバイス コンテキストを使用して 1 回です。 GDI は、Windows を使用して、結果として得られるエクステントが一致しない場合`StretchBlt`を圧縮または必要に応じて、元のビットマップを拡大する関数。

変換先、ソース、およびパターン ビットマップは、同じ色の書式を持たない場合、`BitBlt`関数が宛先に一致するソースとパターン ビットマップに変換します。 コピー先のビットマップの前景色と背景色は、変換に使用されます。

ときに、`BitBlt`関数は、モノクロのビットマップをカラーに変換します、白のビット (1) を背景色、前景の色を黒のビット (0) に設定します。 コピー先のデバイス コンテキストの前景色と背景色が使用されます。 カラーをモノクロに変換する`BitBlt`背景色を白に一致するピクセルを設定し、その他のすべてのピクセルを黒に設定します。 `BitBlt` デバイスのカラー コンテキストの前景色と背景色を使用して、色からモノクロに変換します。

すべてのデバイス コンテキストをサポートする注`BitBlt`します。 指定されたデバイス コンテキストはサポートされているかどうかを確認する`BitBlt`を使用して、`GetDeviceCaps`メンバー関数し、RASTERCAPS インデックスを指定します。

### <a name="example"></a>例

  例をご覧ください[CDC::CreateCompatibleDC](#createcompatibledc)します。

##  <a name="cdc"></a>  CDC::CDC

`CDC` オブジェクトを構築します。

```
CDC();
```

##  <a name="chord"></a>  CDC::Chord

コード (楕円と直線セグメントで囲まれる閉じた図) を描画します。

```
BOOL Chord(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Chord(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>パラメーター

*x1*<br/>
コードの左上隅の x 座標の (論理単位) 内の四角形の境界を指定します。

*y1*<br/>
コードの左上隅の y 座標の (論理単位) 内の四角形の境界を指定します。

*x2*<br/>
コードの右下隅の x 座標の (論理単位) 内の四角形の境界を指定します。

*y2*<br/>
コードの右下隅の y 座標の (論理単位) 内の四角形の境界を指定します。

*x3*<br/>
コードを定義するポイントの x 座標の (論理単位) でのポイントの開始を指定します。

*y3*<br/>
コードを定義するポイントの y 座標の (論理単位) でのポイントの開始を指定します。

*x4*<br/>
(論理単位) で弦のエンドポイントを定義するポイントの x 座標を指定します。

*y4*<br/>
(論理単位) で弦のエンドポイントを定義するポイントの y 座標を指定します。

*lpRect*<br/>
(論理単位) に外接する四角形を指定します。 いずれかを LPRECT を渡すことができます、 [CRect](../../atl-mfc-shared/reference/crect-class.md)このパラメーターのオブジェクト。

*ptStart*<br/>
コードを定義するポイントの x 座標と y 座標の始点 (論理単位) を指定します。 このポイントは、コードで正確にあることはありません。 いずれかを渡すことができます、`POINT`構造または`CPoint`このパラメーターのオブジェクト。

*ptEnd*<br/>
(論理単位) でコードの終了点を定義する点の x 座標と y 座標を指定します。 このポイントは、コードで正確にあることはありません。 いずれかを渡すことができます、[ポイント](/windows/desktop/api/windef/ns-windef-tagpoint)構造または[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)このパラメーターのオブジェクト。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

( *X1*、 *y1*) と ( *x2*、 *y2*) パラメーターを指定左および右下隅で、それぞれ、四角形のコードの一部である楕円の境界です。 ( *X3*、 *y3*) と ( *x4*、 *y4*) パラメーターは、省略記号ボタンと交差する行のエンドポイントを指定します。 コードは、選択したペンを使用して描画され、選択したブラシを使用して塗りつぶされます。

描画する図形、`Chord`関数は、まで拡張しますが、右下隅の座標は含まれません。 つまり、図形の高さは*y2* - *y1* figure の幅は*x2* - *x1*します。

### <a name="example"></a>例

[!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]

##  <a name="closefigure"></a>  CDC::CloseFigure

パス内の開いている図を閉じます。

```
BOOL CloseFigure();
```

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

関数は、図の最初のポイントに現在の位置から行を描画することで、図を閉じます (通常は、最新の呼び出しで指定された点、`MoveTo`メンバー関数) し、直線の接合スタイルを使用して線を接続します。 使用して、図が閉じている場合、`LineTo`メンバー関数の代わりに`CloseFigure`終端のキャップを使用して結合ではなく角を作成します。 `CloseFigure` デバイス コンテキストでパスを開くの角かっこがある場合のみ呼び出さ 必要があります。

パスの図は、この関数を使用して明示的に閉じられている場合を除き、開かれています。 (図を開くことができる場合でも、現在のポイントと、図の開始点は同じです。)任意の行または後にパスに追加する曲線`CloseFigure`新しい図形を開始します。

##  <a name="createcompatibledc"></a>  CDC::CreateCompatibleDC

指定されたデバイスと互換性があるメモリ デバイス コンテキストを作成します*pDC*します。

```
BOOL CreateCompatibleDC(CDC* pDC);
```

### <a name="parameters"></a>パラメーター

*pDC*<br/>
デバイス コンテキストへのポインター。 場合*pDC*が null の場合、この関数は、システムの表示と互換性があるメモリ デバイス コンテキストを作成します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

メモリ デバイス コンテキストは、表示サーフェイスを表すメモリのブロックです。 互換性のあるデバイスの実際のデバイスの画面にコピーする前にメモリ内のイメージを準備するために使用します。

メモリ デバイス コンテキストが作成されると、GDI を 1 対 1 でモノクロのストック ビットマップを自動的に選択します。 ビットマップが作成され、そのコンテキストに選択されている場合にのみ、メモリ デバイス コンテキストの GDI 関数を使用できます。

この関数は、ラスター オペレーションをサポートするデバイスの互換性のあるデバイス コンテキストの作成にのみ使用できます。 参照してください、 [cdc::bitblt](#bitblt)デバイス コンテキストの間でビット ブロック転送に関する情報のメンバー関数。 デバイス コンテキストがラスター オペレーションをサポートするかどうかを確認するには、メンバー関数で RC_BITBLT ラスター機能を参照してください。`CDC::GetDeviceCaps`します。

### <a name="example"></a>例

[!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]

##  <a name="createdc"></a>  CDC::CreateDC

指定したデバイスのデバイス コンテキストを作成します。

```
BOOL CreateDC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>パラメーター

*lpszDriverName*<br/>
デバイス ドライバー (たとえば、"EPSON") のファイル名 (拡張子なし) を指定する null で終わる文字列へのポインター。 渡すことも、`CString`このパラメーターのオブジェクト。

*lpszDeviceName*<br/>
(たとえば、「EPSON FX 80」) をサポートするのには、特定のデバイスの名前を指定する null で終わる文字列へのポインター。 *LpszDeviceName*モジュールは、1 つ以上のデバイスをサポートしている場合、パラメーターを使用します。 渡すことも、`CString`このパラメーターのオブジェクト。

*lpszOutput*<br/>
出力の物理メディア (ファイルまたは出力ポート) のファイルまたはデバイス名を指定する null で終わる文字列へのポインター。 渡すことも、`CString`このパラメーターのオブジェクト。

*lpInitData*<br/>
指す、`DEVMODE`デバイス ドライバーのデバイス固有の初期化データを含む構造体。 Windows`DocumentProperties`関数は、特定のデバイスに入力します。 この構造体を取得します。 *いるとき*パラメーターは、デバイス ドライバーは、コントロール パネルからユーザーが指定した既定の初期化 (ある場合) を使用する場合に、NULL にする必要があります。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

印刷します。H ヘッダー ファイルが必要、 [DEVMODE](/windows/desktop/api/wingdi/ns-wingdi-_devicemodea)構造体を使用します。

デバイス名がこれらの規則に従ってください。 コロン (:) が、推奨されるが、省略可能。 Windows は、コロンで終わるデバイス名がコロンのない同じ名前と同じポートにマップされるように、終端のコロンを削除します。 ドライバおよびポートの名前は、先頭または末尾のスペースを含めることはできません。 GDI 関数は、情報のコンテキストでは使用できません。

##  <a name="createic"></a>  CDC::CreateIC

指定したデバイスの情報コンテキストを作成します。

```
BOOL CreateIC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>パラメーター

*lpszDriverName*<br/>
デバイス ドライバー (たとえば、"EPSON") のファイル名 (拡張子なし) を指定する null で終わる文字列へのポインター。 渡すことができます、`CString`このパラメーターのオブジェクト。

*lpszDeviceName*<br/>
(たとえば、「EPSON FX 80」) をサポートするのには、特定のデバイスの名前を指定する null で終わる文字列へのポインター。 *LpszDeviceName*モジュールは、1 つ以上のデバイスをサポートしている場合、パラメーターを使用します。 渡すことができます、`CString`このパラメーターのオブジェクト。

*lpszOutput*<br/>
(ファイルまたはポート) は、物理出力メディアのファイルまたはデバイス名を指定する null で終わる文字列へのポインター。 渡すことができます、`CString`このパラメーターのオブジェクト。

*lpInitData*<br/>
デバイス ドライバーのデバイス固有の初期化データを指します。 *いるとき*パラメーターは、デバイス ドライバーは、コントロール パネルからユーザーが指定した既定の初期化 (ある場合) を使用する場合に、NULL にする必要があります。 参照してください`CreateDC`デバイス固有の初期化のデータ形式。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

情報のコンテキストでは、高速デバイス コンテキストを作成することがなく、デバイスに関する情報を取得する方法を提供します。

デバイス名がこれらの規則に従ってください。 コロン (:) が、推奨されるが、省略可能。 Windows は、コロンで終わるデバイス名がコロンのない同じ名前と同じポートにマップされるように、終端のコロンを削除します。 ドライバおよびポートの名前は、先頭または末尾のスペースを含めることはできません。 GDI 関数は、情報のコンテキストでは使用できません。

##  <a name="deletedc"></a>  CDC::DeleteDC

一般に、この関数を呼び出していません。デストラクターは、処理を実行します。

```
BOOL DeleteDC();
```

### <a name="return-value"></a>戻り値

関数が正常に完了した場合、0 以外の場合それ以外の場合 0 を返します。

### <a name="remarks"></a>Remarks

`DeleteDC`メンバー関数は、関連付けられている Windows デバイス コンテキストを削除します。 `m_hDC` 、現在の`CDC`オブジェクト。 この場合`CDC`オブジェクトが特定のデバイスの最後のアクティブなデバイス コンテキストはデバイスに通知され、デバイスによって使用されるすべての記憶域とシステム リソースが解放されます。

アプリケーションは呼び出さないでください`DeleteDC`デバイス コンテキストにオブジェクトが選択されている場合。 削除される前に、オブジェクトはまず、デバイス コンテキスト外選択する必要があります。

アプリケーションがハンドルを呼び出すことによって取得したデバイス コンテキストを削除する必要があります[cwnd::getdc](../../mfc/reference/cwnd-class.md#getdc)します。 代わりに、呼び出す必要があります[cwnd::releasedc](../../mfc/reference/cwnd-class.md#releasedc)をデバイス コンテキストを解放します。 [CClientDC](../../mfc/reference/cclientdc-class.md)と[CWindowDC](../../mfc/reference/cwindowdc-class.md)この機能をラップするクラスが用意されています。

`DeleteDC`で作成したデバイス コンテキストを削除する関数が使用される通常[フォーマット](#createdc)、 [CreateIC](#createic)、または[CreateCompatibleDC](#createcompatibledc)します。

### <a name="example"></a>例

  例をご覧ください[CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc)します。

##  <a name="deletetempmap"></a>  CDC::DeleteTempMap

によって自動的に呼び出されます、`CWinApp`アイドル処理ハンドラー、`DeleteTempMap`一時を削除します`CDC`によって作成されたオブジェクト`FromHandle`、が、デバイス コンテキスト ハンドルを破棄しません ( `hDC`s)、に一時的に関連付けられている。`CDC`オブジェクト。

```
static void PASCAL DeleteTempMap();
```

##  <a name="detach"></a>  CDC::Detach

デタッチするには、この関数を呼び出す`m_hDC`(出力デバイス コンテキスト) から、`CDC`オブジェクトし、両方を設定`m_hDC`と`m_hAttribDC`を NULL にします。

```
HDC Detach();
```

### <a name="return-value"></a>戻り値

Windows デバイス コンテキスト。

##  <a name="dptohimetric"></a>  CDC::DPtoHIMETRIC

HIMETRIC ピクセルに変換する ole に HIMETRIC のサイズを指定すると、この関数を使用します。

```
void DPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>パラメーター

*lpSize*<br/>
指す、[サイズ](/windows/desktop/api/windef/ns-windef-tagsize)構造または[CSize](../../atl-mfc-shared/reference/csize-class.md)オブジェクト。

### <a name="remarks"></a>Remarks

デバイス コンテキスト オブジェクトのマッピング モードが MM_LOENGLISH、MM_HIENGLISH、MM_LOMETRIC、または MM_HIMETRIC の場合は、インチの物理ピクセルの数に変換がベースします。 マッピング モードが他の非強制モード (MM_TEXT) のいずれかの場合は、論理インチのピクセルの数に変換がベースします。

##  <a name="dptolp"></a>  CDC::DPtoLP

デバイス単位を論理単位に変換します。

```
void DPtoLP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>パラメーター

*lpPoints*<br/>
配列を指す[ポイント](/windows/desktop/api/windef/ns-windef-tagpoint)構造体または[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)オブジェクト。

*nCount*<br/>
配列内の地点の数。

*lpRect*<br/>
指す、 [RECT](/windows/desktop/api/windef/ns-windef-tagrect)構造または[CRect](../../atl-mfc-shared/reference/crect-class.md)オブジェクト。 デバイスのポイントから論理ポイントに 1 つの四角形を変換する単純なケースでは、このパラメーターは使用されます。

*lpSize*<br/>
指す、[サイズ](/windows/desktop/api/windef/ns-windef-tagsize)構造または[CSize](../../atl-mfc-shared/reference/csize-class.md)オブジェクト。

### <a name="remarks"></a>Remarks

関数は、各ポイントの座標または GDI の論理座標システムにデバイスの座標系から、サイズのディメンションにマップします。 変換は、現在のマッピング モードと、生成元とデバイスのウィンドウ、ビューポートのエクステントの設定に依存します。

##  <a name="draw3drect"></a>  CDC::Draw3dRect

3 次元の四角形を描画するには、このメンバー関数を呼び出します。

```
void Draw3dRect(
    LPCRECT lpRect,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);

void Draw3dRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);
```

### <a name="parameters"></a>パラメーター

*lpRect*<br/>
(論理単位) に外接する四角形を指定します。 ポインターを渡すことができます、 [RECT](/windows/desktop/api/windef/ns-windef-tagrect)構造または[CRect](../../atl-mfc-shared/reference/crect-class.md)このパラメーターのオブジェクト。

*clrTopLeft*<br/>
3 次元の四角形の上および左の辺の色を指定します。

*clrBottomRight*<br/>
下部の色と 3 次元の四角形の右辺を指定します。

*x*<br/>
3 次元の四角形の左上隅の x の論理座標を指定します。

*y*<br/>
論理で 3 次元の四角形の左上隅の y 座標を指定します。

*cx*<br/>
3 次元の四角形の幅を指定します。

*cy*<br/>
3 次元の四角形の高さを指定します。

### <a name="remarks"></a>Remarks

指定された色の上および左の方向の四角形が描画されます*clrTopLeft*下部と右辺で指定された色で*clrBottomRight*します。

### <a name="example"></a>例

[!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]

##  <a name="drawdragrect"></a>  CDC::DrawDragRect

ドラッグ四角形を再描画するには、繰り返しには、このメンバー関数を呼び出します。

```
void DrawDragRect(
    LPCRECT lpRect,
    SIZE size,
    LPCRECT lpRectLast,
    SIZE sizeLast,
    CBrush* pBrush = NULL,
    CBrush* pBrushLast = NULL);
```

### <a name="parameters"></a>パラメーター

*lpRect*<br/>
指す、 [RECT](/windows/desktop/api/windef/ns-windef-tagrect)構造または[CRect](../../atl-mfc-shared/reference/crect-class.md)四角形の論理座標を指定するオブジェクト: この場合、再描画される四角形の終了位置。

*size*<br/>
外側の境界線の四角形の内側の境界線 (つまり、境界線の太さなど) の左上隅を左上隅から移動距離を指定します。

*lpRectLast*<br/>
指す、 [RECT](/windows/desktop/api/windef/ns-windef-tagrect)構造または[CRect](../../atl-mfc-shared/reference/crect-class.md)四角形の位置の論理座標を指定するオブジェクト: この場合、再描画される四角形の元の位置。

*sizeLast*<br/>
外側の境界線の再描画される元の四角形の内側の境界線 (つまり、境界線の太さなど) の左上隅に左上隅から移動距離を指定します。

*pBrush*<br/>
ブラシ オブジェクトへのポインター。 既定のハーフトーン ブラシを使用する、NULL に設定します。

*pBrushLast*<br/>
最後に使用されるブラシ オブジェクトへのポインター。 既定のハーフトーン ブラシを使用する、NULL に設定します。

### <a name="remarks"></a>Remarks

マウスの位置を視覚的なフィードバックを提供するためにサンプリングするには、ループ内で呼び出します。 呼び出すと`DrawDragRect`、前の四角形が削除され、新しいものを描画します。 たとえば、ユーザーとして、画面上で四角形をドラッグ`DrawDragRect`元の四角形を消去して、新しい位置に新しいものを再描画されます。 既定では、`DrawDragRect`ハーフトーン ブラシを使用してちらつきをスムーズに移動の四角形の外観を作成する、四角形を描画します。

初めて呼び出す`DrawDragRect`、 *lpRectLast*パラメーターは NULL になります。

##  <a name="drawedge"></a>  CDC::DrawEdge

指定した型とスタイルの四角形の端を描画するには、このメンバー関数を呼び出します。

```
BOOL DrawEdge(
    LPRECT lpRect,
    UINT nEdge,
    UINT nFlags);
```

### <a name="parameters"></a>パラメーター

*lpRect*<br/>
ポインター、`RECT`四角形の論理座標を含む構造体。

*nEdge*<br/>
描画するために、内側と外側のエッジの種類を指定します。 このパラメーターは、フラグを 1 つの罫線の内側と外側の境界線の 1 つのフラグの組み合わせを指定する必要があります。 参照してください[DrawEdge](/windows/desktop/api/winuser/nf-winuser-drawedge)パラメーターの型のテーブルの Windows SDK に含まれています。

*nFlags*<br/>
描画される境界線の種類を指定するフラグ。 参照してください`DrawEdge`パラメーターの値の一覧については、Windows SDK に含まれています。 対角線 BF_RECT フラグは四角形のパラメーターで範囲指定されたベクターの終点を指定します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

##  <a name="drawescape"></a>  CDC::DrawEscape

描画は、グラフィックス デバイス インターフェイス (GDI) から直接使用できないビデオ ディスプレイの機能にアクセスします。

```
int DrawEscape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData);
```

### <a name="parameters"></a>パラメーター

*nEscape*<br/>
実行するエスケープ関数を指定します。

*nInputSize*<br/>
参照するデータのバイト数を指定します、 *lpszInputData*パラメーター。

*lpszInputData*<br/>
指定したエスケープの必要な入力構造体を指します。

### <a name="return-value"></a>戻り値

関数の結果を指定します。 実装のみをチェックする関数の描画エスケープを除き、成功した場合は 0 より大きいまたは 0 の場合は、エスケープが実装されていません。または、ゼロより小さい場合はエラーが発生しました。

### <a name="remarks"></a>Remarks

アプリケーションを呼び出すと`DrawEscape`で識別されるデータ*nInputSize*と*lpszInputData*指定のディスプレイ ドライバーに直接渡されます。

##  <a name="drawfocusrect"></a>  CDC::DrawFocusRect

四角形にフォーカスがあることを示すために使用するスタイルでは、四角形を描画します。

```
void DrawFocusRect(LPCRECT lpRect);
```

### <a name="parameters"></a>パラメーター

*lpRect*<br/>
指す、 [RECT](/windows/desktop/api/windef/ns-windef-tagrect)構造または[CRect](../../atl-mfc-shared/reference/crect-class.md)オブジェクトを描画する四角形の論理座標を指定します。

### <a name="remarks"></a>Remarks

これは、ブール型 XOR 関数であるためには、表示から、四角形を削除する同じ四角形を 2 回目に、この関数を呼び出します。 この関数によって描画される四角形をスクロールすることはできません。 この関数によって描画される四角形を含む領域をスクロールするには、まず呼び出す`DrawFocusRect`四角形の表示からを削除する、領域をスクロールしを呼び出して`DrawFocusRect`新しい位置に、四角形を描画するためにもう一度です。

> [!CAUTION]
> `DrawFocusRect` MM_TEXT モードでのみ動作します。 他のモードでは、この関数がフォーカスされた四角形を正しく描画できませんが、エラー値を返すことはできません。

##  <a name="drawframecontrol"></a>  CDC::DrawFrameControl

指定した型とスタイルのフレームのコントロールを描画するには、このメンバー関数を呼び出します。

```
BOOL DrawFrameControl(
    LPRECT lpRect,
    UINT nType,
    UINT nState);
```

### <a name="parameters"></a>パラメーター

*lpRect*<br/>
ポインター、`RECT`四角形の論理座標を含む構造体。

*nType*<br/>
描画するフレーム コントロールの種類を指定します。 参照してください、 *uType*パラメーター [DrawFrameControl](/windows/desktop/api/winuser/nf-winuser-drawframecontrol)このパラメーターの使用可能な値の一覧については、Windows sdk。

*nState*<br/>
Frame コントロールの初期状態を指定します。 説明されている値の 1 つ以上を指定することができます、 *uState*パラメーター `DrawFrameControl` Windows sdk。 使用して、*状態*DFCS_ADJUSTRECT プッシュ ボタンの周囲の端を除外する外接する四角形を調整する値します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

いくつかのケースで*状態*によって異なります、 *%n タイプ*パラメーター。 次の一覧は、4 つの間のリレーションシップを示しています *%n タイプ*値と*状態*:。

- DFC_BUTTON

    - DFCS_BUTTON3STATE 3 つの状態のボタン

    - DFCS_BUTTONCHECK チェック ボックス

    - DFCS_BUTTONPUSH プッシュ ボタン

    - DFCS_BUTTONRADIO ラジオ ボタン

    - ラジオ ボタンの DFCS_BUTTONRADIOIMAGE イメージ (非正方形には、イメージが必要です)

    - ラジオ ボタンの DFCS_BUTTONRADIOMASK マスク (非正方形には、マスクが必要です)

- DFC_CAPTION

    - DFCS_CAPTIONCLOSE 閉じるボタン

    - DFCS_CAPTIONHELP ヘルプ ボタン

    - DFCS_CAPTIONMAX を最大化ボタン

    - DFCS_CAPTIONMIN が最小化 ボタン

    - DFCS_CAPTIONRESTORE の復元 ボタン

- DFC_MENU

    - DFCS_MENUARROW サブメニューの矢印

    - DFCS_MENUBULLET 行頭文字

    - DFCS_MENUCHECK のチェック マーク

- DFC_SCROLL

    - DFCS_SCROLLCOMBOBOX コンボ ボックスのスクロール バー

    - DFCS_SCROLLDOWN 下方向のスクロール バー

    - スクロール バーの DFCS_SCROLLLEFT 左矢印

    - スクロール バーの DFCS_SCROLLRIGHT 右矢印

    - ウィンドウの右下隅の DFCS_SCROLLSIZEGRIP サイズ変更グリップ

    - スクロール バーの DFCS_SCROLLUP 上矢印

### <a name="example"></a>例

このコードは、ウィンドウの右下隅でサイズ変更グリップを描画します。 適切である、`OnPaint`のスタイルを持たず、通常は、サイズ変更グリップを付けますが (ステータス バー) のようなその他のコントロールを含まない ダイアログ ボックスのハンドラー。

[!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]

##  <a name="drawicon"></a>  CDC::DrawIcon

現在によって表されるデバイスにアイコンを描画`CDC`オブジェクト。

```
BOOL DrawIcon(
    int x,
    int y,
    HICON hIcon);

BOOL DrawIcon(
    POINT point,
    HICON hIcon);
```

### <a name="parameters"></a>パラメーター

*x*<br/>
論理でアイコンの左上隅の x 座標を指定します。

*y*<br/>
論理でアイコンの左上隅の y 座標を指定します。

*hIcon*<br/>
描画するアイコンのハンドルを識別します。

*ポイント*<br/>
アイコンの左上隅の論理 x 座標と y 座標を指定します。 渡すことができます、[ポイント](/windows/desktop/api/windef/ns-windef-tagpoint)構造または[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)このパラメーターのオブジェクト。

### <a name="return-value"></a>戻り値

関数が正常に完了した場合、0 以外の場合それ以外の場合 0 を返します。

### <a name="remarks"></a>Remarks

関数で指定された場所にあるアイコンの左上隅に配置*x*と*y*します。 場所は、デバイス コンテキストの現在のマップ モードの対象です。

アイコン リソースする必要がありますが既に読み込まれている関数を使用して`CWinApp::LoadIcon`、 `CWinApp::LoadStandardIcon`、または`CWinApp::LoadOEMIcon`します。 `MM_TEXT`マッピング モードは、この関数を使用する前に選択する必要があります。

### <a name="example"></a>例

  例をご覧ください[CWnd::IsIconic](../../mfc/reference/cwnd-class.md#isiconic)します。

##  <a name="drawstate"></a>  CDC::DrawState

イメージを表示し、無効ななどの状態または既定の状態を示す視覚効果を適用するには、このメンバー関数を呼び出します。

> [!NOTE]
>  すべての*指します*DSS_NORMAL、以外を示す視覚効果が適用される前に画像が白黒に変換されます。

```
BOOL DrawState(
    CPoint pt,
    CSize size,
    HBITMAP hBitmap,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    CBitmap* pBitmap,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    CBrush* pBrush = NULL);
```

### <a name="parameters"></a>パラメーター

*pt*<br/>
イメージの場所を指定します。

*size*<br/>
イメージのサイズを指定します。

*hBitmap*<br/>
ビットマップへのハンドル。

*nFlags*<br/>
イメージの種類と状態を指定するフラグ。 参照してください[DrawState](/windows/desktop/api/winuser/nf-winuser-drawstatea) 、可能性があるのため、Windows sdk *nFlags*の種類と状態。

*hBrush*<br/>
ブラシへのハンドル。

*pBitmap*<br/>
CBitmap オブジェクトへのポインター。

*pBrush*<br/>
CBrush オブジェクトへのポインター。

*hIcon*<br/>
アイコンにへのハンドル。

*lpszText*<br/>
テキストへのポインター。

*bPrefixText*<br/>
アクセラレータのアクセラレータ キーを含む可能性のあるテキストです。 *LData*パラメーターは、文字列のアドレスを指定し、 *nTextLen*パラメーターが長さを指定します。 場合*nTextLen*が 0 の場合、文字列は null で終わると見なされます。

*nTextLen*<br/>
によって示されるテキスト文字列の長さ*lpszText*します。 場合*nTextLen*が 0 の場合、文字列は null で終わると見なされます。

*lpDrawProc*<br/>
イメージを表示するために使用するコールバック関数へのポインター。 イメージを入力する場合は、このパラメーターは必要*nFlags* DST_COMPLEX です。 省略可能で、イメージの種類が DST_TEXT 場合は NULL にすることができます。 他のすべての種類のイメージでは、このパラメーターは無視されます。 コールバック関数の詳細については、次を参照してください。、 [DrawStateProc](/windows/desktop/api/winuser/nc-winuser-drawstateproc) Windows SDK 内の関数。

*lData*<br/>
イメージに関する情報を指定します。 このパラメーターの意味は、イメージの種類によって異なります。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

##  <a name="drawtext"></a>  CDC::DrawText

指定した四角形内のテキストを書式設定するには、このメンバー関数を呼び出します。 追加の書式設定オプションを指定するには使用[には](#drawtextex)します。

```
virtual int DrawText(
    LPCTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat);

int DrawText(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat);
```

### <a name="parameters"></a>パラメーター

*lpszString*<br/>
描画する文字列を指します。 場合*nCount* -1 で、null で終わる文字列がある必要があります。

*nCount*<br/>
文字列の文字数を指定します。 場合*nCount*は-1、 *lpszString* null で終わる文字列への long ポインターと見なされますと`DrawText`文字数を自動的に計算します。

*lpRect*<br/>
指す、 [RECT](/windows/desktop/api/windef/ns-windef-tagrect)構造または[CRect](../../atl-mfc-shared/reference/crect-class.md)テキストの書式設定 (論理座標) の四角形を格納しているオブジェクト。

*str*<br/>
A [CString](../../atl-mfc-shared/reference/cstringt-class.md)を描画する指定された文字を含むオブジェクト。

*nFormat*<br/>
テキストの書式設定の方法を指定します。 説明されている値の任意の組み合わせであることができます、 *uFormat*パラメーター [DrawText](/windows/desktop/api/winuser/nf-winuser-drawtext) Windows SDK にします。 (結合のビットごとの OR 演算子を使用して)。

> [!NOTE]
>  いくつか*uFormat*フラグの組み合わせが発生する、渡された文字列を変更することができます。 使用する DT_MODIFYSTRING DT_END_ELLIPSIS または DT_PATH_ELLIPSIS のいずれかであります変更するには、文字列ではアサーションを原因と、`CString`をオーバーライドします。 DT_CALCRECT、DT_EXTERNALLEADING、DT_INTERNAL、DT_NOCLIP、および DT_NOPREFIX 値は、DT_TABSTOP 値では使用できません。

### <a name="return-value"></a>戻り値

関数が成功した場合は、テキストの高さ。

### <a name="remarks"></a>Remarks

テキストを書式設定には、左、右、テキストの配置に適切なスペース、または特定の四角形の中心にタブを展開し、テキストを指定した四角形内に収まる行に分割します。 書式の種類がで指定された*フォーマット*します。

このメンバー関数では、デバイス コンテキストの選択したフォント、テキストの色と背景色を使用して、テキストを描画します。 DT_NOCLIP 形式を使用すると、しない限り、`DrawText`テキストが指定した四角形の外側に表示されないように、テキストをクリップします。 すべての書式設定に DT_SINGLELINE 形式を指定しない限り、複数の行があると見なされます。

指定した四角形に対して選択したフォントが大きすぎる場合、`DrawText`メンバー関数は小さいフォント置換しようとはしません。

四角形がで指定された DT_CALCRECT フラグが指定されている場合*lpRect*幅とテキストを描画するために必要な高さを反映するように更新されます。

TA_UPDATECP テキストの配置のフラグが設定されているかどうか (を参照してください[CDC::SetTextAlign](#settextalign))、`DrawText`から指定した四角形の左にあるではなく、現在の位置でテキストが表示されます。 `DrawText` テキストは折り返されません TA_UPDATECP フラグが設定されている場合 (つまり、DT_WORDBREAK フラグ効果はありません)。

テキストの色によって設定される[CDC::SetTextColor](#settextcolor)します。

##  <a name="drawtextex"></a>  CDC::DrawTextEx

指定した四角形内のテキストの書式を設定します。

```
virtual int DrawTextEx(
    LPTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

int DrawTextEx(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```

### <a name="parameters"></a>パラメーター

*lpszString*<br/>
描画する文字列を指します。 場合*nCount* -1 で、文字列は null 終端である必要があります。

*nCount*<br/>
文字列の文字数を指定します。 場合*nCount*は-1、 *lpszString* null で終わる文字列への long ポインターと見なされますと`DrawText`文字数を自動的に計算します。

*lpRect*<br/>
指す、 [RECT](/windows/desktop/api/windef/ns-windef-tagrect)構造または[CRect](../../atl-mfc-shared/reference/crect-class.md)テキストの書式設定 (論理座標) の四角形を格納しているオブジェクト。

*str*<br/>
A [CString](../../atl-mfc-shared/reference/cstringt-class.md)を描画する指定された文字を含むオブジェクト。

*nFormat*<br/>
テキストの書式設定の方法を指定します。 説明されている値の任意の組み合わせであることができます、 *uFormat*パラメーター [DrawText](/windows/desktop/api/winuser/nf-winuser-drawtext) Windows SDK にします。 (ビット演算を使用して結合**または**演算子)。

> [!NOTE]
>  いくつか*uFormat*フラグの組み合わせが発生する、渡された文字列を変更することができます。 使用する DT_MODIFYSTRING DT_END_ELLIPSIS または DT_PATH_ELLIPSIS のいずれかであります変更するには、文字列ではアサーションを原因と、`CString`をオーバーライドします。 DT_CALCRECT、DT_EXTERNALLEADING、DT_INTERNAL、DT_NOCLIP、および DT_NOPREFIX 値は、DT_TABSTOP 値では使用できません。

*lpDTParams*<br/>
ポインターを[DRAWTEXTPARAMS](/windows/desktop/api/winuser/ns-winuser-tagdrawtextparams)オプションの追加の書式設定を指定する構造体。 このパラメーターは、NULL を指定できます。

### <a name="remarks"></a>Remarks

テキストを書式設定には、左、右、テキストの配置に適切なスペース、または特定の四角形の中心にタブを展開し、テキストを指定した四角形内に収まる行に分割します。 書式の種類がで指定された*フォーマット*と*lpDTParams*します。 詳細については、次を参照してください。 [CDC::DrawText](#drawtext)と[DrawTextEx](/windows/desktop/api/winuser/nf-winuser-drawtextexa) Windows SDK に含まれています。

テキストの色によって設定される[CDC::SetTextColor](#settextcolor)します。

##  <a name="ellipse"></a>  CDC::Ellipse

楕円を描きます。

```
BOOL Ellipse(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Ellipse(LPCRECT lpRect);
```

### <a name="parameters"></a>パラメーター

*x1*<br/>
楕円の外接する四角形の左上隅の x の論理座標を指定します。

*y1*<br/>
楕円の外接する四角形の左上隅の y の論理座標を指定します。

*x2*<br/>
楕円の外接する四角形の右上隅の x の論理座標を指定します。

*y2*<br/>
楕円の外接する四角形の右上隅の y の論理座標を指定します。

*lpRect*<br/>
楕円の外接する四角形を指定します。 渡すことも、 [CRect](../../atl-mfc-shared/reference/crect-class.md)このパラメーターのオブジェクト。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

楕円の中心で指定された外接する四角形の中心*x1*、 *y1*、 *x2*、および*y2*、または*lpRect*します。 楕円の描画に使用、現在のペンとその内部が現在のブラシで塗りつぶされます。

この関数で描画する図形、まで拡張は含まれません、右下隅の座標。 つまり、図形の高さは*y2* - *y1* figure の幅は*x2* - *x1*します。

外接する四角形の高さまたは幅のいずれかが 0 の場合は、楕円は描画されません。

##  <a name="enddoc"></a>  CDC::EndDoc

呼び出しによって開始された印刷ジョブの終了、 [StartDoc](#startdoc)メンバー関数。

```
int EndDoc();
```

### <a name="return-value"></a>戻り値

以上の値を関数が成功した場合は 0 または負の値を使用している場合、エラーが発生しました。

### <a name="remarks"></a>Remarks

このメンバー関数は、ENDDOC のプリンター エスケープを置換し、成功した印刷ジョブの完了直後に呼び出す必要があります。

いずれかを使用して、操作を終了する、読み取ろうとしないで、アプリケーションには、印刷のミスや印刷操作の中止が発生すると、`EndDoc`または[AbortDoc](#abortdoc)します。 GDI は、エラー値を返す前に、操作を自動的に終了します。

メタファイル内で、この関数を使用しない必要があります。

### <a name="example"></a>例

  例をご覧ください[CDC::StartDoc](#startdoc)します。

##  <a name="endpage"></a>  CDC::EndPage

アプリケーションのページへの書き込みが完了したことをデバイスに伝えます。

```
int EndPage();
```

### <a name="return-value"></a>戻り値

以上の値を関数が成功した場合は 0 または負の値を使用している場合、エラーが発生しました。

### <a name="remarks"></a>Remarks

このメンバー関数は通常に新しいページに進み、デバイス ドライバーを直接に使用されます。

このメンバー関数は、NEWFRAME のプリンター エスケープを置き換えます。 NEWFRAME とは異なり、ページの印刷後にこの関数は常に呼び出されます。

### <a name="example"></a>例

  例をご覧ください[CDC::StartDoc](#startdoc)します。

##  <a name="endpath"></a>  CDC::EndPath

パスの角かっこを終了し、デバイス コンテキストに、角かっこで定義されているパスを選択します。

```
BOOL EndPath();
```

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="example"></a>例

  例をご覧ください[cdc::beginpath](#beginpath)します。

##  <a name="enumobjects"></a>  CDC::EnumObjects

ペンを列挙し、デバイス コンテキストで使用できるブラシします。

```
int EnumObjects(
    int nObjectType,
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),
    LPARAM lpData);
```

### <a name="parameters"></a>パラメーター

*nObjectType*<br/>
オブジェクトの種類を指定します。 OBJ_BRUSH または OBJ_PEN 値ことができます。

*lpfn*<br/>
アプリケーションによって提供されるコールバック関数のプロシージャ インスタンスのアドレスです。 以下の「解説」セクションを参照してください。

*lpData*<br/>
アプリケーションによって提供されるデータへのポインター。 データは、オブジェクトの情報と共に、コールバック関数に渡されます。

### <a name="return-value"></a>戻り値

によって返される最後の値を指定します、[コールバック関数](callback-functions-used-by-mfc.md#enum_objects)します。 その意味では、ユーザーが定義されます。

### <a name="remarks"></a>Remarks

指定された型のオブジェクトごとに、そのオブジェクトの情報を渡すコールバック関数が呼び出されます。 システムより上にオブジェクトがあるか、コールバック関数は 0 を返すまで、コールバック関数を呼び出します。

Microsoft Visual C の新機能に渡される関数としては、通常の関数を使用することに注意してください。`EnumObjects`します。 渡されるアドレス`EnumObjects`と共にエクスポートされる関数へのポインターは、**エクスポート**Pascal 呼び出し規則を使用して。 保護モードのアプリケーションでは Windows MakeProcInstance 関数を使用したこの関数を作成または使用 FreeProcInstance Windows 関数を使用した後に、関数を解放する必要はありません。

する必要はありませんで関数名のエクスポート、**エクスポート**アプリケーションのモジュール定義ファイル内のステートメント。 代わりに使用することができます、**エクスポート**としての関数の修飾子

**コールバックがエクスポート int**関数 **(LPSTR**、 **LPSTR)。**

エイリアスなしの名前でエクスポートするための適切なエクスポート レコードを生成するコンパイラは、します。 これは、ほとんどのニーズに対して機能します。 序数またはエイリアス、関数のエクスポートなど、いくつかの特殊なケースにする必要がありますを使用して、**エクスポート**モジュール定義ファイル内のステートメント。

Microsoft Foundation プログラムをコンパイルするのには、通常、/GA と/GEs コンパイラ オプションを使用するは。 /Gw コンパイラ オプションは、Microsoft Foundation classes では使用されません。 (Windows 関数を使用する場合`MakeProcInstance`、FARPROC からこの API で必要な型への返された関数ポインターを明示的にキャストする必要があります)。コールバックの登録インターフェイスがタイプ セーフではようになりました (特定のコールバック関数の適切な種類を指す関数ポインターに渡す必要があります)。

また、すべてのコールバック関数がコールバックの境界を越えて例外をスローすることはできませんので、Windows に戻る前に Microsoft Foundation 例外をトラップする必要がありますに注意してください。 例外の詳細については、記事を参照してください。[例外](../../mfc/exception-handling-in-mfc.md)します。

### <a name="example"></a>例

[!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]

##  <a name="escape"></a>  CDC::Escape

このメンバー関数は、Win32 プログラミングのために残さです。

```
virtual int Escape(
    int nEscape,
    int nCount,
    LPCSTR lpszInData,
    LPVOID lpOutData);

int Escape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData,
    int nOutputSize,
    LPSTR lpszOutputData);
```

### <a name="parameters"></a>パラメーター

*nEscape*<br/>
実行するエスケープ関数を指定します。

エスケープの関数の完全な一覧を参照してください。[エスケープ](/windows/desktop/api/wingdi/nf-wingdi-escape)Windows SDK に含まれています。

*nCount*<br/>
参照するデータのバイト数を指定します*lpszInData*します。

*lpszInData*<br/>
このエスケープの必要な入力データ構造体を指します。

*lpOutData*<br/>
このエスケープから出力を受け取る構造体をポイントします。 *れないとき*データが返されない場合、パラメーターが NULL です。

*nInputSize*<br/>
参照するデータのバイト数を指定します、 *lpszInputData*パラメーター。

*lpszInputData*<br/>
指定したエスケープの必要な入力構造体を指します。

*nOutputSize*<br/>
参照するデータのバイト数を指定します、 *lpszOutputData*パラメーター。

*lpszOutputData*<br/>
このエスケープから出力を受け取る構造体を指します。 データが返されない場合、このパラメーターは NULL を指定する必要があります。

### <a name="return-value"></a>戻り値

関数が成功すると、実装の関数エスケープ以外の場合は、正の値が返されます。 エスケープが実装されていない場合は、0 が返されます。 エラーが発生した場合は、負の値が返されます。 次に、一般的なエラー値を示します。

- SP_ERROR の一般的なエラー。

- させることでよりいない十分なディスク領域がスプールされている、現在使用できると、空き領域が使用可能になります。

- SP_OUTOFMEMORY いない十分なメモリがスプールのために使用できます。

- SP_USERABORT ユーザーには、プリント マネージャーを使って、ジョブが終了しました。

### <a name="remarks"></a>Remarks

元のプリンター エスケープの Win32 アプリケーションの関数のみがサポートされています。 その他のすべてのプリンター エスケープが廃止され、16 ビット アプリケーションとの互換性についてのみサポートされます。

Win32 プログラミング、`CDC`これで、対応するプリンター エスケープよりも優先される 6 つのメンバー関数を提供します。

- [CDC::AbortDoc](#abortdoc)

- [CDC::EndDoc](#enddoc)

- [CDC::EndPage](#endpage)

- [CDC::SetAbortProc](#setabortproc)

- [CDC::StartDoc](#startdoc)

- [CDC::StartPage](#startpage)

さらに、[は](#getdevicecaps)は他のプリンター エスケープよりも優先される Win32 インデックスをサポートします。 参照してください[調べるため](/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps)詳細については、Windows SDK に含まれています。

このメンバー関数は、アプリケーションは GDI を介して直接利用できない特定のデバイスの機能にアクセスできます。

アプリケーションは、定義済みのエスケープ値を使用する場合は、最初のバージョンを使用します。 アプリケーションが独自のエスケープ値を定義している場合は、2 番目のバージョンを使用します。 参照してください[ExtEscape](/windows/desktop/api/wingdi/nf-wingdi-extescape) 2 番目のバージョンの詳細については、Windows SDK に含まれています。

##  <a name="excludecliprect"></a>  CDC::ExcludeClipRect

指定した四角形から既存のクリッピング領域で構成される新しいクリップ領域を作成します。

```
int ExcludeClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int ExcludeClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>パラメーター

*x1*<br/>
四角形の左上隅の x の論理座標を指定します。

*y1*<br/>
論理で四角形の左上隅の y 座標を指定します。

*x2*<br/>
論理で四角形の右上隅の x 座標を指定します。

*y2*<br/>
論理で四角形の右上隅の y 座標を指定します。

*lpRect*<br/>
四角形を指定します。 できます、`CRect`オブジェクト。

### <a name="return-value"></a>戻り値

新しいクリップ領域の種類を指定します。 次の値のいずれかを指定できます。

- COMPLEXREGION 領域には、重なり合った境界線。

- エラー リージョンは作成されませんでした。

- NULLREGION 領域が空です。

- SIMPLEREGION 領域には、重複する境界線がありません。

### <a name="remarks"></a>Remarks

絶対値で指定された四角形の幅*x2* - *x1*、単位数が 32,767 を超えることはできません。 この制限は、同様の四角形の高さに適用されます。

##  <a name="excludeupdatergn"></a>  CDC::ExcludeUpdateRgn

関連付けられているクリップ領域から更新されたウィンドウ領域を除外することで無効なウィンドウ領域内の描画を防止、`CDC`オブジェクト。

```
int ExcludeUpdateRgn(CWnd* pWnd);
```

### <a name="parameters"></a>パラメーター

*我が物*<br/>
更新されるウィンドウを持つウィンドウ オブジェクトへのポインター。

### <a name="return-value"></a>戻り値

除外された領域の種類。 次の値のいずれかを指定できます。

- COMPLEXREGION 領域には、重なり合った境界線。

- エラー リージョンは作成されませんでした。

- NULLREGION 領域が空です。

- SIMPLEREGION 領域には、重複する境界線がありません。

##  <a name="extfloodfill"></a>  CDC::ExtFloodFill

現在のブラシで、表示画面の領域を塗りつぶします。

```
BOOL ExtFloodFill(
    int x,
    int y,
    COLORREF crColor,
    UINT nFillType);
```

### <a name="parameters"></a>パラメーター

*x*<br/>
論理で塗りつぶしを開始点の x 座標を指定します。

*y*<br/>
論理で塗りつぶしを開始するポイントの y 座標を指定します。

*crColor*<br/>
またはを格納する領域の境界の色を指定します。 解釈*crColor*の値に依存*nFillType*します。

*nFillType*<br/>
実行する塗りつぶしの種類を指定します。 値は次のいずれかを指定する必要があります。

- 指定された色の塗りつぶし領域に制限されます FLOODFILLBORDER *crColor*します。 このスタイルは、いっぱいになるによって実行されるのと同じ`FloodFill`します。

- 指定された色の塗りつぶし領域が定義されている返して*crColor*します。 色が発生した場合に限り、入力はすべての方向に外側続行されます。 このスタイルは、マルチカラーの境界領域を塗りつぶす場合に便利です。

### <a name="return-value"></a>戻り値

関数が成功した場合、0 以外の場合入力を完了できませんでした、指定したポイントに境界がある場合場合、は 0 で指定された色*crColor* (かどうか FLOODFILLBORDER が要求されました) で指定された色が指定したポイントにない場合*crColor*(かどうか返して)、またはポイントがクリッピング領域の外側にある場合。

### <a name="remarks"></a>Remarks

このメンバー関数はよりも柔軟`FloodFill`で塗りつぶしの種類を指定するため、 *nFillType*します。

場合*nFillType*設定で指定された色によって完全に制限すると見なされます、領域を FLOODFILLBORDER、 *crColor*。 指定された時点で、関数の開始*x*と*y*色の境界にすべての方向に拡張されます。

場合*nFillType*設定で指定された時点で開始する関数を返して、 *x*と*y*され、すべての隣接する領域の入力のすべての方向に続行指定された色を含む*crColor*します。

メモリ デバイス コンテキストとラスター表示テクノロジのサポートをサポートするデバイスだけ`ExtFloodFill`です。 詳細については、次を参照してください。、[調べるため](#getdevicecaps)メンバー関数。

##  <a name="exttextout"></a>  CDC::ExtTextOut

現在選択されているフォントを使用して四角形領域内の文字の文字列を書き込むには、このメンバー関数を呼び出します。

```
virtual BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    LPCTSTR lpszString,
    UINT nCount,
    LPINT lpDxWidths);

BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    const CString& str,
    LPINT lpDxWidths);
```

### <a name="parameters"></a>パラメーター

*x*<br/>
指定した文字列内の最初の文字の文字セルの論理の x 座標を指定します。

*y*<br/>
指定した文字列内の論理で最初の文字の文字セルの上端の y 座標を指定します。

*nOptions*<br/>
四角形の種類を指定します。 いずれか、両方、または、次の値のどちらも、このパラメーターを指定できます。

- ETO_CLIPPED では、テキストを四角形にクリップされるを指定します。

- ETO_OPAQUE を指定したこと、現在の背景色は、新たな、四角形を塗りつぶします。 (設定でき、クエリでは、現在の背景色、 [SetBkColor](#setbkcolor)と[GetBkColor](#getbkcolor)メンバー関数)。

*lpRect*<br/>
指す、 [RECT](/windows/desktop/api/windef/ns-windef-tagrect)四角形の寸法を決定する構造体。 このパラメーターは、NULL を指定できます。 渡すことも、 [CRect](../../atl-mfc-shared/reference/crect-class.md)このパラメーターのオブジェクト。

*lpszString*<br/>
描画する指定された文字の文字列を指します。 渡すことも、 [CString](../../atl-mfc-shared/reference/cstringt-class.md)このパラメーターのオブジェクト。

*nCount*<br/>
文字列の文字数を指定します。

*lpDxWidths*<br/>
隣接する文字セルの配信元の間の距離を示す値の配列を指します。 たとえば、 *lpDxWidths*[*は*] 論理ユニットは文字セルのオリジンを区切る*は*と文字セル*は*+ 1 です。 場合*lpDxWidths*が null の場合、`ExtTextOut`文字の既定の間隔を使用します。

*str*<br/>
A`CString`を描画する指定された文字を含むオブジェクト。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

四角形領域不透明にできます (現在の背景色で塗りつぶされた) とクリッピング領域であることができます。

場合*nOptions*は 0 と*lpRect*が null の場合、関数は、四角形の領域を使用せず、デバイス コンテキストにテキストを書き込みます。 既定では、関数は現在位置を使用することも、更新することもありません。 アプリケーションを呼び出すときに、現在の位置を更新する必要があるかどうか`ExtTextOut`、アプリケーションが呼び出すことができます、`CDC`メンバー関数は[呼び出された](#settextalign)で*nFlags* TA_UPDATECP に設定します。 このフラグを設定すると場合、Windows は無視されます*x*と*y*に後続の呼び出しで`ExtTextOut`し、代わりに、現在の位置を使用します。 アプリケーションでは、TA_UPDATECP を使用して、現在の位置を更新するときに`ExtTextOut`が指す配列の最後の要素で指定した位置またはテキストの前の行の末尾に、現在の位置を設定する*lpDxWidths*、大きい方になります。

##  <a name="fillpath"></a>  CDC::FillPath

現在のパス内の開いている図形を閉じ、現在のブラシと多角形の塗りつぶしモードを使用してパスの内部を塗りつぶします。

```
BOOL FillPath();
```

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

内部を入力すると、デバイス コンテキストからのパスは破棄されます。

##  <a name="fillrect"></a>  CDC::FillRect

指定されたブラシを使用して、指定した四角形を入力するには、このメンバー関数を呼び出します。

```
void FillRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>パラメーター

*lpRect*<br/>
指す、 [RECT](/windows/desktop/api/windef/ns-windef-tagrect)を格納する四角形の論理座標を含む構造体。 渡すことも、 [CRect](../../atl-mfc-shared/reference/crect-class.md)このパラメーターのオブジェクト。

*pBrush*<br/>
四角形の塗りつぶしに使用するブラシを識別します。

### <a name="remarks"></a>Remarks

関数は、左と上の境界線を含む、完全な四角形を塗りつぶしますが右や下の境界線に満たない。

ブラシが必要するいずれかを作成するを使用して、 [CBrush](../../mfc/reference/cbrush-class.md)メンバー関数[CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush)、[とき](../../mfc/reference/cbrush-class.md#createpatternbrush)、および[CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush)、によって取得されたか、 `GetStockObject` Windows 関数。

指定した四角形の入力時に`FillRect`四角形の右および下の辺には含まれません。 GDI は、四角形を塗りつぶしますが、含まれない、適切な列と下の行を現在のマッピング モードに関係なく。 `FillRect` 値を比較、 `top`、 `bottom`、 `left`、および`right`指定した四角形のメンバー。 場合`bottom`に等しいまたはそれよりも小さい`top`、または`right`に等しいまたはそれよりも小さい`left`、四角形が描画されていません。

`FillRect` ような[CDC::FillSolidRect](#fillsolidrect)。 ただし、`FillRect`ブラシを受け取り、したがって、純色、ディザリングされた色、ハッチ ブラシ、またはパターン塗りつぶす四角形を使用できます。 `FillSolidRect` 純色のみが (COLORREF パラメーターで示されます) を使用します。 `FillRect` 通常よりも遅い`FillSolidRect`します。

##  <a name="fillrgn"></a>  CDC::FillRgn

指定された領域を塗りつぶします*pRgn*で指定されたブラシで*pBrush*します。

```
BOOL FillRgn(
    CRgn* pRgn,
    CBrush* pBrush);
```

### <a name="parameters"></a>パラメーター

*pRgn*<br/>
塗りつぶす領域へのポインター。 指定された領域の座標は、論理単位で指定されます。

*pBrush*<br/>
領域の塗りつぶしに使用されるブラシを識別します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

使用して、ブラシを作成する必要がありますか、`CBrush`メンバー関数`CreateHatchBrush`、 `CreatePatternBrush`、`CreateSolidBrush`を取得または`GetStockObject`します。

### <a name="example"></a>例

  例をご覧ください[CRgn::CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn)します。

##  <a name="fillsolidrect"></a>  CDC::FillSolidRect

このメンバー関数は、指定の純色で指定した四角形の塗りつぶしを呼び出します。

```
void FillSolidRect(
    LPCRECT lpRect,
    COLORREF clr);

void FillSolidRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clr);
```

### <a name="parameters"></a>パラメーター

*lpRect*<br/>
(論理単位) に外接する四角形を指定します。 ポインターを渡すことができます、 [RECT](/windows/desktop/api/windef/ns-windef-tagrect)データ構造体または`CRect`このパラメーターのオブジェクト。

*clr*四角形の塗りつぶしに使用する色を指定します。

*x*<br/>
四角形の左上隅の x の論理座標を指定します。

*y*<br/>
先の四角形の左上隅の y の論理座標を指定します。

*cx*<br/>
四角形の幅を指定します。

*cy*<br/>
四角形の高さを指定します。

### <a name="remarks"></a>Remarks

`FillSolidRect` よく似ています[CDC::FillRect](#fillrect)ただし、`FillSolidRect`のみ純色 (COLORREF パラメーターで示されます)、中にを使用して`FillRect`ブラシを受け取り、したがって、ディザリングされた、純色で四角形の塗りつぶしに使用できます。色、ハッチ ブラシ、またはパターン。 `FillSolidRect` 通常より高速`FillRect`します。

> [!NOTE]
>  呼び出すと`FillSolidRect`、背景色は、これを使用して設定されていた[SetBkColor](#setbkcolor)、によって示される色に設定されている*clr*します。

##  <a name="flattenpath"></a>  CDC::FlattenPath

現在のデバイス コンテキストに選択したパス内の任意の曲線に変換し、行のシーケンスに、各曲線。

```
BOOL FlattenPath();
```

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

##  <a name="floodfill"></a>  CDC::FloodFill

現在のブラシで、表示画面の領域を塗りつぶします。

```
BOOL FloodFill(
    int x,
    int y,
    COLORREF crColor);
```

### <a name="parameters"></a>パラメーター

*x*<br/>
論理で塗りつぶしを開始点の x 座標を指定します。

*y*<br/>
論理で塗りつぶしを開始するポイントの y 座標を指定します。

*crColor*<br/>
境界の色を指定します。

### <a name="return-value"></a>戻り値

関数が成功した場合、0 以外の場合それ以外の場合 0 が返される特定のポイントがで指定された境界の色である場合は、入力を完了できませんでした、 *crColor*点、クリッピング領域の外側ですか。

### <a name="remarks"></a>Remarks

指定されたとして制限する領域を想定*crColor*します。 `FloodFill`関数で指定されたポイントから始まります*x*と*y*され、色の境界にすべての方向に続行します。

メモリ デバイス コンテキストとラスター表示テクノロジのサポートをサポートしているデバイスのみ、`FloodFill`メンバー関数。 RC_BITBLT 機能の詳細については、次を参照してください。、`GetDeviceCaps`メンバー関数。

`ExtFloodFill`関数は柔軟性が同様の機能を提供します。

##  <a name="framerect"></a>  CDC::FrameRect

指定された四角形の境界線を描画*lpRect*します。

```
void FrameRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>パラメーター

*lpRect*<br/>
指す、 [RECT](/windows/desktop/api/windef/ns-windef-tagrect)構造または[CRect](../../atl-mfc-shared/reference/crect-class.md)四角形の左上隅および右下コーナーの論理座標を格納しているオブジェクト。 渡すことも、`CRect`このパラメーターのオブジェクト。

*pBrush*<br/>
四角形の境界線に使用されるブラシを識別します。

### <a name="remarks"></a>Remarks

関数では、指定されたブラシを使用して、境界線を描画します。 幅と高さの枠線は、常に 1 論理単位です。

場合、四角形の`bottom`座標と等しいまたはそれよりも小さい`top`、または`right`に等しいまたはそれよりも小さい`left`、四角形が描画されていません。

によって描画される境界線`FrameRect`によって描画される境界線と同じ位置では、`Rectangle`メンバー関数が同じ座標を使用して (場合`Rectangle`ワイド論理ユニットが 1 であるペンを使用)。 四角形の内部が塗りつぶされていない`FrameRect`します。

##  <a name="framergn"></a>  CDC::FrameRgn

指定されたリージョン境界線を描画*pRgn*で指定されたブラシを使用して*pBrush*します。

```
BOOL FrameRgn(
    CRgn* pRgn,
    CBrush* pBrush,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>パラメーター

*pRgn*<br/>
指す、`CRgn`罫線で囲む領域を識別するオブジェクト。 指定された領域の座標は、論理単位で指定されます。

*pBrush*<br/>
指す、`CBrush`境界線の描画に使用されるブラシを識別するオブジェクト。

*nWidth*<br/>
デバイス単位での垂直方向のブラシで、罫線の幅を指定します。

*nHeight*<br/>
デバイス単位で水平方向のブラシのストロークの境界線の高さを指定します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="example"></a>例

  例をご覧ください[CRgn::CombineRgn](../../mfc/reference/crgn-class.md#combinergn)します。

##  <a name="fromhandle"></a>  CDC::FromHandle

ポインターを返します、`CDC`デバイス コンテキストを識別するハンドルが指定されるとします。

```
static CDC* PASCAL FromHandle(HDC hDC);
```

### <a name="parameters"></a>パラメーター

*hDC*<br/>
Windows デバイス コンテキストを識別するハンドルが含まれています。

### <a name="return-value"></a>戻り値

ポインターは、一時的な場合があり、すぐに使用できるを超えて保存してはなりません。

### <a name="remarks"></a>Remarks


  `CDC` オブジェクトがハンドルに関連付けられていない場合は、一時的な `CDC` オブジェクトが生成され、関連付けられます。

### <a name="example"></a>例

  例をご覧ください[CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc)します。

##  <a name="getarcdirection"></a>  CDC::GetArcDirection

デバイス コンテキストの現在の円弧の方向を取得します。

```
int GetArcDirection() const;
```

### <a name="return-value"></a>戻り値

成功した場合は、現在の円弧の方向を指定します。 以下は、有効な戻り値です。

- AD_COUNTERCLOCKWISE 円弧と反時計回りに描画する四角形。

- AD_CLOCKWISE 円弧、時計回りに描画する四角形。

エラーが発生する場合、戻り値は 0 です。

### <a name="remarks"></a>Remarks

円弧と四角形の関数は、円弧の方向を使用します。

##  <a name="getaspectratiofilter"></a>  CDC::GetAspectRatioFilter

現在の縦横比のフィルターの設定を取得します。

```
CSize GetAspectRatioFilter() const;
```

### <a name="return-value"></a>戻り値

A`CSize`縦横比の現在のフィルターで使用される縦横比を表すオブジェクト。

### <a name="remarks"></a>Remarks

縦横比は、デバイスのピクセルの幅と高さによって形成される比率です。 については、デバイスの縦横比は、作成、選択、およびフォントの表示で使用されます。 Windows では、縦横比フィルターのすべての利用可能なフォントから特定の縦横比用に設計されたフォントを選択する、特殊なフィルターを提供します。 フィルターで指定した縦横比を使用して、`SetMapperFlags`メンバー関数。

##  <a name="getbkcolor"></a>  CDC::GetBkColor

現在の背景色を返します。

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>戻り値

RGB 色の値。

### <a name="remarks"></a>Remarks

バック グラウンド モードが不透明である場合は、システムをスタイル設定された行のギャップ、ハッチ ブラシ、行と文字セルの背景の間のギャップを埋める背景色を使用します。 ビットマップの色とモノクロ デバイス コンテキストの間を変換するときにも背景色が使用されます。

##  <a name="getbkmode"></a>  CDC::GetBkMode

バック グラウンド モードを返します。

```
int GetBkMode() const;
```

### <a name="return-value"></a>戻り値

現在バック グラウンド モードを透明または不透明にすることができます。

### <a name="remarks"></a>Remarks

バック グラウンド モードでは、テキストやハッチ ブラシ、実線ではないペンのスタイルを描画する前に、システムが描画サーフェイスでの既存の背景色を削除するかどうかを定義します。

##  <a name="getboundsrect"></a>  CDC::GetBoundsRect

現在までの累積外接する四角形の指定したデバイス コンテキストを返します。

```
UINT GetBoundsRect(
    LPRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>パラメーター

*lpRectBounds*<br/>
現在の外接する四角形を受け取るバッファーへのポインター。 論理座標では、四角形が返されます。

*flags*<br/>
外接する四角形が返された後に消去するかどうかを指定します。 このパラメーターを 0 にするか、次の値に設定する必要があります。

- DCB_RESET では、返された後に消去する外接する四角形を強制します。

### <a name="return-value"></a>戻り値

関数が成功した場合は、外接する四角形の現在の状態を指定します。 次の値の組み合わせを指定できます。

- DCB_ACCUMULATE 外接する四角形の累積が発生しています。

- DCB_RESET 外接する四角形が空です。

- DCB_SET 外接する四角形が空ではありません。

- 集積/離散の DCB_ENABLE 境界です。

- 集積/離散の DCB_DISABLE 境界は off です。

##  <a name="getbrushorg"></a>  CDC::GetBrushOrg

デバイス コンテキストの現在選択されているブラシの原点を (デバイス単位) を取得します。

```
CPoint GetBrushOrg() const;
```

### <a name="return-value"></a>戻り値

(デバイス単位) としてのブラシの現在の配信元を[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)オブジェクト。

### <a name="remarks"></a>Remarks

最初のブラシの原点が (0, 0) がクライアント領域の。 戻り値は、デスクトップ ウィンドウの原点のデバイス単位で、このポイントを指定します。

##  <a name="getcharacterplacement"></a>  CDC::GetCharacterPlacement

文字列に関するさまざまな情報を取得します。

```
DWORD GetCharacterPlacement(
    LPCTSTR lpString,
    int nCount,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;

DWORD GetCharacterPlacement(
    CString& str,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>パラメーター

*lpString*<br/>
処理する文字列へのポインター。

*nCount*<br/>
文字列の長さを指定します。 ANSI バージョンの場合は BYTE カウント、Unicode 関数の場合は WORD カウントです。 詳細については、次を参照してください。 [GetCharacterPlacement](/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa)します。

*nMaxExtent*<br/>
処理する文字列の最大エクステントを論理単位で指定します。 このエクステントを超えて処理された文字列は無視されます。 並べ替えやグリフの配列に必要な演算は、範囲に含まれている文字だけに適用されます。 GCP_MAXEXTENT 値が指定されている場合にのみ、このパラメーターが使用される、 *dwFlags*パラメーター。 入力文字列を処理するときは、エクステントの合計が最大値を超えない限り、各文字と文字のエクステントが出力、エクステント、および他の配列に追加されます。 制限に達すると、処理は停止します。

*lpResults*<br/>
ポインターを[GCP_Results](/windows/desktop/api/wingdi/ns-wingdi-taggcp_resultsa)関数の結果を受け取る構造体。

*dwFlags*<br/>
必要な配列に挿入される文字列の処理方法を指定します。 このパラメーターは、いずれかを指定できますか記載以上の値、 *dwFlags*のセクション、 [GetCharacterPlacement](/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa)トピック。

*str*<br/>
ポインターを[CString](../../atl-mfc-shared/reference/cstringt-class.md)オブジェクトを処理します。

### <a name="return-value"></a>戻り値

関数が正常に終了した場合は、文字列の幅と高さを論理単位で返します。

関数が失敗した場合は、0 を返します。

### <a name="remarks"></a>Remarks

このメンバー関数は、関数の機能をエミュレート[GetCharacterPlacement](/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa)」の説明に従って、Windows SDK。

##  <a name="getcharabcwidths"></a>  CDC::GetCharABCWidths

現在の TrueType フォントから指定した範囲内の連続する文字の幅を取得します。

```
BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABC lpabc) const;

BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABCFLOAT lpABCF) const;
```

### <a name="parameters"></a>パラメーター

*nFirstChar*<br/>
文字の幅が返される現在のフォントの文字の範囲の最初の文字を指定します。

*nLastChar*<br/>
文字の幅が返される現在のフォントの文字の範囲の最後の文字を指定します。

*lpabc*<br/>
配列を指す[ABC](/windows/desktop/api/wingdi/ns-wingdi-_abc)関数が返す場合は、文字幅を受信する構造体。 この配列に含める必要があります多くとして少なくとも`ABC`構造体で指定された範囲の文字があると、 *nFirstChar*と*とも*パラメーター。

*lpABCF*<br/>
アプリケーションによって提供されるバッファーの配列を指す[ABCFLOAT](/windows/desktop/api/wingdi/ns-wingdi-_abcfloat)関数が返す場合は、文字幅を受信する構造体。 この関数によって返される幅は、IEEE 浮動小数点形式では。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

論理ユニットでは、幅が返されます。 この関数は、TrueType フォントでのみ成功します。

TrueType ラスタライザーは、特定のポイント サイズを選択した後に、"ABC"の文字間隔を提供します。 "A"の間隔は、グリフを配置する前に、現在の位置に追加される距離です。 "B"の間隔は、グリフの黒い部分の幅です。 "C"間隔は、グリフの右側に空白文字に対応する現在の位置に追加されます。 幅の総計が A で指定された + B + C.

ときに、`GetCharABCWidths`メンバー関数は、負の値"A"を取得します。 または、文字、文字幅を"C"では、スペーシングまたはオーバー ハングが含まれています。

ABC の幅をフォント デザイン単位に変換するアプリケーションがフォントを作成、高さが (で指定されている、`lfHeight`のメンバー、 [LOGFONT](/windows/desktop/api/wingdi/ns-wingdi-taglogfonta)構造) に格納されている値と等しい、 `ntmSizeEM` のメンバー[NEWTEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagnewtextmetrica)構造体。 (の値、`ntmSizeEM`メンバーを呼び出すことによって取得できます、 [EnumFontFamilies](/windows/desktop/api/wingdi/nf-wingdi-enumfontfamiliesa) Windows 関数です)。

現在選択されているフォントの範囲外にある文字では、既定の文字の ABC の幅が使用されます。

非 TrueType フォントの文字の幅を取得するアプリケーションを使用する必要があります、 [GetCharWidth](/windows/desktop/api/wingdi/nf-wingdi-getcharwidtha) Windows 関数。

##  <a name="getcharabcwidthsi"></a>  CDC::GetCharABCWidthsI

現在の TrueType フォントを指定の範囲内で連続したグリフのインデックスの論理単位の幅を取得します。

```
BOOL GetCharABCWidthsI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPABC lpabc) const;
```

### <a name="parameters"></a>パラメーター

*giFirst*<br/>
現在のフォントから連続するグリフのインデックスのグループでは、最初のグリフ インデックスを指定します。 場合にのみ、このパラメーターが使用、 *pgi*パラメーターが NULL です。

*cgi*<br/>
グリフのインデックスの数を指定します。

*pgi*<br/>
グリフのインデックスを含む配列へのポインター。 値が NULL の場合、 *giFirst*パラメーターを代わりに使用されます。 *Cgi*パラメーターは、この配列のグリフのインデックスの数を指定します。

*lpabc*<br/>
配列を指すポインター [ABC](/windows/desktop/api/wingdi/ns-wingdi-_abc)文字幅を受け取る構造体。 この配列に含める必要があります多くとして少なくとも`ABC`構造体で指定されたグリフのインデックスがあると、 *cgi*パラメーター。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

このメンバー関数は、関数の機能をエミュレート[GetCharABCWidthsI](/windows/desktop/api/wingdi/nf-wingdi-getcharabcwidthsi)」の説明に従って、Windows SDK。

##  <a name="getcharwidth"></a>  CDC::GetCharWidth

現在のフォントの文字の隣接するグループの個々 の文字の幅を取得を使用して`m_hAttribDC`、入力デバイス コンテキスト。

```
BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;

BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    float* lpFloatBuffer) const;
```

### <a name="parameters"></a>パラメーター

*nFirstChar*<br/>
現在のフォントの文字の連続したグループ内の最初の文字を指定します。

*nLastChar*<br/>
現在のフォントの文字の連続したグループ内の最後の文字を指定します。

*lpBuffer*<br/>
現在のフォントで文字の隣接するグループの幅の値を受け取るバッファーへのポインター。

*lpFloatBuffer*<br/>
文字幅を受け取るバッファーへのポインター。 返される幅は 32 ビット IEEE 浮動小数点形式です。 (幅は、文字のベース ラインに沿って測定されます)。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

たとえば場合、 *nFirstChar*文字を識別します。 'a' と*とも*文字 'z'、関数を取得しますすべての小文字の幅を識別します。

関数の値を指すバッファーに格納する*lpBuffer*します。 このバッファーは、すべての幅を保持するのに十分な大きさである必要があります。 エントリが発生する必要がある 26 少なくともこの例では。

特定のフォントの文字の連続したグループ内の文字が存在しない場合は、既定の文字の幅の値が割り当てられます。

##  <a name="getcharwidthi"></a>  CDC::GetCharWidthI

現在のフォントを指定の範囲内で連続したグリフのインデックスの論理座標、幅を取得します。

```
BOOL GetCharWidthI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>パラメーター

*giFirst*<br/>
現在のフォントから連続するグリフのインデックスのグループでは、最初のグリフ インデックスを指定します。 場合にのみ、このパラメーターが使用、 *pgi*パラメーターが NULL です。

*cgi*<br/>
グリフのインデックスの数を指定します。

*pgi*<br/>
グリフのインデックスを含む配列へのポインター。 値が NULL の場合、 *giFirst*パラメーターを代わりに使用されます。 *Cgi*パラメーターは、この配列のグリフのインデックスの数を指定します。

*lpBuffer*<br/>
幅を受け取るバッファーへのポインター。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

このメンバー関数は、関数の機能をエミュレート[GetCharWidthI](/windows/desktop/api/wingdi/nf-wingdi-getcharwidthi)」の説明に従って、Windows SDK。

##  <a name="getclipbox"></a>  CDC::GetClipBox

現在のクリップ領域を最小の外接する四角形の寸法を取得します。

```
virtual int GetClipBox(LPRECT lpRect) const;
```

### <a name="parameters"></a>パラメーター

*lpRect*<br/>
指す、 [RECT](/windows/desktop/api/windef/ns-windef-tagrect)構造または[CRect](../../atl-mfc-shared/reference/crect-class.md)四角形の大きさを受信するオブジェクト。

### <a name="return-value"></a>戻り値

クリッピング領域の種類。 次の値のいずれかを指定できます。

- COMPLEXREGION クリッピング領域には、重なり合った境界線。

- デバイス コンテキストのエラーが無効です。

- NULLREGION クリッピング領域が空です。

- SIMPLEREGION クリッピング領域には、重複する境界がありません。

### <a name="remarks"></a>Remarks

ディメンションがによって指し示されるバッファーにコピーされます*lpRect*します。

##  <a name="getcoloradjustment"></a>  CDC::GetColorAdjustment

デバイス コンテキストの色の調整値を取得します。

```
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
```

### <a name="parameters"></a>パラメーター

*lpColorAdjust*<br/>
指す、 [COLORADJUSTMENT](/windows/desktop/api/wingdi/ns-wingdi-tagcoloradjustment)色の調整値を受信するデータ構造体。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

##  <a name="getcurrentbitmap"></a>  CDC::GetCurrentBitmap

現在選択されているポインターを返します`CBitmap`オブジェクト。

```
CBitmap* GetCurrentBitmap() const;
```

### <a name="return-value"></a>戻り値

ポインターを`CBitmap`オブジェクト、成功した場合。 それ以外の場合は NULL です。

### <a name="remarks"></a>Remarks

このメンバー関数は、一時オブジェクトを返す可能性があります。

##  <a name="getcurrentbrush"></a>  CDC::GetCurrentBrush

現在選択されているポインターを返します`CBrush`オブジェクト。

```
CBrush* GetCurrentBrush() const;
```

### <a name="return-value"></a>戻り値

ポインターを`CBrush`オブジェクト、成功した場合。 それ以外の場合は NULL です。

### <a name="remarks"></a>Remarks

このメンバー関数は、一時オブジェクトを返す可能性があります。

##  <a name="getcurrentfont"></a>  CDC::GetCurrentFont

現在選択されているポインターを返します`CFont`オブジェクト。

```
CFont* GetCurrentFont() const;
```

### <a name="return-value"></a>戻り値

ポインターを`CFont`オブジェクト、成功した場合。 それ以外の場合は NULL です。

### <a name="remarks"></a>Remarks

このメンバー関数は、一時オブジェクトを返す可能性があります。

##  <a name="getcurrentpalette"></a>  CDC::GetCurrentPalette

現在選択されているポインターを返します`CPalette`オブジェクト。

```
CPalette* GetCurrentPalette() const;
```

### <a name="return-value"></a>戻り値

ポインターを`CPalette`オブジェクト、成功した場合。 それ以外の場合は NULL です。

### <a name="remarks"></a>Remarks

このメンバー関数は、一時オブジェクトを返す可能性があります。

##  <a name="getcurrentpen"></a>  CDC::GetCurrentPen

現在選択されているポインターを返します`CPen`オブジェクト。

```
CPen* GetCurrentPen() const;
```

### <a name="return-value"></a>戻り値

ポインターを`CPen`オブジェクト、成功した場合。 それ以外の場合は NULL です。

### <a name="remarks"></a>Remarks

このメンバー関数は、一時オブジェクトを返す可能性があります。

##  <a name="getcurrentposition"></a>  CDC::GetCurrentPosition

(論理座標) の現在の位置を取得します。

```
CPoint GetCurrentPosition() const;
```

### <a name="return-value"></a>戻り値

現在の位置として、`CPoint`オブジェクト。

### <a name="remarks"></a>Remarks

現在の位置を設定することができます、`MoveTo`メンバー関数。

##  <a name="getdcbrushcolor"></a>  CDC::GetDCBrushColor

現在のブラシの色を取得します。

```
COLORREF GetDCBrushColor() const;
```

### <a name="return-value"></a>戻り値

関数が成功した場合、戻り値は、 [COLORREF](/windows/desktop/gdi/colorref)現在のブラシの色の値。

関数が失敗した場合は、値を返します。

### <a name="remarks"></a>Remarks

このメンバー関数は、関数の機能をエミュレート[GetDCBrushColor](/windows/desktop/api/wingdi/nf-wingdi-getdcbrushcolor)」の説明に従って、Windows SDK。

##  <a name="getdcpencolor"></a>  CDC::GetDCPenColor

現在のペンの色を取得します。

```
COLORREF GetDCPenColor() const;
```

### <a name="return-value"></a>戻り値

関数が成功した場合、戻り値は、 [COLORREF](/windows/desktop/gdi/colorref)現在のペンの色の値。

関数が失敗した場合は、値を返します。

### <a name="remarks"></a>Remarks

このメンバー関数で Win32 関数[GetDCPenColor](/windows/desktop/api/wingdi/nf-wingdi-getdcpencolor)」の説明に従って、Windows SDK。

##  <a name="getdevicecaps"></a>  CDC::GetDeviceCaps

さまざまなディスプレイ デバイスのデバイスに固有の情報を取得します。

```
int GetDeviceCaps(int nIndex) const;
```

### <a name="parameters"></a>パラメーター

*nIndex*<br/>
返される情報の種類を指定します。 参照してください[調べるため](/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps)値の一覧については、Windows SDK に含まれています。

### <a name="return-value"></a>戻り値

関数が成功した場合、要求された機能の値。

### <a name="example"></a>例

  例をご覧ください[CPrintDialog::GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults)します。

##  <a name="getfontdata"></a>  CDC::GetFontData

スケーラブルなフォント ファイルからフォント メトリック情報を取得します。

```
DWORD GetFontData(
    DWORD dwTable,
    DWORD dwOffset,
    LPVOID lpData,
    DWORD cbData) const;
```

### <a name="parameters"></a>パラメーター

*dwTable*<br/>
返されるメトリック テーブルの名前を指定します。 このパラメーターは、Microsoft Corporation によって公開されている TrueType フォント ファイルの仕様に記載されているメトリックのテーブルのいずれかを指定できます。 このパラメーターが 0 の場合、フォント ファイルの先頭からの情報が取得されます。

*dwOffset*<br/>
情報の取得を開始する位置のテーブルの先頭からのオフセットを指定します。 指定されたテーブルの先頭から情報を取得するこのパラメーターが 0 の場合、 *dwTable*パラメーター。 この値が、テーブルのサイズ以上である場合`GetFontData`0 を返します。

*lpData*<br/>
フォント情報を受け取るバッファーへのポインター。 この値が NULL の場合は、関数がで指定されたフォント データに必要なバッファーのサイズを返します、 *dwTable*パラメーター。

*cbData*<br/>
取得する情報のバイト単位の長さを指定します。 このパラメーターが 0 の場合`GetFontData`で指定されたデータのサイズを返します、 *dwTable*パラメーター。

### <a name="return-value"></a>戻り値

指すバッファーに返されるバイト数を指定します*lpData*関数が成功した場合は-1 です。

### <a name="remarks"></a>Remarks

取得する情報は、フォント ファイルに返される情報の長さのオフセットを指定することによって識別されます。

アプリケーションを使用できる場合があります、`GetFontData`メンバー関数は、文書に TrueType フォントを保存します。 これを行うには、アプリケーションかどうかをフォント埋め込み可能の場合は 0 を指定する、全体のフォント ファイルを取得、 *dwTable*、 *dwOffset*、および*cbData*パラメーター。

アプリケーションがチェックして、フォントを埋め込むことができるかどうかを判断することができます、`otmfsType`のメンバー、 [OUTLINETEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-_outlinetextmetrica)構造体。 場合のビット 1`otmfsType`が設定された場合、フォントの埋め込みは許可されていません。 1 ビットがオフの場合は、フォントを埋め込むことができます。 ビット 2 が設定されている場合、埋め込みは読み取り専用です。

この関数を使用して非 TrueType フォントの情報を取得しようとしているアプリケーションの場合、`GetFontData`メンバー関数は-1 を返します。

##  <a name="getfontlanguageinfo"></a>  CDC::GetFontLanguageInfo

現在選択されているフォントを指定した表示コンテキストに関する情報を返します。

```
DWORD GetFontLanguageInfo() const;
```

### <a name="return-value"></a>戻り値

戻り値は、現在選択されているフォントの特性を識別します。 使用可能な値の完全な一覧については、次を参照してください。 [GetFontLanguageInfo](/windows/desktop/api/wingdi/nf-wingdi-getfontlanguageinfo)します。

### <a name="remarks"></a>Remarks

このメンバー関数は、関数の機能をエミュレート[GetFontLanguageInfo](/windows/desktop/api/wingdi/nf-wingdi-getfontlanguageinfo)」の説明に従って、Windows SDK。

##  <a name="getglyphoutline"></a>  CDC::GetGlyphOutline

曲線のアウトラインまたはビットマップでは、現在のフォントをアウトライン文字を取得します。

```
DWORD GetGlyphOutline(
    UINT nChar,
    UINT nFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cbBuffer,
    LPVOID lpBuffer,
    const MAT2* lpmat2) const;
```

### <a name="parameters"></a>パラメーター

*NChar*<br/>
情報が返される対象の文字を指定します。

*nFormat*<br/>
情報を返す関数の形式を指定します。 次の値の 1 つまたは 0 を指定できます。

|[値]|説明|
|-----------|-------------|
|GGO_BITMAP|グリフ ビットマップを返します。 返す場合は、関数によって指し示されるバッファー *lpBuffer*ダブルワード境界にピクセルあたり 1 ビット ビットマップが含まれています。|
|GGO_NATIVE|デバイス単位を使用して、ラスタライザーのネイティブ形式でデータ ポイント、曲線を返します。 すべての変換がで指定されたこの値を指定すると、 *lpmat2*は無視されます。|

ときの値*フォーマット*が 0 の場合、関数を入力、 [GLYPHMETRICS](/windows/desktop/api/wingdi/ns-wingdi-_glyphmetrics)構造体がグリフのアウトライン データは返されません。

*lpgm*<br/>
文字セル内のグリフの配置を表す GLYPHMETRICS 構造体を指します。

*cbbuffer:*<br/>
関数がアウトライン文字に関する情報をコピーする先のバッファーのサイズを指定します。 この値が 0 の場合、*フォーマット*パラメーター GGO_BITMAP または GGO_NATIVE のいずれかの値は、必要なバッファーのサイズを返します。

*lpBuffer*<br/>
関数がアウトライン文字に関する情報をコピーする先のバッファーを指します。 場合*フォーマット*GGO_NATIVE 値を指定します TTPOLYGONHEADER とそれに続く構造体の形式で情報をコピーします。 この値が NULL の場合と*フォーマット*GGO_BITMAP または GGO_NATIVE のいずれかの値は、必要なバッファーのサイズを返します。

*lpmat2*<br/>
指す、 [MAT2](/windows/desktop/api/wingdi/ns-wingdi-_mat2)文字の変換行列を含む構造体。 GGO_NATIVE 値が指定されている場合でも、このパラメーターは NULL をすることはできません*フォーマット*します。

### <a name="return-value"></a>戻り値

場合に取得した情報に必要なバッファーのバイト単位でサイズを*cbbuffer:* 0 がまたは*lpBuffer*は NULL です。 それ以外は正の値、関数が成功した場合またはエラーがある場合は-1。

### <a name="remarks"></a>Remarks

アプリケーションが指す構造体で、2-2 での変換行列を指定することで、ビットマップ形式で取得した文字を回転できます*lpmat2*します。

グリフのアウトラインは、一連の輪郭として返されます。 各の輪郭を[TTPOLYGONHEADER](/windows/desktop/api/wingdi/ns-wingdi-tagttpolygonheader)構造が続く多くとして`TTPOLYCURVE`構造体とその内容について説明する必要があります。 すべてのポイントとして返されます[POINTFX](/windows/desktop/api/wingdi/ns-wingdi-tagpointfx)構造体し、しない相対移動の絶対位置を表します。 によって指定された開始点、`pfxStart`のメンバー、 [TTPOLYGONHEADER](/windows/desktop/api/wingdi/ns-wingdi-tagttpolygonheader)構造は、輪郭のアウトラインを開始するポイント。 [それに続く](/windows/desktop/api/wingdi/ns-wingdi-tagttpolycurve)続く構造体はポリライン レコードまたはスプライン レコードのいずれかにできます。 折れ線レコードは、一連のポイント。点の間に描画される線では、文字のアウトラインを説明します。 スプライン レコードは、TrueType (つまり、2 次 b スプライン) で使用される二次曲線を表します。

##  <a name="getgraphicsmode"></a>  CDC::GetGraphicsMode

指定したデバイス コンテキストの現在のグラフィックス モードを取得します。

```
int GetGraphicsMode() const;
```

### <a name="return-value"></a>戻り値

成功した場合に、現在のグラフィックス モードを返します。 このメソッドが返すことができる値については、次を参照してください。[については](/windows/desktop/api/wingdi/nf-wingdi-getgraphicsmode)します。

失敗した場合は 0 を返します。

拡張エラー情報を取得するには呼び出します[GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360)します。

### <a name="remarks"></a>Remarks

このメソッドは、Windows GDI 関数をラップ[については](/windows/desktop/api/wingdi/nf-wingdi-getgraphicsmode)します。

##  <a name="gethalftonebrush"></a>  CDC::GetHalftoneBrush

ハーフトーン ブラシを取得するには、このメンバー関数を呼び出します。

```
static CBrush* PASCAL GetHalftoneBrush();
```

### <a name="return-value"></a>戻り値

ポインター、`CBrush`成功。 それ以外の場合に NULL の場合は、オブジェクト。

### <a name="remarks"></a>Remarks

ハーフトーン ブラシは、ディザリングされたパターンを作成する前景色と背景の色またはピクセルを示しています。 次にハーフトーン ブラシによって作成されたディザリングされたパターンの例を示します。

![ディザリングされたペンのストロークの詳細](../../mfc/reference/media/vc318s1.gif "ディザリングされたペンのストロークの詳細")

##  <a name="getkerningpairs"></a>  CDC::GetKerningPairs

指定したデバイス コンテキストで現在選択されているフォントのペアをカーニング文字を取得します。

```
int GetKerningPairs(
    int nPairs,
    LPKERNINGPAIR lpkrnpair) const;
```

### <a name="parameters"></a>パラメーター

*nPairs*<br/>
数を指定[受け取る](/windows/desktop/api/wingdi/ns-wingdi-tagkerningpair)によって示される構造体*lpkrnpair*します。 関数は指定よりもカーニング ペアをコピーしません*nPairs*します。

*lpkrnpair*<br/>
配列を指す`KERNINGPAIR`関数が返す場合のペアをカーニングする構造体。 この配列によって指定された数以上の構造を含める必要があります*nPairs*します。 このパラメーターが NULL の場合は、カーニング、フォントのペアの合計数を返します。

### <a name="return-value"></a>戻り値

関数が成功した場合は、取得したカーニング ペアの数またはカーニング、フォントのペアの合計数を指定します。 関数が失敗するか、カーニング、フォントのペアがない場合は、0 が返されます。

##  <a name="getlayout"></a>  CDC::GetLayout

テキストとグラフィックス デバイス コンテキストをプリンターなど、メタファイルのレイアウトを決定するには、このメンバー関数を呼び出します。

```
DWORD GetLayout() const;
```

### <a name="return-value"></a>戻り値

成功した場合、レイアウトは、現在のデバイス コンテキストのフラグします。 それ以外の場合、GDI_ERROR します。 エラーの詳細については、呼び出す[GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360)します。 レイアウトのフラグの一覧は、次を参照してください。 [CDC::SetLayout](#setlayout)します。

### <a name="remarks"></a>Remarks

既定のレイアウトを左右から。

##  <a name="getmapmode"></a>  CDC::GetMapMode

現在のマップ モードを取得します。

```
int GetMapMode() const;
```

### <a name="return-value"></a>戻り値

マップ モード。

### <a name="remarks"></a>Remarks

マップ モードの説明は、次を参照してください。、`SetMapMode`メンバー関数。

> [!NOTE]
>  呼び出す場合[SetLayout](#setlayout) DC を右から左のレイアウトに変更する`SetLayout`にマッピング モードが自動的に変更します。 その結果、すべての後続の呼び出しに`GetMapMode`MM_ISOTROPIC が返されます。

##  <a name="getmiterlimit"></a>  CDC::GetMiterLimit

デバイス コンテキストのマイタ制限値を返します。

```
float GetMiterLimit() const;
```

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

マイター リミットは、マイター結合を持つ幾何学的線を描画するときに使用されます。

##  <a name="getnearestcolor"></a>  CDC::GetNearestColor

指定した論理色に最適な純色を返します。

```
COLORREF GetNearestColor(COLORREF crColor) const;
```

### <a name="parameters"></a>パラメーター

*crColor*<br/>
一致する色を指定します。

### <a name="return-value"></a>戻り値

色の RGB (赤、緑、青) 値、平面を定義するに最も近い色、 *crColor*デバイスを表すことができます。

### <a name="remarks"></a>Remarks

特定のデバイスは、この色を表現できる必要があります。

##  <a name="getoutlinetextmetrics"></a>  CDC::GetOutlineTextMetrics

TrueType フォントのメトリック情報を取得します。

```
UINT GetOutlineTextMetrics(
    UINT cbData,
    LPOUTLINETEXTMETRIC lpotm) const;
```

### <a name="parameters"></a>パラメーター

*lpotm*<br/>
配列を指す[OUTLINETEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-_outlinetextmetrica)構造体。 このパラメーターが NULL の場合は、取得されたメトリック データに必要なバッファーのサイズを返します。

*cbData*<br/>
情報が返されるバッファーのバイト単位で、サイズを指定します。

*lpotm*<br/>
指す、`OUTLINETEXTMETRIC`構造体。 このパラメーターが NULL の場合は、取得したメトリック情報に必要なバッファーのサイズを返します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

[OUTLINETEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-_outlinetextmetrica)構造には、truetype フォントの形式で提供されるフォント メトリック情報の大部分が含まれるなど、[受け取る](/windows/desktop/api/wingdi/ns-wingdi-tagtextmetrica)構造体。 最後の 4 つのメンバー、`OUTLINETEXTMETRIC`構造体は文字列へのポインター。 アプリケーションでは、これらの文字列だけでなく、他のメンバーに必要な領域の領域を割り当てる必要があります。 メモリの割り当ての最も簡単な方法がの場合は NULL を指定することで、必要なサイズを取得するには、文字列のサイズをシステムの制限がないため、*規定*最初の呼び出しで、`GetOutlineTextMetrics`関数。

##  <a name="getoutputcharwidth"></a>  CDC::GetOutputCharWidth

出力デバイス コンテキストを使用して`m_hDC`現在のフォントからの文字の隣接するグループの個々 の文字の幅を取得します。

```
BOOL GetOutputCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>パラメーター

*nFirstChar*<br/>
現在のフォントの文字の連続したグループ内の最初の文字を指定します。

*nLastChar*<br/>
現在のフォントの文字の連続したグループ内の最後の文字を指定します。

*lpBuffer*<br/>
現在のフォントで文字の隣接するグループの幅の値を受け取るバッファーへのポインター。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

たとえば場合、 *nFirstChar*文字を識別します。 'a' と*とも*文字 'z'、関数を取得しますすべての小文字の幅を識別します。

関数の値を指すバッファーに格納する*lpBuffer*します。 このバッファーは、すべての幅を保持するために十分な大きさである必要があります。エントリが発生する必要がある 26 少なくともこの例では。

特定のフォントの文字の連続したグループ内の文字が存在しない場合は、既定の文字の幅の値が割り当てられます。

##  <a name="getoutputtabbedtextextent"></a>  CDC::GetOutputTabbedTextExtent

幅と高さを文字の文字列の使用を計算するには、このメンバー関数を呼び出す[m_hDC](#m_hdc)、出力デバイス コンテキスト。

```
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetOutputTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>パラメーター

*lpszString*<br/>
測定する文字の文字列を指します。 渡すことも、 [CString](../../atl-mfc-shared/reference/cstringt-class.md)このパラメーターのオブジェクト。

*nCount*<br/>
文字列の文字数を指定します。 場合*nCount* -1 で、長さが計算されます。

*nTabPositions*<br/>
指す配列内のタブ ストップの位置の数を指定します*いる*します。

*いる*<br/>
論理ユニットのタブ ストップの位置を格納している整数の配列を指します。 タブ ストップを昇順に並べ替え; 並べ替える必要があります。x の最小値、配列の最初の項目があります。 バック タブを指定することはできません。

*str*<br/>
A`CString`を測定する指定された文字を含むオブジェクト。

### <a name="return-value"></a>戻り値

文字列 (論理単位) でのディメンションを[CSize](../../atl-mfc-shared/reference/csize-class.md)オブジェクト。

### <a name="remarks"></a>Remarks

文字列の幅がで指定されたタブ ストップをに基づいて、文字列に 1 つまたは複数のタブ文字が含まれている場合*いる*します。 関数では、現在選択されているフォントを使用して、文字列の大きさを計算します。

幅と高さによって返される現在のクリップ領域がオフセットされません、`GetOutputTabbedTextExtent`関数。

一部のデバイスは通常のセル配列に文字を配置しないので (つまり、カーニング、文字の場合)、文字列内の文字のエクステントの合計は、文字列の範囲と等しいできない可能性があります。

場合*nTabPositions*は 0 と*いる*が null の場合、タブは 8 つの平均文字幅を展開します。 場合*nTabPositions*は 1 です。 タブ ストップが先の配列の最初の値で指定された距離で区切られる*いる*ポイント。 場合*いる*ポイントを複数の単一の値をタブ ストップで指定された数まで、配列内の各値の設定は*nTabPositions*します。

##  <a name="getoutputtextextent"></a>  CDC::GetOutputTextExtent

出力デバイス コンテキストを使用するには、このメンバー関数を呼び出す[m_hDC](#m_hdc)幅と現在のフォントを使用して、テキストの行の高さを計算します。

```
CSize GetOutputTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetOutputTextExtent(const CString& str) const;
```

### <a name="parameters"></a>パラメーター

*lpszString*<br/>
文字の文字列を指します。 渡すことも、 [CString](../../atl-mfc-shared/reference/cstringt-class.md)このパラメーターのオブジェクト。

*nCount*<br/>
文字列の文字数を指定します。 場合*nCount* -1 で、長さが計算されます。

*str*<br/>
A`CString`を測定する指定された文字を含むオブジェクト。

### <a name="return-value"></a>戻り値

返される文字列 (論理単位) でのディメンションを[CSize](../../atl-mfc-shared/reference/csize-class.md)オブジェクト。

### <a name="remarks"></a>Remarks

現在のクリップ領域には影響しません、幅と高さがによって返される`GetOutputTextExtent`します。

一部のデバイスは通常のセル配列に文字を配置しないので (つまり、カーニングが実行される)、文字列内の文字のエクステントの合計は、文字列の範囲と等しいできない可能性があります。

##  <a name="getoutputtextmetrics"></a>  CDC::GetOutputTextMetrics

現在のフォントを使用するためのメトリックを取得`m_hDC`、出力デバイス コンテキスト。

```
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>パラメーター

*lpMetrics*<br/>
指す、[受け取る](/windows/desktop/api/wingdi/ns-wingdi-tagtextmetrica)メトリックを受信する構造体。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

##  <a name="getpath"></a>  CDC::GetPath

行の端点と、デバイス コンテキストに選択されているパスに曲線の制御点を定義する座標を取得します。

```
int GetPath(
    LPPOINT lpPoints,
    LPBYTE lpTypes,
    int nCount) const;
```

### <a name="parameters"></a>パラメーター

*lpPoints*<br/>
配列を指す[ポイント](/windows/desktop/api/windef/ns-windef-tagpoint)データ構造体または`CPoint`線の端点と曲線コントロール ポイントのオブジェクトが配置されます。

*lpTypes*<br/>
頂点の型が配置されているバイトの配列を指します。 値は、次のいずれかです。

- 直前には、特定の時点、対応することを指定*lpPoints*不整合のある図から開始します。

- PT_LINETO では、前のポイントと、対応するポイントのことを指定します*lpPoints*行のエンドポイントします。

- PT_BEZIERTO では、特定の時点、対応することを指定します*lpPoints*ベジエ曲線の制御点または終了します。

PT_BEZIERTO 型は、3 つのセットで常に発生します。 その前にすぐに、パス内のポイントは、ベジエ曲線の開始点を定義します。 PT_BEZIERTO の最初の 2 つのポイントは、管理ポイントと 3 番目の PT_BEZIERTO ポイントは、終点 (場合ハード コーディングされた)。

   PT_LINETO または PT_BEZIERTO 型は、次のフラグと組み合わせることも (ビットごとの演算子を使用して**OR**) に対応する点が、図の最後の点であり、図を閉じる必要があります。

- PT_CLOSEFIGURE では、図が対応する行の後に自動的に閉じられますまたは曲線を描画するを指定します。 図は、最後の直前に対応する点を直線または曲線のエンドポイントから行を描画することによって閉じられます。

*nCount*<br/>
合計数を指定します[ポイント](/windows/desktop/api/windef/ns-windef-tagpoint)内に配置できるデータ構造、 *lpPoints*配列。 この値に格納できるバイト数と同じである必要があります、 *lpTypes*配列。

### <a name="return-value"></a>戻り値

場合、 *nCount*パラメーターが 0 以外の場合、列挙されたポイントの数。 場合*nCount*が 0 の場合、パス内の地点の合計数 (と`GetPath`nothing をバッファーに書き込みます)。 場合*nCount*が 0 以外で、ポイントの数より少なく、パスでは、戻り値は-1 です。

### <a name="remarks"></a>Remarks

デバイス コンテキストでは、閉じたパスを含める必要があります。 論理座標では、パスのポイントが返されます。 ポイントは、そのため、デバイス座標のパスに保存`GetPath`デバイス座標から論理座標に現在の変換の逆関数を使用して、ポイントを変更します。 `FlattenPath`する前に、メンバー関数を呼び出すことができます`GetPath`、直線セグメントでは、パス内のすべての曲線に変換します。

### <a name="example"></a>例

  例をご覧ください[cdc::beginpath](#beginpath)します。

##  <a name="getpixel"></a>  CDC::GetPixel

指定された時点で、ピクセルの RGB 色の値を取得します。 *x*と*y*します。

```
COLORREF GetPixel(
    int x,
    int y) const;

COLORREF GetPixel(POINT point) const;
```

### <a name="parameters"></a>パラメーター

*x*<br/>
論理で調査する点の x 座標を指定します。

*y*<br/>
論理で調査する点の y 座標を指定します。

*ポイント*<br/>
調査する点の論理 x 座標と y 座標を指定します。

### <a name="return-value"></a>戻り値

指定したポイントの色の RGB カラー値、関数のいずれかのバージョン。 座標はクリッピング領域で、ポイントを指定しない場合は-1 になります。

### <a name="remarks"></a>Remarks

クリッピング領域で、ポイントがある必要があります。 クリッピング領域で、ポイントがない場合、関数は影響を与えませんし、-1 を返します。

一部のデバイスでは、`GetPixel` 関数がサポートされていません。 詳細については、RC_BITBLT ラスター機能を参照してください、[調べるため](#getdevicecaps)メンバー関数。

`GetPixel`メンバー関数が 2 つの形式。 1 つ目は 2 つの座標値。2 つ目は、いずれかを[ポイント](/windows/desktop/api/windef/ns-windef-tagpoint)構造または[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)オブジェクト。

##  <a name="getpolyfillmode"></a>  CDC::GetPolyFillMode

現在の多角形の塗りつぶしモードを取得します。

```
int GetPolyFillMode() const;
```

### <a name="return-value"></a>戻り値

現在多角形で塗りつぶされたモード、代替または巻き戻し、関数が成功した場合。

### <a name="remarks"></a>Remarks

参照してください、`SetPolyFillMode`多角形の塗りつぶしモードの説明については、メンバー関数。

##  <a name="getrop2"></a>  CDC::GetROP2

現在の描画モードを取得します。

```
int GetROP2() const;
```

### <a name="return-value"></a>戻り値

描画モード。 描画モードの値については、次を参照してください。、`SetROP2`メンバー関数。

### <a name="remarks"></a>Remarks

描画モードでは、既に、表示画面上の色でペンの色と塗りつぶされたオブジェクトの内部を結合する方法を指定します。

##  <a name="getsafehdc"></a>  CDC::GetSafeHdc

取得するには、このメンバー関数を呼び出す[m_hDC](#m_hdc)、出力デバイス コンテキスト。

```
HDC GetSafeHdc() const;
```

### <a name="return-value"></a>戻り値

デバイス コンテキストのハンドル。

### <a name="remarks"></a>Remarks

このメンバー関数は、null ポインターでも機能します。

##  <a name="getstretchbltmode"></a>  CDC::GetStretchBltMode

現在のビットマップの伸縮モードを取得します。

```
int GetStretchBltMode() const;
```

### <a name="return-value"></a>戻り値

戻り値が現在のビットマップの伸縮モードを指定します: STRETCH_ANDSCANS、STRETCH_DELETESCANS、または終了した、関数が成功した場合。

### <a name="remarks"></a>Remarks

ビットマップの伸縮モードでは、拡大またはで圧縮されているビットマップから情報を削除する方法を定義、`StretchBlt`メンバー関数。

STRETCH_ANDSCANS および終了したモードは通常、モノクロ ビットマップのピクセルをフォア グラウンドを保持するために使用されます。 STRETCH_DELETESCANS モードは通常、カラー ビットマップの色を保持するために使用されます。

##  <a name="gettabbedtextextent"></a>  CDC::GetTabbedTextExtent

幅と高さを文字の文字列の使用を計算するには、このメンバー関数を呼び出す[は](#m_hattribdc)属性のデバイス コンテキスト。

```
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>パラメーター

*lpszString*<br/>
文字の文字列を指します。 渡すことも、 [CString](../../atl-mfc-shared/reference/cstringt-class.md)このパラメーターのオブジェクト。

*nCount*<br/>
文字列の文字数を指定します。 場合*nCount* -1 で、長さが計算されます。

*nTabPositions*<br/>
指す配列内のタブ ストップの位置の数を指定します*いる*します。

*いる*<br/>
論理ユニットのタブ ストップの位置を格納している整数の配列を指します。 タブ ストップを昇順に並べ替え; 並べ替える必要があります。x の最小値、配列の最初の項目があります。 バック タブを指定することはできません。

*str*<br/>
A`CString`を描画する指定された文字を含むオブジェクト。

### <a name="return-value"></a>戻り値

文字列 (論理単位) でのディメンションを[CSize](../../atl-mfc-shared/reference/csize-class.md)オブジェクト。

### <a name="remarks"></a>Remarks

文字列の幅がで指定されたタブ ストップをに基づいて、文字列に 1 つまたは複数のタブ文字が含まれている場合*いる*します。 関数では、現在選択されているフォントを使用して、文字列の大きさを計算します。

幅と高さによって返される現在のクリップ領域がオフセットされません、`GetTabbedTextExtent`関数。

一部のデバイスは通常のセル配列に文字を配置しないので (つまり、カーニング、文字の場合)、文字列内の文字のエクステントの合計は、文字列の範囲と等しいできない可能性があります。

場合*nTabPositions*は 0 と*いる*が null の場合、タブは、平均文字幅の 8 倍に拡張されます。 場合*nTabPositions*は 1 です。 タブ ストップが先の配列の最初の値で指定された距離で区切られる*いる*ポイント。 場合*いる*ポイントを複数の単一の値をタブ ストップで指定された数まで、配列内の各値の設定は*nTabPositions*します。

##  <a name="gettextalign"></a>  CDC::GetTextAlign

デバイス コンテキストのテキスト配置フラグの状態を取得します。

```
UINT GetTextAlign() const;
```

### <a name="return-value"></a>戻り値

テキストの配置のフラグの状態です。 戻り値は、次の値の 1 つ以上には。

- X 軸と外接する四角形内で選択したフォントのベースラインの TA_BASELINE を指定の配置です。

- X 軸の外接する四角形の下部にある TA_BOTTOM を指定の配置。

- 外接する四角形の中心と y 軸の配置を TA_CENTER を指定します。

- Y 軸の外接する四角形の左側にある配置を TA_LEFT を指定します。

- TA_NOUPDATECP では、現在の位置が更新されないことを指定します。

- 外接する四角形の右端と y 軸の配置を TA_RIGHT を指定します。

- 外接する四角形の上端と x 軸の配置を TA_TOP を指定します。

- TA_UPDATECP では、現在の位置が更新されたことを指定します。

### <a name="remarks"></a>Remarks

テキスト配置フラグを決定する方法、`TextOut`と`ExtTextOut`メンバー関数は、文字列の開始点に対するテキストの文字列を配置します。 テキスト配置フラグでは、必ずしも単一のビット フラグではなく、0 に等しい場合があります。 フラグが設定されているかどうかをテストするには、アプリケーションは以下の手順を実行する必要があります。

1. フラグとその関連フラグの次のようにグループ化にビットごとの OR 演算子が適用されます。

    - TA_LEFT、TA_CENTER、および TA_RIGHT

    - TA_BASELINE、TA_BOTTOM、および TA_TOP

    - TA_NOUPDATECP と TA_UPDATECP

1. ビットごとの適用- と演算子の戻り値と`GetTextAlign`します。

1. この結果とフラグが等しいかどうかをテストします。

##  <a name="gettextcharacterextra"></a>  CDC::GetTextCharacterExtra

現在の文字間隔の設定を取得します。

```
int GetTextCharacterExtra() const;
```

### <a name="return-value"></a>戻り値

文字間隔の量。

### <a name="remarks"></a>Remarks

GDI は、デバイス コンテキストに 1 行のテキストを書き込む際に、改行文字を含む、各文字に、この間隔を追加します。

文字間隔の既定値は 0 です。

##  <a name="gettextcolor"></a>  CDC::GetTextColor

現在のテキストの色を取得します。

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>戻り値

RGB 色の値として現在のテキストの色。

### <a name="remarks"></a>Remarks

テキストの色は、GDI のテキスト出力のメンバー関数を使用して描画される文字の前景色[TextOut](#textout)、 [ExtTextOut](#exttextout)、および[TabbedTextOut](#tabbedtextout)します。

##  <a name="gettextextent"></a>  CDC::GetTextExtent

幅の大きさを現在のフォントを使用してテキストの行の高さを計算するには、このメンバー関数を呼び出します。

```
CSize GetTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetTextExtent(const CString& str) const;
```

### <a name="parameters"></a>パラメーター

*lpszString*<br/>
文字の文字列を指します。 渡すことも、 [CString](../../atl-mfc-shared/reference/cstringt-class.md)このパラメーターのオブジェクト。

*nCount*<br/>
文字列の文字数を指定します。

*str*<br/>
A`CString`の指定した文字を含むオブジェクト。

### <a name="return-value"></a>戻り値

文字列 (論理単位) でのディメンションを[CSize](../../atl-mfc-shared/reference/csize-class.md)オブジェクト。

### <a name="remarks"></a>Remarks

情報の取得から[は](#m_hattribdc)属性のデバイス コンテキスト。

既定では、`GetTextExtent`を水平方向の寸法を取得するテキストが設定されている前提としています (つまり、escapement は 0)。 0 以外の文字送りを指定するフォントを作成する場合は、文字列の寸法を取得するには、明示的にテキストの角度を変換する必要があります。

現在のクリップ領域には影響しません、幅と高さがによって返される`GetTextExtent`します。

一部のデバイスは通常のセル配列に文字を配置しないので (つまり、カーニングが実行される)、文字列内の文字のエクステントの合計は、文字列の範囲と等しいできない可能性があります。

##  <a name="gettextextentexpointi"></a>  CDC::GetTextExtentExPointI

指定した領域内に収まるし、それらの各文字の配列をテキスト範囲で設定を指定した文字列の文字数を取得します。

```
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,
    int cgi,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT alpDx,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>パラメーター

*pgiIn*<br/>
エクステントが取得するのには、グリフのインデックスの配列へのポインター。

*cgi*<br/>
指す配列のグリフ数を指定*pgiIn*します。

*nMaxExtent*<br/>
論理ユニットは、書式設定された文字列の許容される最大の幅を指定します。

*lpnFit*<br/>
指定された領域に収まる文字の最大数のカウントを受け取る整数へのポインター *nMaxExtent*します。 ときに*lpnFit*が null の場合、 *nMaxExtent*は無視されます。

*alpDx*<br/>
部分的なグリフのエクステントを受信する整数の配列へのポインター。 配列内の各要素は、グリフのインデックスの配列の先頭とで指定された領域に適合するグリフの 1 つの間の論理単位の距離*nMaxExtent*します。 この配列で指定されたグリフ インデックスとして少なくとも同じ数の要素を用意する必要があります*cgi*、配列で指定された数のグリフ インデックスのみのエクステントを埋める*lpnFit*します。 場合*lpnDx*が null の場合、関数は文字列の一部の幅が計算されません。

*lpSize*<br/>
ポインターを[サイズ](/windows/desktop/api/windef/ns-windef-tagsize)論理単位でのグリフのインデックスの配列のサイズを受け取る構造体。 この値は NULL をすることはできません。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

このメンバー関数は、関数の機能をエミュレート[GetTextExtentExPointI](/windows/desktop/api/wingdi/nf-wingdi-gettextextentexpointi)」の説明に従って、Windows SDK。

##  <a name="gettextextentpointi"></a>  CDC::GetTextExtentPointI

幅と高さのグリフのインデックスの指定した配列を取得します。

```
BOOL GetTextExtentPointI(
    LPWORD pgiIn,
    int cgi,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>パラメーター

*pgiIn*<br/>
エクステントが取得するのには、グリフのインデックスの配列へのポインター。

*cgi*<br/>
指す配列のグリフ数を指定*pgiIn*します。

*lpSize*<br/>
ポインターを[サイズ](/windows/desktop/api/windef/ns-windef-tagsize)論理単位でのグリフのインデックスの配列のサイズを受け取る構造体。 この値は NULL をすることはできません。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

このメンバー関数は、関数の機能をエミュレート[GetTextExtentPointI](/windows/desktop/api/wingdi/nf-wingdi-gettextextentpointi)」の説明に従って、Windows SDK。

##  <a name="gettextface"></a>  CDC::GetTextFace

現在のフォントのタイプフェイス名をバッファーにコピーするには、このメンバー関数を呼び出します。

```
int GetTextFace(
    int nCount,
    LPTSTR lpszFacename) const;

int GetTextFace(CString& rString) const;
```

### <a name="parameters"></a>パラメーター

*nCount*<br/>
バイト単位のバッファーのサイズを指定します。 タイプフェイス名がこのパラメーターで指定したバイト数よりも長い場合は、名前は切り捨てられます。

*lpszFacename*<br/>
タイプフェイス名を受け取るバッファーへのポインター。

*rString*<br/>
参照を[CString](../../atl-mfc-shared/reference/cstringt-class.md)オブジェクト。

### <a name="return-value"></a>戻り値

終端の null 文字を含まない、バッファーにコピーされたバイト数。 エラーが発生した場合は 0 になります。

### <a name="remarks"></a>Remarks

タイプフェイス名は、null で終わる文字列としてコピーされます。

##  <a name="gettextmetrics"></a>  CDC::GetTextMetrics

属性のデバイス コンテキストを使用して現在のフォントのメトリックを取得します。

```
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>パラメーター

*lpMetrics*<br/>
指す、[受け取る](/windows/desktop/api/wingdi/ns-wingdi-tagtextmetrica)メトリックを受信する構造体。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

##  <a name="getviewportext"></a>  CDC::GetViewportExt

デバイス コンテキストのビューポートの x 範囲と y 範囲を取得します。

```
CSize GetViewportExt() const;
```

### <a name="return-value"></a>戻り値

X と y-範囲範囲 (デバイス単位) として、`CSize`オブジェクト。

##  <a name="getviewportorg"></a>  CDC::GetViewportOrg

デバイス コンテキストに関連付けられた、ビューポートの原点の x 座標と y 座標を取得します。

```
CPoint GetViewportOrg() const;
```

### <a name="return-value"></a>戻り値

ビューポート (デバイス座標) での配信元を`CPoint`オブジェクト。

##  <a name="getwindow"></a>  CDC::GetWindow

ディスプレイ デバイス コンテキストに関連付けられているウィンドウを返します。

```
CWnd* GetWindow() const;
```

### <a name="return-value"></a>戻り値

ポインター、`CWnd`成功。 それ以外の場合に NULL の場合は、オブジェクト。

### <a name="remarks"></a>Remarks

これは、高度な関数です。 たとえば、このメンバー関数を印刷するとき、または印刷プレビューでビュー ウィンドウを返しません可能性があります。 常に、出力に関連付けられているウィンドウを返します。 特定の DC を使用する出力関数は、このウィンドウに描画します。

##  <a name="getwindowext"></a>  CDC::GetWindowExt

デバイス コンテキストに関連付けられているウィンドウの x 範囲と y 範囲を取得します。

```
CSize GetWindowExt() const;
```

### <a name="return-value"></a>戻り値

X と y-範囲範囲 (論理単位) として、`CSize`オブジェクト。

##  <a name="getwindoworg"></a>  CDC::GetWindowOrg

デバイス コンテキストに関連付けられているウィンドウの原点の x 座標と y 座標を取得します。

```
CPoint GetWindowOrg() const;
```

### <a name="return-value"></a>戻り値

(論理座標) をウィンドウとしての原点を`CPoint`オブジェクト。

##  <a name="getworldtransform"></a>  CDC::GetWorldTransform

ページ領域の変換を現在のワールド空間を取得します。

```
BOOL GetWorldTransform(XFORM& rXform) const;
```

### <a name="parameters"></a>パラメーター

*rXform*<br/>
参照、 [XFORM](/windows/desktop/api/wingdi/ns-wingdi-tagxform)ページ領域の変換を現在のワールド空間を受信する構造体。

### <a name="return-value"></a>戻り値

成功した場合に、0 以外の値を返します。

失敗した場合は 0 を返します。

拡張エラー情報を取得するには呼び出します[GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360)します。

### <a name="remarks"></a>Remarks

このメソッドは、Windows GDI 関数をラップ[GetWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-getworldtransform)します。

##  <a name="gradientfill"></a>  CDC::GradientFill

四角形と三角形の構造体を他の 1 つの側からスムーズにフェードする色で塗りつぶすには、このメンバー関数を呼び出します。

```
BOOL GradientFill(
    TRIVERTEX* pVertices,
    ULONG nVertices,
    void* pMesh,
    ULONG nMeshElements,
    DWORD dwMode);
```

### <a name="parameters"></a>パラメーター

*pVertices*<br/>
配列を指すポインター [TRIVERTEX](/windows/desktop/api/wingdi/ns-wingdi-_trivertex)構造体の三角形の頂点を定義します。

*nVertices*<br/>
頂点の数。

*pMesh*<br/>
配列[場合は](/windows/desktop/api/wingdi/ns-wingdi-_gradient_triangle)三角形のモード、または配列の構造体[GRADIENT_RECT](/windows/desktop/api/wingdi/ns-wingdi-_gradient_rect)四角形のモードでの構造体。

*nMeshElements*<br/>
内の要素 (三角形または四角形) の数*pMesh*します。

*dwMode*<br/>
グラデーションの塗りつぶしモードを指定します。 使用可能な値の一覧は、次を参照してください。 [GradientFill](/windows/desktop/api/wingdi/nf-wingdi-gradientfill) Windows SDK に含まれています。

### <a name="return-value"></a>戻り値

成功した場合は TRUE、それ以外の場合は FALSE。

### <a name="remarks"></a>Remarks

詳細については、次を参照してください。 `GradientFill` Windows SDK に含まれています。

##  <a name="graystring"></a>  CDC::GrayString

描画では、メモリ ビットマップ内のテキストを書き込む、暗転、ビットマップ、および表示するビットマップをコピーして、指定した場所にある (灰色) のテキストが淡色表示されます。

```
virtual BOOL GrayString(
    CBrush* pBrush,
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),
    LPARAM lpData,
    int nCount,
    int x,
    int y,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>パラメーター

*pBrush*<br/>
淡色 (灰色表示) に使用するブラシを識別します。

*lpfnOutput*<br/>
文字列を描画するアプリケーションによって提供されるコールバック関数、プロシージャ インスタンスのアドレスを指定します。 詳細については、Windows の説明を参照してください。 `OutputFunc` [コールバック関数](callback-functions-used-by-mfc.md#graystring)します。 このパラメーターが NULL の場合、システムは、Windows を使用して`TextOut`関数、文字列を描画するために、 *lpData*出力する文字の文字列への long ポインターと見なされます。

*lpData*<br/>
出力関数に渡されるデータへの far ポインターを指定します。 場合*lpfnOutput*が null の場合、 *lpData*出力する文字列への long ポインターである必要があります。

*nCount*<br/>
出力する文字数を指定します。 このパラメーターが 0 の場合`GrayString`文字列の長さを計算します (仮定*lpData*文字列へのポインターです)。 場合*nCount* -1 とによって示される関数は、 *lpfnOutput*返します 0 の場合、イメージが表示が淡色表示にします。

*x*<br/>
論理で文字列を囲む四角形の開始位置の x 座標を指定します。

*y*<br/>
論理で文字列を囲む四角形の開始位置の y 座標を指定します。

*nWidth*<br/>
文字列を囲む四角形の幅を (論理単位) で指定します。 場合*nWidth*は 0 です。`GrayString`領域の幅を計算すると仮定すると*lpData*文字列へのポインターです。

*nHeight*<br/>
文字列を囲む四角形の高さを (論理単位) で指定します。 場合*パラメーター nHeight*は 0 です。 `GrayString` 、領域の高さを計算すると仮定すると*lpData*文字列へのポインターです。

### <a name="return-value"></a>戻り値

文字列を描画する場合は 0 以外またはいずれかの場合は 0、`TextOut`関数または出力のアプリケーションによって提供される関数に 0 が返されるのと、暗転メモリ ビットマップを作成する十分なメモリがあった場合、または。

### <a name="remarks"></a>Remarks

関数には、選択したブラシとバック グラウンドに関係なく、テキストが使用できなくなります。 `GrayString`メンバー関数は、現在選択されているフォントを使用します。 MM_TEXT のマッピング モードは、この関数を使用する前に選択する必要があります。

淡色表示 (灰色表示) の文字列を呼び出さずに純色の灰色をサポートするデバイスで描画する、`GrayString`メンバー関数。 システム カラーでは、無効なテキストを描画するために使用されるソリッド灰色のシステム カラーです。 アプリケーションが呼び出すことができます、 `GetSysColor` Windows での色の値を取得します。 色が 0 (黒) 以外の場合、アプリケーションを呼び出すことができます、`SetTextColor`メンバー関数は、テキストの色を色の値に設定し、文字列を直接描画できます。 取得された色が黒の場合、アプリケーションを呼び出す必要があります`GrayString`(灰色) の明るさを抑えるテキスト。

場合*lpfnOutput*が null の場合、GDI は、Windows を使用して[TextOut](/windows/desktop/api/wingdi/nf-wingdi-textouta)関数、および*lpData*出力する文字への far ポインターと見なされます。 によって出力される文字を処理できないかどうか、`TextOut`メンバー関数 (たとえば、文字列はビットマップとして)、アプリケーションが独自の出力関数を指定する必要があります。

また、すべてのコールバック関数がコールバックの境界を越えて例外をスローすることはできませんので、Windows に戻る前に Microsoft Foundation 例外をトラップする必要がありますに注意してください。 例外の詳細については、記事を参照してください。[例外](../../mfc/exception-handling-in-mfc.md)します。

渡されるコールバック関数`GrayString`を使用する必要があります、`__stdcall`呼び出し規約とと共にエクスポートする必要があります`__declspec`します。

フレームワークは、プレビュー モードへの呼び出しの場合、`GrayString`にメンバー関数が変換された、`TextOut`呼び出しとコールバック関数は呼び出されません。

##  <a name="himetrictodp"></a>  CDC::HIMETRICtoDP

OLE から HIMETRIC のサイズをピクセルに変換する場合は、この関数を使用します。

```
void HIMETRICtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>パラメーター

*lpSize*<br/>
指す、[サイズ](/windows/desktop/api/windef/ns-windef-tagsize)構造または[CSize](../../atl-mfc-shared/reference/csize-class.md)オブジェクト。

### <a name="remarks"></a>Remarks

デバイス コンテキスト オブジェクトのマッピング モードが MM_LOENGLISH、MM_HIENGLISH、MM_LOMETRIC または MM_HIMETRIC の場合は、インチの物理ピクセルの数に変換がベースします。 マッピング モードが他の非強制モード (MM_TEXT) のいずれかの場合は、論理インチのピクセルの数に変換がベースします。

##  <a name="himetrictolp"></a>  CDC::HIMETRICtoLP

HIMETRIC 単位を論理単位に変換するには、この関数を呼び出します。

```
void HIMETRICtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>パラメーター

*lpSize*<br/>
指す、[サイズ](/windows/desktop/api/windef/ns-windef-tagsize)構造または[CSize](../../atl-mfc-shared/reference/csize-class.md)オブジェクト。

### <a name="remarks"></a>Remarks

OLE から HIMETRIC のサイズを取得し、アプリケーションの自然な割り当てモードに変換する場合は、この関数を使用します。

変換は、まず HIMETRIC 単位をピクセルに変換して、デバイス コンテキストの現在のマップの単位を使用して論理ユニットにこれらのユニットを変換して実行されます。 デバイスのウィンドウ、ビューポートのエクステントが結果に影響することに注意してください。

##  <a name="intersectcliprect"></a>  CDC::IntersectClipRect

現在のリージョンとで指定された四角形の交差部分を形成して新しいクリップ領域を作成します*x1*、 *y1*、 *x2*、および*y2*.

```
int IntersectClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int IntersectClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>パラメーター

*x1*<br/>
四角形の左上隅の x の論理座標を指定します。

*y1*<br/>
論理で四角形の左上隅の y 座標を指定します。

*x2*<br/>
論理で四角形の右上隅の x 座標を指定します。

*y2*<br/>
論理で四角形の右上隅の y 座標を指定します。

*lpRect*<br/>
四角形を指定します。 いずれかを渡すことができます、`CRect`オブジェクトまたはへのポインターを`RECT`このパラメーターの構造体。

### <a name="return-value"></a>戻り値

新しいクリップ領域の種類。 次の値のいずれかを指定できます。

- 新しい COMPLEXREGION のクリッピング領域には、重なり合った境界線。

- デバイス コンテキストのエラーが無効です。

- 新しい NULLREGION のクリッピング領域が空です。

- 新しい SIMPLEREGION のクリッピング領域には、重複する境界線がありません。

### <a name="remarks"></a>Remarks

GDI は、新しい境界内に収まるすべての後の出力をクリップします。 幅と高さは、32,767 を超えましていない必要があります。

##  <a name="invertrect"></a>  CDC::InvertRect

指定した四角形の内容を反転します。

```
void InvertRect(LPCRECT lpRect);
```

### <a name="parameters"></a>パラメーター

*lpRect*<br/>
指す、`RECT`反転される四角形の論理座標を格納しています。 渡すことも、`CRect`このパラメーターのオブジェクト。

### <a name="remarks"></a>Remarks

反転は論理操作と各ピクセルのビットを反転できません。 モノクロ モニターで、関数は、黒と黒のピクセルの白いピクセル白。 色が表示されたら、反転表示の色を生成する方法に依存します。 呼び出す`InvertRect`同じ四角形で 2 回の色を前に、表示を復元します。

四角形が空の場合は何も描画されます。

### <a name="example"></a>例

[!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]

##  <a name="invertrgn"></a>  CDC::InvertRgn

指定された領域の色を反転*pRgn*します。

```
BOOL InvertRgn(CRgn* pRgn);
```

### <a name="parameters"></a>パラメーター

*pRgn*<br/>
反転する領域を識別します。 領域の座標は、論理単位で指定されます。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

モノクロ モニターで、関数は、黒と黒のピクセルの白いピクセル白。 色が表示されたら、反転表示の色を生成する方法に依存します。

##  <a name="isprinting"></a>  CDC::IsPrinting

印刷デバイス コンテキストが使用されているかどうかを判断します。

```
BOOL IsPrinting() const;
```

### <a name="return-value"></a>戻り値

0 以外の値、`CDC`オブジェクトはプリンター DC。 それ以外の場合、0。

##  <a name="lineto"></a>  CDC::LineTo

現在の位置が、指定した点、線を描画します*x*と*y* (または*ポイント*)。

```
BOOL LineTo(
    int x,
    int y);

BOOL LineTo(POINT point);
```

### <a name="parameters"></a>パラメーター

*x*<br/>
線の終点の論理の x 座標を指定します。

*y*<br/>
論理で線の終点の y 座標を指定します。

*ポイント*<br/>
線の終点を指定します。 いずれかを渡すことができます、`POINT`構造または`CPoint`このパラメーターのオブジェクト。

### <a name="return-value"></a>戻り値

線が描画された場合は 0 以外それ以外の場合 0 を返します。

### <a name="remarks"></a>Remarks

行は、選択されたペンで描画されます。 現在の位置に設定されている*x*、 *y*または*ポイント*します。

### <a name="example"></a>例

  例をご覧ください[CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint)します。

##  <a name="lptodp"></a>  CDC::LPtoDP

論理ユニットをデバイス単位に変換します。

```
void LPtoDP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>パラメーター

*lpPoints*<br/>
ポイントの配列を指します。 配列内の各ポイントは、[ポイント](/windows/desktop/api/windef/ns-windef-tagpoint)構造または[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)オブジェクト。

*nCount*<br/>
配列内の地点の数。

*lpRect*<br/>
指す、 [RECT](/windows/desktop/api/windef/ns-windef-tagrect)構造または[CRect](../../atl-mfc-shared/reference/crect-class.md)オブジェクト。 このパラメーターは、デバイス単位を論理座標から四角形のマッピングの一般的なケースで使用されます。

*lpSize*<br/>
指す、[サイズ](/windows/desktop/api/windef/ns-windef-tagsize)構造または[CSize](../../atl-mfc-shared/reference/csize-class.md)オブジェクト。

### <a name="remarks"></a>Remarks

関数は、各ポイントの座標またはデバイスの座標系に変換、GDI の論理座標システムから、サイズの大きさをマップします。 変換は、現在のマップ モード」および「配信元の設定とデバイスのウィンドウ ビューポートのエクステントによって異なります。

ポイントの x 座標と y 座標は、-32,768 ~ 32,767 の範囲内の 2 バイト符号付き整数です。 場所のマッピング モードが、これらの制限より大きい値になります。 の場合、システム値に設定-32,768 から 32,767、それぞれします。

##  <a name="lptohimetric"></a>  CDC::LPtoHIMETRIC

論理ユニットを HIMETRIC 単位に変換するには、この関数を呼び出します。

```
void LPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>パラメーター

*lpSize*<br/>
指す、`SIZE`構造または`CSize`オブジェクト。

### <a name="remarks"></a>Remarks

アプリケーションの自然な割り当てモードから変換する ole に HIMETRIC のサイズを指定すると、この関数を使用します。 デバイスのウィンドウ、ビューポートのエクステントが結果に影響することに注意してください。

変換は、デバイス コンテキストの現在のマッピング単位を使用して、これらのユニットを HIMETRIC 単位に変換するピクセルに論理ユニットを変換することによって実現されます。

##  <a name="m_hattribdc"></a>  CDC::m_hAttribDC

この属性のデバイス コンテキスト`CDC`オブジェクト。

```
HDC m_hAttribDC;
```

### <a name="remarks"></a>Remarks

既定では、このデバイス コンテキストと等しい`m_hDC`します。 一般に、`CDC`宛てのデバイス コンテキストから情報を要求する GDI 呼び出し`m_hAttribDC`します。 参照してください、 [CDC](../../mfc/reference/cdc-class.md)クラスのこれらの 2 つのデバイス コンテキストの使用について説明します。

##  <a name="m_hdc"></a>  CDC::m_hDC

この出力デバイス コンテキスト`CDC`オブジェクト。

```
HDC m_hDC;
```

### <a name="remarks"></a>Remarks

既定では、`m_hDC`と等しい`m_hAttribDC`、他のデバイス コンテキストによってラップされた`CDC`します。 一般に、 `CDC` GDI 呼び出しの出力を作成するには、`m_hDC`デバイス コンテキスト。 初期化するには`m_hDC`と`m_hAttribDC`さまざまなデバイスを指すようにします。 参照してください、 [CDC](../../mfc/reference/cdc-class.md)クラスのこれらの 2 つのデバイス コンテキストの使用について説明します。

##  <a name="maskblt"></a>  CDC::MaskBlt

指定したマスクとラスター オペレーションを使用してソースと変換先のビットマップのカラー データを結合します。

```
BOOL MaskBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    CBitmap& maskBitmap,
    int xMask,
    int yMask,
    DWORD dwRop);
```

### <a name="parameters"></a>パラメーター

*x*<br/>
先の四角形の左上隅の x の論理座標を指定します。

*y*<br/>
先の四角形の左上隅の y の論理座標を指定します。

*nWidth*<br/>
論理ユニットは、コピー先の四角形と元のビットマップの幅を指定します。

*nHeight*<br/>
論理ユニットは、コピー先の四角形と元のビットマップの高さを指定します。

*pSrcDC*<br/>
ビットマップのコピー元デバイス コンテキストを識別します。 場合は 0 をある必要があります、 *dwRop*パラメーターが、ソースが含まれていないラスター オペレーションを指定します。

*xSrc*<br/>
ソース ビットマップの左上隅の x の論理座標を指定します。

*ySrc*<br/>
ソース ビットマップの左上隅の y の論理座標を指定します。

*maskBitmap*<br/>
元のデバイス コンテキストのカラー ビットマップと組み合わせて、モノクロ マスク ビットマップを識別します。

*xMask*<br/>
指定されたマスク ビットマップのピクセルを水平方向のオフセットを指定します、 *maskBitmap*パラメーター。

*yMask*<br/>
指定されたマスク ビットマップのピクセルの垂直オフセットを指定します、 *maskBitmap*パラメーター。

*dwRop*<br/>
前景と背景三項ラスター オペレーション コード、ソースと変換先のデータの組み合わせを制御する関数を使用するを指定します。 バック グラウンドのラスター オペレーション コードがこの値の上位ワードの高位バイトに格納されています。フォア グラウンドのラスター オペレーション コードがこの値の上位ワードの下位バイトに格納されています。この値の下位ワードは無視され、0 にする必要があります。 MAKEROP4 マクロは、このような組み合わせの前景色と背景ラスター オペレーション コードを作成します。 前景色と背景がこの関数のコンテキストでの詳細については、「解説」を参照してください。 参照してください、`BitBlt`共通ラスター オペレーション コードの一覧については、メンバー関数。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

値 1 で指定されたマスクに*maskBitmap*によって、フォア グラウンドのラスター オペレーション コードが指定されていることを示します*dwRop*その場所に適用する必要があります。 マスク内の 0 の値は、バック グラウンドのラスター オペレーション コードがで指定されたことを示します*dwRop*その場所に適用する必要があります。 ラスター オペレーションは、ソースを必要とする場合、マスクの四角形には元の四角形する必要がありますについて説明します。 そうでない場合、関数は失敗します。 ラスター オペレーション、ソースが必要でない場合マスク四角形は先の四角形をカバーする必要があります。 そうでない場合、関数は失敗します。

この関数が呼び出されたときに、回転、または傾斜変換は元のデバイス コンテキストを有効になっている場合、エラーが発生します。 ただし、他の種類の変換は許可されます。

ソース、パターン、およびコピー先ビットマップの色形式が異なる場合、この関数は、パターンまたはソース形式、または変換先の形式に一致するように、両方を変換します。 マスクのビットマップがモノクロ ビットマップでない場合、エラーが発生します。 拡張メタファイルが記録されているときにエラーが発生した (および、0 を返します) 場合は、ソース デバイス コンテキスト拡張メタファイル デバイス コンテキストを識別します。 すべてのデバイスをサポートして`MaskBlt`します。 アプリケーションを呼び出す必要があります`GetDeviceCaps`をデバイスがこの関数をサポートしているかどうかを判断します。 この関数の動作と同様にマスク ビットマップを指定しない場合は`BitBlt`、フォア グラウンドのラスター オペレーション コードを使用します。 ピクセルのオフセットは、点 (0, 0) にマップするときのマスクのビットマップで、ソース デバイス コンテキストのビットマップ。 これは、マスクのビットマップにマスクのセットが含まれている場合に役立ちますアプリケーション簡単に適用、いずれかのマスクの中のタスクにピクセルのオフセットを調整することによってして四角形のサイズに送信される`MaskBlt`します。

##  <a name="modifyworldtransform"></a>  CDC::ModifyWorldTransform

指定されたモードを使用してデバイス コンテキストのワールド変換を変更します。

```
BOOL ModifyWorldTransform(
    const XFORM& rXform,
    DWORD iMode);
```

### <a name="parameters"></a>パラメーター

*rXform*<br/>
参照、 [XFORM](/windows/desktop/api/wingdi/ns-wingdi-tagxform)構造体の特定のデバイス コンテキストのワールド変換を変更するために使用します。

*i モード*<br/>
変換データが現在のワールド変換を変更する方法を指定します。 このパラメーターが取る値の一覧では、次を参照してください。 [ModifyWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-modifyworldtransform)します。

### <a name="return-value"></a>戻り値

成功した場合に、0 以外の値を返します。

失敗した場合は 0 を返します。

拡張エラー情報を取得するには呼び出します[GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360)します。

### <a name="remarks"></a>Remarks

このメソッドは、Windows GDI 関数をラップ[ModifyWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-modifyworldtransform)します。

##  <a name="moveto"></a>  CDC::MoveTo

指定されたポイントに現在の位置を移動*x*と*y* (または*ポイント*)。

```
CPoint MoveTo(
    int x,
    int y);

CPoint MoveTo(POINT point);
```

### <a name="parameters"></a>パラメーター

*x*<br/>
新しい位置の論理の x 座標を指定します。

*y*<br/>
新しい位置の論理の y 座標を指定します。

*ポイント*<br/>
新しい位置を指定します。 いずれかを渡すことができます、`POINT`構造または`CPoint`このパラメーターのオブジェクト。

### <a name="return-value"></a>戻り値

として前の位置の x 座標と y 座標を`CPoint`オブジェクト。

### <a name="example"></a>例

  例をご覧ください[CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint)します。

##  <a name="offsetcliprgn"></a>  CDC::OffsetClipRgn

指定されたオフセットで、デバイス コンテキストのクリッピング領域に移動します。

```
int OffsetClipRgn(
    int x,
    int y);

int OffsetClipRgn(SIZE size);
```

### <a name="parameters"></a>パラメーター

*x*<br/>
左に移動する論理ユニットの数を指定します。

*y*<br/>
上下に移動する論理ユニットの数を指定します。

*size*<br/>
オフセットする量を指定します。

### <a name="return-value"></a>戻り値

新しい領域の種類。 次の値のいずれかを指定できます。

- COMPLEXREGION クリッピング領域には、重なり合った境界線。

- デバイス コンテキストのエラーが無効です。

- NULLREGION クリッピング領域が空です。

- SIMPLEREGION クリッピング領域には、重複する境界がありません。

### <a name="remarks"></a>Remarks

関数は、リージョンを移動*x* x 軸に沿った単位と*y* y 軸に沿った単位。

##  <a name="offsetviewportorg"></a>  CDC::OffsetViewportOrg

現在のビューポートの原点の座標に対して相対的ビューポートの原点の座標を変更します。

```
virtual CPoint OffsetViewportOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>パラメーター

*nWidth*<br/>
現在の原点の x 座標に追加するデバイス単位の数を指定します。

*nHeight*<br/>
現在の原点の y 座標に追加するデバイス単位の数を指定します。

### <a name="return-value"></a>戻り値

前のビューポートの原点が (デバイス座標) でとしてを`CPoint`オブジェクト。

##  <a name="offsetwindoworg"></a>  CDC::OffsetWindowOrg

現在のウィンドウの原点の座標に対するウィンドウの原点の座標を変更します。

```
CPoint OffsetWindowOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>パラメーター

*nWidth*<br/>
現在の原点の x 座標に追加する論理ユニットの数を指定します。

*nHeight*<br/>
現在の原点の y 座標に追加する論理ユニットの数を指定します。

### <a name="return-value"></a>戻り値

前のウィンドウの原点が (論理座標) でとしてを`CPoint`オブジェクト。

##  <a name="operator_hdc"></a>  CDC::operator HDC

この演算子を使用してのデバイス コンテキスト ハンドルを取得する、`CDC`オブジェクト。

```
operator HDC() const;
```

### <a name="return-value"></a>戻り値

成功した場合、デバイス コンテキスト オブジェクトのハンドルそれ以外の場合は NULL です。

### <a name="remarks"></a>Remarks

ハンドルを使用して、Windows Api を直接呼び出すことができます。

##  <a name="paintrgn"></a>  CDC::PaintRgn

指定された領域を塗りつぶします*pRgn*現在のブラシを使用します。

```
BOOL PaintRgn(CRgn* pRgn);
```

### <a name="parameters"></a>パラメーター

*pRgn*<br/>
塗りつぶす領域を識別します。 指定された領域の座標は、論理単位で指定されます。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

##  <a name="patblt"></a>  CDC::PatBlt

デバイスには、ビット パターンを作成します。

```
BOOL PatBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>パラメーター

*x*<br/>
論理でパターンを受信する四角形の左上隅の x 座標を指定します。

*y*<br/>
論理でパターンを受信する四角形の左上隅の y 座標を指定します。

*nWidth*<br/>
(論理単位) で、パターンを受信する四角形の幅を指定します。

*nHeight*<br/>
(論理単位) で、パターンを受信する四角形の高さを指定します。

*dwRop*<br/>
ラスター オペレーション コードを指定します。 ラスター オペレーション コード (Rop) は、GDI による色、現在のブラシ、転送元のビットマップとコピー先ビットマップに関連する出力操作での結合方法を定義します。 このパラメーターには、次の値のいずれかを指定できます。

- コピー先ビットマップに PATCOPY コピー パターン。

- PATINVERT を組み合わせて、ブール型 XOR 演算子を使用してパターンを持つビットマップを変換先です。

- DSTINVERT では、コピー先のビットマップを反転します。

- すべての出力を黒黒になります。

- すべての出力を白 WHITENESS になります。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

パターンは、選択したブラシと、デバイスで既にパターンの組み合わせです。 指定されたラスター オペレーション コード*dwRop*に結合するパターンは、どのように定義します。 この関数の一覧表示するラスター オペレーションは、256 三項ラスター オペレーション コードの一部のサブセット具体的には、ソースを参照するラスター オペレーション コードは使用できません。

すべてのデバイス コンテキスト、`PatBlt`関数。 デバイス コンテキストをサポートしているかどうかを判断する`PatBlt`、呼び出し、`GetDeviceCaps`メンバー関数と RASTERCAPS インデックスと RC_BITBLT フラグの戻り値を確認します。

##  <a name="pie"></a>  CDC::Pie

中心と 2 つのエンドポイントが線で参加している楕円の円弧を描画することによって作られる扇形を描画します。

```
BOOL Pie(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>パラメーター

*x1*<br/>
(論理単位) に外接する四角形の左上隅の x 座標を指定します。

*y1*<br/>
(論理単位) に外接する四角形の左上隅の y 座標を指定します。

*x2*<br/>
(論理単位) に外接する四角形の右上隅の x 座標を指定します。

*y2*<br/>
(論理単位) に外接する四角形の右上隅の y 座標を指定します。

*x3*<br/>
(論理単位) での円弧の始点の x 座標を指定します。 このポイントは、円弧上正確にする必要はありません。

*y3*<br/>
(論理単位) での円弧の始点の y 座標を指定します。 このポイントは、円弧上正確にする必要はありません。

*x4*<br/>
(論理単位) での円弧の終点の x 座標を指定します。 このポイントは、円弧上正確にする必要はありません。

*y4*<br/>
(論理単位) での円弧の終点の y 座標を指定します。 このポイントは、円弧上正確にする必要はありません。

*lpRect*<br/>
外接する四角形を指定します。 いずれかを渡すことができます、`CRect`オブジェクトまたはへのポインターを`RECT`このパラメーターの構造体。

*ptStart*<br/>
円弧の始点を指定します。このポイントは、円弧上正確にする必要はありません。いずれかを渡すことができます、[ポイント](/windows/desktop/api/windef/ns-windef-tagpoint)構造または[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)このパラメーターのオブジェクト。

*ptEnd*<br/>
円弧の終点を指定します。このポイントは、円弧上正確にする必要はありません。いずれかを渡すことができます、`POINT`構造または`CPoint`このパラメーターのオブジェクト。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

円弧の中心で指定された外接する四角形の中心*x1*、 *y1*、 *x2*、および*y2* (または*lpRect*). 開始と円弧の終点がで指定された*x3*、 *y3*、 *x4*、および*y4* (または*ptStart*と*終点*)。

円弧が反時計回りに移動、選択されたペンで描画されます。 次の 2 行は、各エンドポイントから円弧の中央に描画されます。 扇形の領域は、現在のブラシで塗りつぶされます。 場合*x3* equals *x4*と*y3* equals *y4*楕円の中心からポイント (への単一行で楕円になります*x3*、 *y3*) または ( *x4*、 *y4*)。

この関数によって描画される図形はまで拡張しますが、右下隅の座標は含まれません。 つまり、図形の高さは*y2* - *y1* figure の幅は*x2* - *x1*します。 外接する四角形の高さと幅の両方は、2 つのユニットと 32,767 より小さい単位より大きくなければなりません。

### <a name="example"></a>例

[!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]

##  <a name="playmetafile"></a>  CDC::PlayMetaFile

デバイス コンテキストでは、指定されたメタファイルのコンテンツを再生します。

```
BOOL PlayMetaFile(HMETAFILE hMF);

BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,
    LPCRECT lpBounds);
```

### <a name="parameters"></a>パラメーター

*hMF*<br/>
再生するメタファイルを識別します。

*hEnhMetaFile*<br/>
拡張メタファイルを識別します。

*lpBounds*<br/>
指す、`RECT`構造または`CRect`画像を表示するために使用する外接する四角形の座標を格納しているオブジェクト。 座標は、論理単位で指定されます。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

メタファイルを何度でも再生できます。

2 番目のバージョンの`PlayMetaFile`特定の拡張形式メタファイルに格納されている画像が表示されます。 アプリケーションでの 2 番目のバージョンを呼び出すときに`PlayMetaFile`、Windows によって示される四角形に画像をマップする拡張メタファイル ヘッダー画像フレームを使用して、 *lpBounds*パラメーター。 (この図の傾斜またはワールド変換を呼び出す前に、出力デバイスに設定して回転が`PlayMetaFile`)。図では、四角形の辺に沿ったポイントが含まれます。 拡張メタファイルを再生する前に、出力デバイスでのクリッピング領域を定義することで、拡張メタファイル画像をクリップすることができます。

拡張メタファイルにオプションのパレットが含まれている場合、アプリケーションがの 2 番目のバージョンを呼び出す前に設定されているカラー パレットを出力デバイスにすることによって色の統一を実現できます`PlayMetaFile`します。 省略可能なパレットを取得する、 `GetEnhMetaFilePaletteEntries` Windows 関数。 拡張メタファイルを新しく作成された拡張メタファイルに埋め込みの 2 番目のバージョンを呼び出すことによって`PlayMetaFile`とメタファイルを強化する新しいデバイス コンテキストに元の拡張メタファイルを再生します。

この関数では、出力デバイス コンテキストの状態が保持されます。 この関数では、作成、拡張メタファイルでは削除されませんが、任意のオブジェクトが削除されます。 この関数を停止するアプリケーションを呼び出すことができます、`CancelDC`操作を終了する別のスレッドからの Windows 関数。 この場合、関数は、0 を返します。

##  <a name="plgblt"></a>  CDC::PlgBlt

指定されたデバイス コンテキストの指定した平行四辺形に元のデバイス コンテキストで指定した四角形から色データのビットのビット ブロック転送を実行します。

```
BOOL PlgBlt(
    LPPOINT lpPoint,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nWidth,
    int nHeight,
    CBitmap& maskBitmap,
    int xMask,
    int yMask);
```

### <a name="parameters"></a>パラメーター

*lpPoint*<br/>
先の平行四辺形の 3 つの角を識別する論理空間内の 3 つの点の配列を指します。 元の四角形の左上隅にあるは、この配列、2 番目の点で、この配列に右上隅および 3 番目のポイントを左上隅にある最初の要素にマップされます。 元の四角形の右上隅にあるは、暗黙の 4 番目のポイント、平行四辺形内にマップされます。

*pSrcDC*<br/>
元のデバイス コンテキストを識別します。

*xSrc*<br/>
論理ユニットは、元の四角形の左上隅の x 座標を指定します。

*ySrc*<br/>
論理ユニットは、元の四角形の左上隅の y 座標を指定します。

*nWidth*<br/>
論理ユニットは、元の四角形の幅を指定します。

*nHeight*<br/>
論理ユニットは、元の四角形の高さを指定します。

*maskBitmap*<br/>
元の四角形の色をマスクするために使用するオプションのモノクロ ビットマップを識別します。

*xMask*<br/>
モノクロのビットマップの左上隅の x 座標を指定します。

*yMask*<br/>
モノクロのビットマップの左上隅の y 座標を指定します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

指定されたビットマスク ハンドルは、有効なモノクロ ビットマップを識別する場合、関数はこのビットマップを使用して、元の四角形の色データのビット マスクします。

最初の 3 つを扱うことにより、平行四辺形 (D) の 4 番目の頂点が定義されているコンピューティング D ベクトルであり、ポイント (A、B、および C) = B + C - A.

ビットマスクが存在する場合、マスク内の 1 の値は、ソース ピクセルの色が変換先にコピーされることを示します。 マスク内の 0 の値は、コピー先のピクセルの色が、変更できないことを示します。

マスクの四角形が元とコピー先の四角形よりも小さい場合は、関数はマスク パターンをレプリケートします。

元のデバイス コンテキストでのスケーリング、翻訳、およびリフレクションの変換が許可されます。ただし、回転と傾斜変換がないです。 マスクのビットマップがモノクロ ビットマップでない場合、エラーが発生します。 コピー先のデバイス コンテキストの伸縮モードを使用して、必要がある場合は、拡大または (ピクセル単位) を圧縮する方法を決定します。 拡張メタファイルを記録中は、元のデバイス コンテキスト拡張メタファイル デバイス コンテキストを識別する場合に、エラーが発生します。

コピー先の座標は、コピー先デバイス コンテキストに従って変換されます。コピー元の座標は、コピー元デバイス コンテキストに従って変換されます。 ソースの変換は、回転、傾斜がある、エラーが返されます。 送信先と送信元の四角形が同じ色の書式を持たない場合`PlgBlt`先の四角形と一致するソース四角形に変換します。 すべてのデバイスをサポートして`PlgBlt`します。 詳細については、RC_BITBLT ラスター機能の説明を参照して、`CDC::GetDeviceCaps`メンバー関数。

元とコピー先デバイス コンテキストは、互換性のないデバイスを表す場合`PlgBlt`エラーが返されます。

##  <a name="polybezier"></a>  CDC::PolyBezier

1 つまたは複数のベジエ スプラインを描画します。

```
BOOL PolyBezier(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>パラメーター

*lpPoints*<br/>
配列を指す[ポイント](/windows/desktop/api/windef/ns-windef-tagpoint)エンドポイントおよびスプラインを制御するデータ構造体。

*nCount*<br/>
内の地点の数を指定します、 *lpPoints*配列。 この値は、スプラインを描画する数の 3 倍をいずれかに指定する必要があります、2 つの制御点と、エンドポイントと初期スプライン各ベジエ スプラインが必要なため、追加の開始点が必要です。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

この関数は、エンドポイントとで指定されたコントロール ポイントを使用して 3 次ベジエ スプラインを描画、 *lpPoints*パラメーター。 最初のスプラインは、制御点として、2 番目と 3 番目のポイントを使用して、最初の点から、4 番目の点に描画されます。 必要な 3 つの点をシーケンス内の各後続スプライン: 以前スプラインの終了点は、開始点として使用、シーケンス内の次の 2 つのポイントは制御点、および 3 番目は終点。

現在の位置が使用されるもによって更新、`PolyBezier`関数。 図が入力されていません。 この関数は、現在のペンを使用して線を描画します。

##  <a name="polybezierto"></a>  CDC::PolyBezierTo

1 つまたは複数のベジエ スプラインを描画します。

```
BOOL PolyBezierTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>パラメーター

*lpPoints*<br/>
配列を指す[ポイント](/windows/desktop/api/windef/ns-windef-tagpoint)エンドポイントとコントロールを含むデータ構造体をポイントします。

*nCount*<br/>
内の地点の数を指定します、 *lpPoints*配列。 この値は、各ベジエ スプラインは、2 つの制御点と終了ポイントが必要なために、スプラインを描画する数の 3 倍にすることがあります。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

この関数で指定されたコントロール ポイントを使用して 3 次ベジエ スプラインを描画、 *lpPoints*パラメーター。 最初のスプラインは、コントロール ポイントとして最初の 2 つのポイントを使用して、現在の位置から、3 番目のポイントに描画されます。 各後続のスプラインは、この関数は、3 つの点を必要があり、開始点として、次の前のスプラインの終了点を使用します。 `PolyBezierTo` 最後のベジエ スプラインの終了点には、現在の位置を移動します。 図が入力されていません。 この関数は、現在のペンを使用して線を描画します。

### <a name="example"></a>例

  例をご覧ください[cdc::beginpath](#beginpath)します。

##  <a name="polydraw"></a>  CDC::PolyDraw

一連の線分とベジエ スプラインを描画します。

```
BOOL PolyDraw(
    const POINT* lpPoints,
    const BYTE* lpTypes,
    int nCount);
```

### <a name="parameters"></a>パラメーター

*lpPoints*<br/>
配列を指す[ポイント](/windows/desktop/api/windef/ns-windef-tagpoint)ごとにエンドポイントを含むデータ構造が線のセグメントと、エンドポイントと各ベジエ スプラインのポイントを制御します。

*lpTypes*<br/>
各内のポイントを指定する配列を指す、 *lpPoints*配列を使用します。 値には、次のいずれかを指定できます。

- 直前では、このポイントが不整合のある図形を開始することを指定します。 この時点では、新しい現在位置になります。

- PT_LINETO では、行がこの時点で、新しい現在の位置となる現在の位置から描画されることを指定します。

- PT_BEZIERTO では、このポイントは、ベジエ スプラインの制御点または終了を指定します。

PT_BEZIERTO 型は、3 つのセットで常に発生します。 現在の位置は、ベジエ スプラインの開始点を定義します。 制御点は、最初の 2 つの PT_BEZIERTO ポイントは、3 番目の PT_BEZIERTO ポイントは、終了ポイント。 終了ポイントでは、新しい現在位置になります。 ない 3 つの連続する PT_BEZIERTO 点がある場合は、エラーが発生します。

   PT_LINETO または PT_BEZIERTO 型は、ビットごとの演算子を使用して次の定数と組み合わせることができますか、対応する点が、図と図の最後の点であることを示すが閉じられます。

- PT_CLOSEFIGURE の図は、PT_LINETO 後に自動的に閉じられるか、このポイントの PT_BEZIERTO 型が完了するを指定します。 行は、最新の直前にこの点から描画または`MoveTo`ポイントします。

   このフラグは行の場合、PT_LINETO 型とビットごとのベジエ スプラインの終点の PT_BEZIERTO 型**OR**演算子。 現在の位置は、終了行の終了点に設定されます。

*nCount*<br/>
内の地点の合計数を指定します、 *lpPoints*配列、バイト数と同じ、 *lpTypes*配列。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

この関数は、不整合のある図表を連続して呼び出す代わりに描画するために使用できます`CDC::MoveTo`、 `CDC::LineTo`、および`CDC::PolyBezierTo`メンバー関数。 行およびスプラインは、現在のペンを使用して描画し、図形は塗りつぶされていません。 呼び出しによって開始されたアクティブのパスがあるかどうか、`CDC::BeginPath`メンバー関数は、`PolyDraw`パスに追加します。 含まれているポイント、 *lpPoints*配列と*lpTypes*各ポイントがの一部であるかどうかを`CDC::MoveTo`、 `CDC::LineTo`、または`CDC::BezierTo`操作。 図形を閉じることもできます。 この関数は、現在の位置を更新します。

### <a name="example"></a>例

  例をご覧ください[cdc::beginpath](#beginpath)します。

##  <a name="polygon"></a>  CDC::Polygon

2 つ以上の点 (頂点)、現在のペンを使用して、行によって接続されているので構成される多角形を描画します。

```
BOOL Polygon(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>パラメーター

*lpPoints*<br/>
多角形の頂点を指定する点の配列を指します。 配列内の各ポイントは、`POINT`構造または`CPoint`オブジェクト。

*nCount*<br/>
配列内の頂点の数を指定します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

システム、多角形自動的に閉じます、必要に応じて、最後の頂点から最初の行を描画することで。

現在の多角形の塗りつぶしモードを取得または設定を使用して、`GetPolyFillMode`と`SetPolyFillMode`メンバー関数。

### <a name="example"></a>例

[!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]

##  <a name="polyline"></a>  CDC::Polyline

指定した点を結ぶ線分のセットを描画*lpPoints*します。

```
BOOL Polyline(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>パラメーター

*lpPoints*<br/>
配列を指す`POINT`構造体または`CPoint`接続しているオブジェクト。

*nCount*<br/>
配列内の地点の数を指定します。 この値は、少なくとも 2 を指定する必要があります。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

行は、現在のペンを使用して後続のポイントで最初の点から描画されます。 異なり、`LineTo`メンバー関数を`Polyline`関数で使用しても、現在の位置を更新します。

詳細については、次を参照してください。[ポリライン](/windows/desktop/api/wingdi/nf-wingdi-polyline)Windows SDK に含まれています。

##  <a name="polylineto"></a>  CDC::PolylineTo

1 つまたは複数の直線を描画します。

```
BOOL PolylineTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>パラメーター

*lpPoints*<br/>
配列を指す[ポイント](/windows/desktop/api/windef/ns-windef-tagpoint)行の頂点を格納するデータ構造体。

*nCount*<br/>
配列内の地点の数を指定します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

指定された最初のポイントを現在の位置から行が描画される、 *lpPoints*現在のペンを使用してパラメーター。 追加行ごとに、関数から描画前の行の終了点で指定された次のポイントに*lpPoints*します。 `PolylineTo` 最後の行の終了点には、現在の位置を移動します。 この関数によって描画される直線セグメントでは、閉じた図形をフォームの図は塗りつぶされていません。

##  <a name="polypolygon"></a>  CDC::PolyPolygon

現在の多角形の塗りつぶしモードを使用して入力が 2 つ以上の多角形を作成します。

```
BOOL PolyPolygon(
    LPPOINT lpPoints,
    LPINT lpPolyCounts,
    int nCount);
```

### <a name="parameters"></a>パラメーター

*lpPoints*<br/>
配列を指す`POINT`構造体または`CPoint`多角形の頂点を定義するオブジェクト。

*lpPolyCounts*<br/>
整数の配列へのポインターをそれぞれ指定するポイント数の多角形のいずれかで、 *lpPoints*配列。

*nCount*<br/>
内のエントリの数、 *lpPolyCounts*配列。 この数には、描画する多角形の数を指定します。 この値は、少なくとも 2 を指定する必要があります。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

多角形は、不整合のあるまたは重複する可能性があります。

呼び出しで指定された各多角形、`PolyPolygon`関数が終了する必要があります。 によって作成された多角形とは異なり、`Polygon`メンバー関数は、によって作成された多角形`PolyPolygon`自動的に閉じられていません。

この関数は、2 つ以上の多角形を作成します。 1 つの多角形を作成するアプリケーションを使用する必要があります、`Polygon`メンバー関数。

現在の多角形の塗りつぶしモードを取得または設定を使用して、`GetPolyFillMode`と`SetPolyFillMode`メンバー関数。

##  <a name="polypolyline"></a>  CDC::PolyPolyline

接続された線分の複数の系列を描画します。

```
BOOL PolyPolyline(
    const POINT* lpPoints,
    const DWORD* lpPolyPoints,
    int nCount);
```

### <a name="parameters"></a>パラメーター

*lpPoints*<br/>
ポリラインの頂点を格納する構造体の配列を指します。 ポリラインが連続的に指定します。

*lpPolyPoints*<br/>
内の地点の数を指定する変数の配列を指す、 *lpPoints*の対応する多角形の配列。 各エントリは、2 以上である必要があります。

*nCount*<br/>
カウントの合計数を指定します、 *lpPolyPoints*配列。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

直線セグメントは、現在のペンを使用して描画されます。 セグメントで構成される数値が入力されていません。 現在の位置が使用も、この関数によって更新します。

##  <a name="ptvisible"></a>  CDC::PtVisible

デバイス コンテキストのクリッピング領域内で指定したポイントであるかどうかを判断します。

```
virtual BOOL PtVisible(
    int x,
    int y) const;

BOOL PtVisible(POINT point) const;
```

### <a name="parameters"></a>パラメーター

*x*<br/>
ポイントの論理の x 座標を指定します。

*y*<br/>
ポイントの論理の y 座標を指定します。

*ポイント*<br/>
論理座標でチェックするポイントを指定します。 いずれかを渡すことができます、`POINT`構造または`CPoint`このパラメーターのオブジェクト。

### <a name="return-value"></a>戻り値

クリップ領域内の指定したポイントがある場合、0 以外の場合それ以外の場合 0 を返します。

##  <a name="queryabort"></a>  CDC::QueryAbort

によってインストールされているアボート関数を呼び出し、 [SetAbortProc](#setabortproc)印刷が終了したかどうかに、印刷アプリケーションとクエリのメンバー関数。

```
BOOL QueryAbort() const;
```

### <a name="return-value"></a>戻り値

印刷を続行する場合、または中止のプロシージャがない場合は 0 以外の値を返します。 印刷ジョブを終了する必要がある場合は 0 になります。 戻り値は、中止関数によって提供されます。

##  <a name="realizepalette"></a>  CDC::RealizePalette

マップのエントリは、現在の論理パレットからシステム パレット。

```
UINT RealizePalette();
```

### <a name="return-value"></a>戻り値

システム パレット内の異なるエントリに論理パレットのエントリの数がマップされたことを示します。 これは、この関数は、論理パレットが最後に実現されたために、システム パレット内の変更を対応するために再マップするエントリの数を表します。

### <a name="remarks"></a>Remarks

論理カラー パレットは、他のウィンドウに表示される色または色集中型アプリケーションとアプリケーションを独自に干渉することがなく、必要に応じて多くの色に色が表示されるように使用することにより、システムの間のバッファーとして機能します。

ウィンドウが入力フォーカスと呼び出しの場合`RealizePalette`、Windows により、すべての要求の色、画面に同時に使用できる最大数まで、ウィンドウに表示されます。 Windows では、使用可能な色に一致することでは、ウィンドウのパレットで検出されなかった色も表示されます。

さらに、Windows では、非アクティブなウィンドウ関数を使用可能な色に可能な限り呼び出すことによって要求された色と一致します。 これには、非アクティブなウィンドウに表示される色の望ましくない変更が大幅に削減されます。

##  <a name="rectangle"></a>  CDC::Rectangle

現在のペンを使用して四角形を描画します。

```
BOOL Rectangle(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Rectangle(LPCRECT lpRect);
```

### <a name="parameters"></a>パラメーター

*x1*<br/>
(論理単位) 内の四角形の左上隅の x 座標を指定します。

*y1*<br/>
(論理単位) 内の四角形の左上隅の y 座標を指定します。

*x2*<br/>
(論理単位) 内の四角形の右上隅の x 座標を指定します。

*y2*<br/>
(論理単位) 内の四角形の右上隅の y 座標を指定します。

*lpRect*<br/>
論理ユニットでは、四角形を指定します。 いずれかを渡すことができます、`CRect`オブジェクトまたはへのポインターを`RECT`このパラメーターの構造体。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

四角形の内部は、現在のブラシで塗りつぶされました。

四角形まで拡張は含まれません、右下隅の座標。 つまり、四角形の高さが*y2* - *y1* 、四角形の幅は*x2* - *x1*. 四角形の高さと幅の両方は、2 つのユニットと 32,767 より小さい単位より大きくなければなりません。

### <a name="example"></a>例

[!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]

##  <a name="rectvisible"></a>  CDC::RectVisible

指定した四角形の任意の部分がディスプレイ コンテキストのクリッピング領域内に存在するかどうかを判断します。

```
virtual BOOL RectVisible(LPCRECT lpRect) const;
```

### <a name="parameters"></a>パラメーター

*lpRect*<br/>
指す、`RECT`構造または`CRect`指定した四角形の論理座標を格納しているオブジェクト。

### <a name="return-value"></a>戻り値

指定した四角形の任意の部分がクリップ領域内にある場合、0 以外。それ以外の場合 0 を返します。

##  <a name="releaseattribdc"></a>  CDC::ReleaseAttribDC

設定するには、このメンバー関数を呼び出す`m_hAttribDC`を NULL にします。

```
virtual void ReleaseAttribDC();
```

### <a name="remarks"></a>Remarks

これは発生しません、`Detach`が発生します。 出力デバイス コンテキストのみに接続されている、`CDC`のみと、オブジェクトをデタッチできます。

##  <a name="releaseoutputdc"></a>  CDC::ReleaseOutputDC

設定するには、このメンバー関数を呼び出す、`m_hDC`メンバーを NULL にします。

```
virtual void ReleaseOutputDC();
```

### <a name="remarks"></a>Remarks

出力デバイス コンテキストが関連付けられている場合、このメンバー関数を呼び出すことはできません、`CDC`オブジェクト。 使用して、`Detach`メンバー関数は、出力デバイス コンテキストをデタッチします。

##  <a name="resetdc"></a>  CDC::ResetDC

によってラップされたデバイス コンテキストを更新するには、このメンバー関数を呼び出す、`CDC`オブジェクト。

```
BOOL ResetDC(const DEVMODE* lpDevMode);
```

### <a name="parameters"></a>パラメーター

*lpDevMode*<br/>
Windows へのポインター`DEVMODE`構造体。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

デバイス コンテキストは、Windows で指定された情報から更新`DEVMODE`構造体。 このメンバー関数は、属性のデバイス コンテキストのみをリセットします。

アプリケーションを使用することは通常、`ResetDC`メンバー関数は、ウィンドウを処理するとき、`WM_DEVMODECHANGE`メッセージ。 ドキュメントの印刷中に、用紙の向きまたは用紙トレイを変更するのに、このメンバー関数を使用することもできます。

このメンバー関数を使用して、出力ポートをドライバー名、デバイスの名前を変更することはできません。 ポート接続またはデバイス名を変更したとき、は、元デバイス コンテキストを削除して、新しい情報で新しいデバイス コンテキストを作成する必要があります。

このメンバー関数を呼び出す前に、、デバイス コンテキストに選択されている必要がある (ストック オブジェクト以外のすべてのオブジェクトが選択されていることを確認する必要があります。

##  <a name="restoredc"></a>  CDC::RestoreDC

デバイス コンテキストで識別される前の状態に復元*nSavedDC*します。

```
virtual BOOL RestoreDC(int nSavedDC);
```

### <a name="parameters"></a>パラメーター

*nSavedDC*<br/>
復元するデバイス コンテキストを指定します。 指定できる値の前、によって返される`SaveDC`関数呼び出し。 場合*nSavedDC* -1 で、最も最近保存したデバイス コンテキストを復元します。

### <a name="return-value"></a>戻り値

指定したコンテキストが復元された場合は 0 以外それ以外の場合 0 を返します。

### <a name="remarks"></a>Remarks

`RestoreDC` デバイス コンテキストを復元状態の情報を前の呼び出しで作成したスタックからポップすることで、`SaveDC`メンバー関数。

スタックは、複数のデバイス コンテキストの状態情報を含めることができます。 によってコンテキストが指定されている場合*nSavedDC* 、スタックの一番上にない`RestoreDC`で指定されたデバイス コンテキストの間のすべての状態情報を削除*nSavedDC*スタックの一番上とします。 削除済みの情報は失われます。

##  <a name="roundrect"></a>  CDC::RoundRect

現在のペンを使用して角の丸い四角形を描画します。

```
BOOL RoundRect(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3);

BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```

### <a name="parameters"></a>パラメーター

*x1*<br/>
(論理単位) 内の四角形の左上隅の x 座標を指定します。

*y1*<br/>
(論理単位) 内の四角形の左上隅の y 座標を指定します。

*x2*<br/>
(論理単位) 内の四角形の右上隅の x 座標を指定します。

*y2*<br/>
(論理単位) 内の四角形の右上隅の y 座標を指定します。

*x3*<br/>
(論理単位) での角が丸いの描画に使用される楕円の幅を指定します。

*y3*<br/>
(論理単位) での角が丸いの描画に使用される楕円の高さを指定します。

*lpRect*<br/>
論理ユニットでは、外接する四角形を指定します。 いずれかを渡すことができます、`CRect`オブジェクトまたはへのポインターを`RECT`このパラメーターの構造体。

*ポイント*<br/>
X 座標*ポイント*(論理単位) で、角が丸いを描画するために、楕円の幅を指定します。 Y 座標*ポイント*(論理単位) で、角が丸いを描画するために省略記号の高さを指定します。 いずれかを渡すことができます、`POINT`構造または`CPoint`このパラメーターのオブジェクト。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

四角形の内部は、現在のブラシで塗りつぶされました。

この関数は描画の図はまで拡張しますが、右下隅の座標は含まれません。 つまり、図形の高さは*y2* - *y1* figure の幅は*x2* - *x1*します。 外接する四角形の幅と高さの両方は、2 つのユニットと 32,767 より小さい単位より大きくなければなりません。

### <a name="example"></a>例

[!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]

##  <a name="savedc"></a>  CDC::SaveDC

Windows によって管理されるコンテキスト スタックには、(クリッピング領域、選択したオブジェクトは、マップ モードなど) の状態情報をコピーすることによって、デバイス コンテキストの現在の状態を保存します。

```
virtual int SaveDC();
```

### <a name="return-value"></a>戻り値

保存されたデバイス コンテキストを識別する整数。 エラーが発生した場合は 0 になります。 これを呼び出すことによって、デバイス コンテキストを復元する値を使用できますが返されます`RestoreDC`します。

### <a name="remarks"></a>Remarks

保存されたデバイス コンテキストを使用して後で復元できる`RestoreDC`します。

`SaveDC` 何回でも任意の数のデバイス コンテキストの状態を保存するために使用します。

##  <a name="scaleviewportext"></a>  CDC::ScaleViewportExt

現在の値を基準としたビューポートの範囲を変更します。

```
virtual CSize ScaleViewportExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>パラメーター

*xNum*<br/>
現在の x エクステントの乗算に使用量を指定します。

*xDenom*<br/>
値を現在の x エクステントを乗算した結果を除算する量を指定します、 *xNum*パラメーター。

*yNum*<br/>
Y 範囲が現在の乗算に使用量を指定します。

*yDenom*<br/>
値を現在の y 範囲を乗算した結果を除算する量を指定します、 *yNum*パラメーター。

### <a name="return-value"></a>戻り値

前のビューポートの範囲が (デバイス単位) として、`CSize`オブジェクト。

### <a name="remarks"></a>Remarks

数式は次のように書き込まれます。

`xNewVE = ( xOldVE * xNum ) / xDenom`

`yNewVE = ( yOldVE * yNum ) / yDenom`

ビューポートの新しい範囲は、特定の分子を現在の範囲を乗算し、特定の分母で除算して計算されます。

##  <a name="scalewindowext"></a>  CDC::ScaleWindowExt

現在の値を基準としたウィンドウの範囲を変更します。

```
virtual CSize ScaleWindowExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>パラメーター

*xNum*<br/>
現在の x エクステントの乗算に使用量を指定します。

*xDenom*<br/>
値を現在の x エクステントを乗算した結果を除算する量を指定します、 *xNum*パラメーター。

*yNum*<br/>
Y 範囲が現在の乗算に使用量を指定します。

*yDenom*<br/>
値を現在の y 範囲を乗算した結果を除算する量を指定します、 *yNum*パラメーター。

### <a name="return-value"></a>戻り値

前のウィンドウの範囲が (論理単位) として、`CSize`オブジェクト。

### <a name="remarks"></a>Remarks

数式は次のように書き込まれます。

`xNewWE = ( xOldWE * xNum ) / xDenom`

`yNewWE = ( yOldWE * yNum ) / yDenom`

新しいウィンドウの範囲は、特定の分子を現在の範囲を乗算し、特定の分母で除算して計算されます。

##  <a name="scrolldc"></a>  CDC::ScrollDC

Bits の四角形は、水平および垂直にスクロールします。

```
BOOL ScrollDC(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* pRgnUpdate,
    LPRECT lpRectUpdate);
```

### <a name="parameters"></a>パラメーター

*dx*<br/>
水平スクロールの単位数を指定します。

*dy*<br/>
垂直スクロール ユニットの数を指定します。

*形*<br/>
指す、`RECT`構造または`CRect`スクロールされる四角形の座標を格納しているオブジェクト。

*lpRectClip*<br/>
指す、`RECT`構造または`CRect`クリッピング四角形の座標を格納しているオブジェクト。 この四角形が 1 つが指す元よりも小さい場合*形*、スクロール、小さい四角形でのみ行われます。

*pRgnUpdate*<br/>
スクロールのプロセスで検出された領域を識別します。 `ScrollDC`関数は、このリージョンを定義します。 とは限りません四角形。

*lpRectUpdate*<br/>
指す、`RECT`構造または`CRect`スクロール可能な更新領域に外接する四角形の座標を受け取るオブジェクト。 これは、再描画が必要な最大の四角形の領域です。 構造体またはオブジェクトの関数が返す場合、値は、特定のデバイス コンテキストのマッピング モードに関係なく、クライアント座標でです。

### <a name="return-value"></a>戻り値

スクロールが実行される場合、0 以外の場合それ以外の場合 0 を返します。

### <a name="remarks"></a>Remarks

場合*lpRectUpdate*が null の場合、Windows では、更新プログラムの四角形は計算されません。 両方*pRgnUpdate*と*lpRectUpdate*が NULL の場合 Windows は更新領域を計算できません。 場合*pRgnUpdate*が NULL でない Windows では、スクロールのプロセスで検出された領域への有効なポインターが含まれている前提としています (によって定義された、`ScrollDC`メンバー関数)。 返される更新領域*lpRectUpdate*に渡すことが`CWnd::InvalidateRgn`必要な場合。

アプリケーションで使用する、`ScrollWindow`クラスのメンバー関数`CWnd`ウィンドウの全体のクライアント領域をスクロールする必要な場合。 それ以外の場合、これを使用する必要があります`ScrollDC`します。

##  <a name="selectclippath"></a>  CDC::SelectClipPath

指定されたモードを使用して、既存のクリッピング領域で新しい地域を組み合わせて、デバイス コンテキストのクリッピング領域として、現在のパスを選択します。

```
BOOL SelectClipPath(int nMode);
```

### <a name="parameters"></a>パラメーター

*nMode*<br/>
パスを使用する方法を指定します。 次の値は使用できます。

- RGN_AND 新しいクリップ領域には、現在のクリップ領域と現在のパスの交差 (重複する領域) が含まれています。

- RGN_COPY 新しいクリッピング領域は、現在のパスです。

- RGN_DIFF 新しいクリップ領域には、現在のクリップ領域の領域が含まれています。 され、現在のパスの除外されます。

- RGN_OR 新しいクリップ領域には、現在のクリップ領域と、現在のパスの和集合 (結合された領域) が含まれています。

- RGN_XOR 新しいクリップ領域には、共用体現在のクリップ領域と、現在のパスが、重複する領域にはが含まれています。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

識別されたデバイス コンテキストでは、閉じたパスを含める必要があります。

##  <a name="selectcliprgn"></a>  CDC::SelectClipRgn

デバイス コンテキストの現在のクリップ領域としては、特定のリージョンを選択します。

```
int SelectClipRgn(CRgn* pRgn);

int SelectClipRgn(
    CRgn* pRgn,
    int nMode);
```

### <a name="parameters"></a>パラメーター

*pRgn*<br/>
選択するリージョンを識別します。

- この関数は、最初のバージョンのクライアント領域全体が選択されているこの値が NULL の場合と、出力は、ウィンドウにはクリップされます。

- この関数の 2 番目のバージョンの RGN_COPY モードを指定した場合にのみ、このハンドルは NULL を指定することができます。

*nMode*<br/>
実行する操作を指定します。 値は次のいずれかを指定する必要があります。

- 新しいクリップ領域が、重複する領域の現在のクリップ領域とによって識別される領域を結合する RGN_AND *pRgn*します。

- RGN_COPY によって識別される領域のコピーである新しいクリップ領域*pRgn*します。 これは、機能の最初のバージョンと同じ`SelectClipRgn`します。 場合は、リージョンがで識別される*pRgn*が null の場合、新しいクリップ領域が既定のクリッピング領域 (null のリージョン) になります。

- RGN_DIFF によって識別される領域から除外した領域の現在のクリップ領域の領域を結合する新しいクリップ領域*pRgn*します。

- 現在のクリップ領域とによって識別される領域は RGN_OR 新しいクリップ領域を組み合わせた*pRgn*します。

- 現在のクリップ領域とによって識別される領域は RGN_XOR 新しいクリップ領域を組み合わせた*pRgn*は重複する区分を除外します。

### <a name="return-value"></a>戻り値

領域の型。 次の値のいずれかを指定できます。

- 新しい COMPLEXREGION のクリッピング領域には、重なり合った境界線。

- デバイス コンテキストのエラーやリージョンが無効です。

- 新しい NULLREGION のクリッピング領域が空です。

- 新しい SIMPLEREGION のクリッピング領域には、重複する境界線がありません。

### <a name="remarks"></a>Remarks

選択された領域のコピーのみが使用されます。 領域自体で選択できるその他のデバイス コンテキストの任意の数、または削除できます。

関数では、デバイス単位で指定された領域の座標が指定されている前提としています。 一部のプリンター デバイスは、テキスト メトリックを表現するために必要な精度を保持するためのグラフィックス出力より高い解像度のテキスト出力をサポートします。 これらのデバイスは、テキスト単位では、以上の解像度でデバイス単位を報告します。 これらのデバイスは、グラフィック ユニットを 1 つのみをデバイス単位のマップをレポートのいくつかされるようにし、グラフィックスの座標をスケールします。 常に呼び出す必要があります、`SelectClipRgn`テキスト単位を使用して機能します。

GDI でグラフィック オブジェクトのスケーリングを行う必要のあるアプリケーションでは、スケール ファクターを判断するのに GETSCALINGFACTOR のプリンター エスケープを使用できます。 このスケール ファクターでは、クリッピングに影響します。 グラフィックスをクリップ領域を使用する場合、GDI は、スケール ファクターで座標を除算します。 テキストをクリップ領域を使用する場合は、GDI にスケール調整がありません。 スケーリング係数は 1 と 2 で除算する座標スケール ファクターは 2 と 4 で除算する座標などなど。

##  <a name="selectobject"></a>  CDC::SelectObject

デバイス コンテキストにオブジェクトを選択します。

```
CPen* SelectObject(CPen* pPen);
CBrush* SelectObject(CBrush* pBrush);
virtual CFont* SelectObject(CFont* pFont);
CBitmap* SelectObject(CBitmap* pBitmap);
int SelectObject(CRgn* pRgn);
CGdiObject* SelectObject(CGdiObject* pObject);
```

### <a name="parameters"></a>パラメーター

*pPen*<br/>
ポインターを[CPen](../../mfc/reference/cpen-class.md)オブジェクトを選択します。

*pBrush*<br/>
ポインターを[CBrush](../../mfc/reference/cbrush-class.md)オブジェクトを選択します。

*pFont*<br/>
ポインターを[CFont](../../mfc/reference/cfont-class.md)オブジェクトを選択します。

*pBitmap*<br/>
ポインターを[CBitmap](../../mfc/reference/cbitmap-class.md)オブジェクトを選択します。

*pRgn*<br/>
ポインターを[CRgn](../../mfc/reference/crgn-class.md)オブジェクトを選択します。

*pObject*<br/>
ポインターを[CGdiObject](../../mfc/reference/cgdiobject-class.md)オブジェクトを選択します。

### <a name="return-value"></a>戻り値

置き換えられるオブジェクトへのポインター。 派生したクラスのいずれかのオブジェクトへのポインターは、この`CGdiObject`など`CPen`、使用する関数のバージョンによって異なります。 エラーがある場合、戻り値は NULL です。 この関数は、一時オブジェクトへのポインターを返す可能性があります。 この一時オブジェクトは 1 つの Windows メッセージの処理中にのみ有効です。 詳細については、「 `CGdiObject::FromHandle` 」を参照してください。

リージョン パラメーターを受け取るメンバー関数のバージョンと同じタスクを実行する、`SelectClipRgn`メンバー関数。 その戻り値には、次のいずれかを指定できます。

- 新しい COMPLEXREGION のクリッピング領域には、重なり合った境界線。

- デバイス コンテキストのエラーやリージョンが無効です。

- 新しい NULLREGION のクリッピング領域が空です。

- 新しい SIMPLEREGION のクリッピング領域には、重複する境界線がありません。

### <a name="remarks"></a>Remarks

クラス`CDC`GDI オブジェクト、ペン、ブラシ、フォント、ビットマップ、リージョンなどの特定の種類の特殊化された 5 つのバージョンを提供します。 新しく選択されたオブジェクトには、同じ型の前のオブジェクトが置き換えられます。 たとえば場合、 *pObject*の一般的なバージョンの`SelectObject`を指す、 [CPen](../../mfc/reference/cpen-class.md)オブジェクト、関数で指定されたペンを使用して、現在のペンを置換する*pObject*.

アプリケーション、ビットマップ メモリ デバイス コンテキストにのみ、1 つだけのメモリ デバイス コンテキストに時に選択できます。 ビットマップの形式またはモノクロのデバイス コンテキストとの互換性にする必要がありますかそうでない場合`SelectObject`エラーが返されます。

Windows 3.1 以降で、`SelectObject`かメタファイルで使用されるかどうか、関数が同じ値を返します。 以前のバージョンの Windows では、`SelectObject`メタファイルで使用されていた場合に成功、0 以外の値とエラーの場合は 0 が返されます。

##  <a name="selectpalette"></a>  CDC::SelectPalette

指定されている論理パレットを選択します。 *pPalette*デバイス コンテキストのパレットを選択したオブジェクトとして。

```
CPalette* SelectPalette(
    CPalette* pPalette,
    BOOL bForceBackground);
```

### <a name="parameters"></a>パラメーター

*pPalette*<br/>
選択する論理パレットを識別します。 このパレットする必要がありますに作成されていると、`CPalette`メンバー関数は[CreatePalette](../../mfc/reference/cpalette-class.md#createpalette)します。

*bForceBackground*<br/>
論理パレットがパレットに強制するかどうかを指定します。 場合*bForceBackground*が 0 以外の場合、選択したパレットは常に、ウィンドウが入力フォーカスを持っているかどうかに関係なく、バック グラウンドのパレット。 場合*bForceBackground*が 0 のデバイス コンテキストがウィンドウにアタッチし、ウィンドウに入力フォーカスがあるとき、論理パレットがフォア グラウンド パレット。

### <a name="return-value"></a>戻り値

ポインターを`CPalette`オブジェクトで指定されたパレットに置き換え、論理パレットを識別する*pPalette*します。 エラーがある場合は NULL になります。

### <a name="remarks"></a>Remarks

新しいパレットは、GDI デバイス コンテキストで表示される色を制御するために使用するパレット オブジェクトになり、前のパレットを置き換えます。

アプリケーションでは、1 つ以上のデバイス コンテキストに論理パレットを選択できます。 ただし、論理パレットの変更が選択されているすべてのデバイス コンテキストに影響します。 アプリケーションでは、1 つ以上のデバイス コンテキストにパレットを選択した場合、デバイス コンテキストする必要がありますすべてに属している、同じ物理デバイス。

##  <a name="selectstockobject"></a>  CDC::SelectStockObject

選択、 [CGdiObject](../../mfc/reference/cgdiobject-class.md)定義済みのストック ペン、ブラシ、フォントのいずれかに対応するオブジェクト。

```
virtual CGdiObject* SelectStockObject(int nIndex);
```

### <a name="parameters"></a>パラメーター

*nIndex*<br/>
目的のストック オブジェクトの種類を指定します。 次の値のいずれかを指定できます。

- BLACK_BRUSH 黒のブラシ。

- DKGRAY_BRUSH 濃い灰色のブラシ。

- GRAY_BRUSH 灰色のブラシ。

- HOLLOW_BRUSH 白抜きのブラシ。

- LTGRAY_BRUSH 薄い灰色のブラシ。

- NULL_BRUSH Null ブラシ。

- WHITE_BRUSH ホワイト ブラシ。

- BLACK_PEN 黒ペン。

- NULL_PEN Null するペン。

- WHITE_PEN ホワイト ペン。

- ANSI_FIXED_FONT ANSI では、システム フォントを固定します。

- ANSI_VAR_FONT ANSI 変数システム フォントです。

- DEVICE_DEFAULT_FONT デバイスに依存するフォントです。

- 固定ピッチ フォントを OEM_FIXED_FONT OEM に依存します。

- SYSTEM_FONT システム フォント。 既定では、Windows は、メニューのダイアログ ボックスのコントロール、およびその他のテキストを描画するために、システム フォントを使用します。 ただし、ダイアログ、および windows で使用されるフォントを取得する SYSTEM_FONT 依存が最善では。 代わりに、使用、`SystemParametersInfo`関数が現在のフォントを取得する SPI_GETNONCLIENTMETRICS パラメーターを使用します。 `SystemParametersInfo` 現在のテーマを考慮し、キャプション、メニューのおよびメッセージのダイアログ ボックスのフォント情報を提供します。

- SYSTEM_FIXED_FONT より前のバージョン 3.0、Windows で使用される固定長のシステム フォント。 このオブジェクトは、Windows の旧バージョンとの互換性のために使用できます。

- DEFAULT_PALETTE 既定色パレット。 このパレットは、システム パレットの 20 の静的な色で構成されます。

### <a name="return-value"></a>戻り値

ポインター、`CGdiObject`関数が成功した場合、置き換えられたオブジェクト。 実際のオブジェクトを指すは、 [CPen](../../mfc/reference/cpen-class.md)、 [CBrush](../../mfc/reference/cbrush-class.md)、または[CFont](../../mfc/reference/cfont-class.md)オブジェクト。 呼び出しが成功しなかった場合、戻り値は NULL です。

##  <a name="setabortproc"></a>  CDC::SetAbortProc

印刷ジョブの中止の手順をインストールします。

```
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```

### <a name="parameters"></a>パラメーター

*lpfn*<br/>
中止の手順に従ってインストールを中止関数へのポインター。 詳細については、コールバック関数は、次を参照してください。 [cdc::setabortproc 用コールバック関数](callback-functions-used-by-mfc.md#setabortproc)します。

### <a name="return-value"></a>戻り値

結果を示す、`SetAbortProc`関数。 次の値の一部は、他よりもより高いがすべて可能です。

- SP_ERROR の一般的なエラー。

- させることでよりいない十分なディスク領域がスプールされている、現在使用できると、空き領域が使用可能になります。

- SP_OUTOFMEMORY いない十分なメモリがスプールのために使用できます。

- SP_USERABORT ユーザーには、プリント マネージャーを使って、ジョブが終了しました。

### <a name="remarks"></a>Remarks

アプリケーションがスプール中に取り消される印刷ジョブを許可する場合で印刷ジョブを開始する前に、中止関数を設定があります、 [StartDoc](#startdoc)メンバー関数。 プリント マネージャーは、スプール中に印刷ジョブをキャンセルするか、ディスク領域不足状態を処理するアプリケーションを中止関数を呼び出します。 Abort 関数が設定されていない場合、スプールのための十分なディスク領域がない場合、印刷ジョブは失敗します。

Microsoft Visual C の機能に渡されるコールバック関数の作成を簡略化ことに注意してください。`SetAbortProc`します。 渡される、アドレス、`EnumObjects`メンバー関数を使用してエクスポート関数へのポインターは、`__declspec(dllexport)`を使用して、`__stdcall`呼び出し規約。

する必要はありませんで関数名のエクスポート、**エクスポート**アプリケーションのモジュール定義ファイル内のステートメント。 代わりに使用することができます、**エクスポート**としての関数の修飾子

**BOOL コールバック エクスポート**関数 ( **HDC**、 `int` **)。**

エイリアスなしの名前でエクスポートするための適切なエクスポート レコードを生成するコンパイラは、します。 これは、ほとんどのニーズに対して機能します。 序数またはエイリアス、関数のエクスポートなど、いくつかの特殊なケースにする必要がありますを使用して、**エクスポート**モジュール定義ファイル内のステートメント。

コールバックの登録インターフェイスがタイプ セーフではようになりました (特定のコールバック関数の適切な種類を指す関数ポインターに渡す必要があります)。

また、すべてのコールバック関数がコールバックの境界を越えて例外をスローすることはできませんので、Windows に戻る前に Microsoft Foundation 例外をトラップする必要がありますに注意してください。 例外の詳細については、記事を参照してください。[例外](../../mfc/exception-handling-in-mfc.md)します。

##  <a name="setarcdirection"></a>  CDC::SetArcDirection

円弧と四角形の関数に使用する描画方向を設定します。

```
int SetArcDirection(int nArcDirection);
```

### <a name="parameters"></a>パラメーター

*nArcDirection*<br/>
新しい円弧の方向を指定します。 このパラメーターは、次の値のいずれかを指定できます。

- AD_COUNTERCLOCKWISE 図形が反時計回りに描画します。

- AD_CLOCKWISE 図形が時計回りに描画します。

### <a name="return-value"></a>戻り値

成功した場合は、古い円弧の方向を指定しますそれ以外の場合 0 を返します。

### <a name="remarks"></a>Remarks

既定の方向は、反時計回りに回転します。 `SetArcDirection`関数は、次の関数は描画する方向を指定します。

|円弧|円グラフ|
|---------|---------|
|`ArcTo`|`Rectangle`|
|`Chord`|`RoundRect`|
|`Ellipse`||

##  <a name="setattribdc"></a>  CDC::SetAttribDC

属性のデバイス コンテキストを設定するには、この関数を呼び出す`m_hAttribDC`します。

```
virtual void SetAttribDC(HDC hDC);
```

### <a name="parameters"></a>パラメーター

*hDC*<br/>
Windows デバイス コンテキスト。

### <a name="remarks"></a>Remarks

このメンバー関数にデバイス コンテキストにアタッチできません、`CDC`オブジェクト。 出力デバイス コンテキストのみに接続されている、`CDC`オブジェクト。

##  <a name="setbkcolor"></a>  CDC::SetBkColor

現在の背景色を指定した色に設定します。

```
virtual COLORREF SetBkColor(COLORREF crColor);
```

### <a name="parameters"></a>パラメーター

*crColor*<br/>
新しい背景色を指定します。

### <a name="return-value"></a>戻り値

RGB 色の値として前の背景色です。 エラーが発生する場合、戻り値は 0x80000000 です。

### <a name="remarks"></a>Remarks

バック グラウンド モードが不透明である場合は、システムをスタイル設定された行のギャップ、ハッチ ブラシ、行と文字セルの背景の間のギャップを埋める背景色を使用します。 ビットマップの色とモノクロ デバイス コンテキストの間を変換するときにも背景色が使用されます。

デバイスが指定した色を表示できない場合、システムは、最も近い物理色を背景色を設定します。

##  <a name="setbkmode"></a>  CDC::SetBkMode

バック グラウンド モードを設定します。

```
int SetBkMode(int nBkMode);
```

### <a name="parameters"></a>パラメーター

*nBkMode*<br/>
設定するモードを指定します。 このパラメーターは、次の値のいずれかを指定できます。

- 不透明な背景は、ハッチ ブラシ、テキストの前に、現在の背景色で塗りつぶされます。 またはペンを描画します。 これは、既定のバック グラウンド モードです。

- 透明な背景は描画前に変更されません。

### <a name="return-value"></a>戻り値

前のバック グラウンド モード。

### <a name="remarks"></a>Remarks

バック グラウンド モードでは、テキストやハッチ ブラシ、実線ではないペンのスタイルを描画する前に、システムが描画サーフェイスでの既存の背景色を削除するかどうかを定義します。

### <a name="example"></a>例

  例をご覧ください[CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor)します。

##  <a name="setboundsrect"></a>  CDC::SetBoundsRect

指定したデバイス コンテキストの境界の四角形の情報の蓄積を制御します。

```
UINT SetBoundsRect(
    LPCRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>パラメーター

*lpRectBounds*<br/>
指す、`RECT`構造または`CRect`外接する四角形の設定に使用されるオブジェクト。 四角形の大きさは、論理座標で指定されます。 このパラメーターは、NULL を指定できます。

*flags*<br/>
新しい四角形が結合して、四角形を蓄積する方法を指定します。 このパラメーターは、次の値の組み合わせを指定できます。

- DCB_ACCUMULATE 追加で指定された四角形*lpRectBounds* (四角形の和集合演算を使用して)、外接する四角形にします。

- DCB_DISABLE は境界の集積/離散オフにします。

- DCB_ENABLE 境界累積有効にします。 (境界集積/離散の既定の設定は無効です。)

### <a name="return-value"></a>戻り値

境界の四角形の関数が成功した場合の現在の状態。 ような*フラグ*、戻り値の組み合わせをできる**DCB_** 値。

- DCB_ACCUMULATE 外接する四角形が空ではありません。 この値は常に設定されます。

- DCB_DISABLE 境界集積/離散は off です。

- DCB_ENABLE 境界が蓄積されるは。

### <a name="remarks"></a>Remarks

Windows では、すべての描画操作の外接する四角形を保持できます。 この四角形は、クエリを実行し、アプリケーションでリセットできます。 描画の境界は、ビットマップのキャッシュを無効にします。

##  <a name="setbrushorg"></a>  CDC::SetBrushOrg

GDI は、アプリケーションがデバイス コンテキストに選択した [次へ]、ブラシに割り当てることが配信元を指定します。

```
CPoint SetBrushOrg(
    int x,
    int y);

CPoint SetBrushOrg(POINT point);
```

### <a name="parameters"></a>パラメーター

*x*<br/>
新しい配信元の (デバイス単位) での x 座標を指定します。 この値は 0 ~ 7 の範囲でなければなりません。

*y*<br/>
新しい配信元の (デバイス単位) での y 座標を指定します。 この値は 0 ~ 7 の範囲でなければなりません。

*ポイント*<br/>
新しい配信元の x 座標と y 座標を指定します。 各値は 0 ~ 7 の範囲でなければなりません。 いずれかを渡すことができます、`POINT`構造または`CPoint`このパラメーターのオブジェクト。

### <a name="return-value"></a>戻り値

前のデバイス単位でブラシの原点。

### <a name="remarks"></a>Remarks

既定値は、ブラシの原点の座標は (0, 0)。 ブラシの原点を変更するには、呼び出し、`UnrealizeObject`関数を`CBrush`オブジェクトを呼び出す`SetBrushOrg`を呼び出して、`SelectObject`メンバー関数は、デバイス コンテキストにブラシを選択します。

使用しない`SetBrushOrg`在庫と`CBrush`オブジェクト。

##  <a name="setcoloradjustment"></a>  CDC::SetColorAdjustment

指定した値を使用してデバイス コンテキストの色の調整値を設定します。

```
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```

### <a name="parameters"></a>パラメーター

*lpColorAdjust*<br/>
指す、 [COLORADJUSTMENT](/windows/desktop/api/wingdi/ns-wingdi-tagcoloradjustment)色の調整値を含むデータ構造体。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

色調整値を使用して入力の呼び出し元のビットマップの色を調整して、`CDC::StretchBlt`ハーフトーン モードが設定されている場合、メンバー関数。

##  <a name="setdcbrushcolor"></a>  CDC::SetDCBrushColor

指定した色の値には、現在のデバイス コンテキスト (DC) ブラシの色を設定します。

```
COLORREF SetDCBrushColor(COLORREF crColor);
```

### <a name="parameters"></a>パラメーター

*crColor*<br/>
新しいブラシの色を指定します。

### <a name="return-value"></a>戻り値

関数が成功した場合、戻り値は COLORREF 値として前の DC のブラシの色を指定します。

関数が失敗した場合は、値を返します。

### <a name="remarks"></a>Remarks

このメソッドは、関数の機能をエミュレート[SetDCBrushColor](/windows/desktop/api/wingdi/nf-wingdi-setdcbrushcolor)」の説明に従って、Windows SDK。

##  <a name="setdcpencolor"></a>  CDC::SetDCPenColor

指定した色の値には、現在のデバイス コンテキスト (DC) ペンの色を設定します。

```
COLORREF SetDCPenColor(COLORREF crColor);
```

### <a name="parameters"></a>パラメーター

*crColor*<br/>
新しいペンの色を指定します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

このメンバー関数で Win32 関数[SetDCPenColor](/windows/desktop/api/wingdi/nf-wingdi-setdcpencolor)」の説明に従って、Windows SDK。

##  <a name="setgraphicsmode"></a>  CDC::SetGraphicsMode

指定したデバイス コンテキストのグラフィックス モードを設定します。

```
int SetGraphicsMode(int iMode);
```

### <a name="parameters"></a>パラメーター

*i モード*<br/>
グラフィック モードを指定します。 このパラメーターが取る値の一覧では、次を参照してください。 [SetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-setgraphicsmode)します。

### <a name="return-value"></a>戻り値

成功した場合、古いグラフィックス モードを返します。

失敗した場合は 0 を返します。 拡張エラー情報を取得するには呼び出します[GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360)します。

### <a name="remarks"></a>Remarks

このメソッドは、Windows GDI 関数をラップ[SetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-setgraphicsmode)します。

##  <a name="setlayout"></a>  CDC::SetLayout

右から左、アラビア語やヘブライ語などのカルチャの標準的なレイアウトにテキストとグラフィックス デバイス コンテキストのレイアウトを変更するには、このメンバー関数を呼び出します。

```
DWORD SetLayout(DWORD dwLayout);
```

### <a name="parameters"></a>パラメーター

*dwLayout*<br/>
デバイス コンテキストのレイアウトとビットマップは、フラグを制御します。 次の値の組み合わせを指定できます。

|[値]|説明|
|-----------|-------------|
|まず|呼び出しに、リフレクションを無効にします。 [cdc::bitblt](#bitblt)と[CDC::StretchBlt](#stretchblt)します。|
|LAYOUT_RTL|右から左にある既定の水平方向のレイアウトを設定します。|
|LAYOUT_LTR|左右からに既定のレイアウトを設定します。|

### <a name="return-value"></a>戻り値

成功した場合、デバイス コンテキストの以前のレイアウト。

失敗した場合、GDI_ERROR します。 拡張エラー情報を取得するには呼び出します[GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360)します。

### <a name="remarks"></a>Remarks

通常、呼び出すことはありません`SetLayout`ウィンドウ。 代わりに、設定して、ウィンドウで右から左のレイアウトを制御する、[拡張ウィンドウ スタイル](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)WS_EX_RTLREADING など。 プリンターや、メタファイルなどのデバイス コンテキストでは、このレイアウトは継承しません。 右から左のレイアウトを呼び出すことによって、デバイス コンテキストを設定する唯一の方法`SetLayout`します。

呼び出す場合**SetLayout (LAYOUT_RTL** )、`SetLayout`にマッピング モードが自動的に変更します。 その結果、後続の呼び出し[この](#getmapmode)MM_TEXT ではなく MM_ISOTROPIC が返されます。

場合によってなど多くのビットマップをたい場合があります左から右のレイアウトを保持します。 このような場合は、呼び出すことによって、イメージをレンダリング`BitBlt`または`StretchBlt`のビットマップ コントロール フラグを設定し、 *dwLayout*まずにします。

LAYOUT_RTL フラグを使用してレイアウトを変更すると、通常を指定するフラグ右端または左端が取り消されます。 混乱を避けるためには、標準のフラグの代替名を定義することがあります。 推奨される代替フラグ名の一覧は、次を参照してください。 [SetLayout](/windows/desktop/api/wingdi/nf-wingdi-setlayout) Windows SDK に含まれています。

##  <a name="setmapmode"></a>  CDC::SetMapMode

マップ モードを設定します。

```
virtual int SetMapMode(int nMapMode);
```

### <a name="parameters"></a>パラメーター

*nMapMode*<br/>
新しいマッピング モードを指定します。 次の値のいずれかを指定できます。

- MM_ANISOTROPIC 論理ユニットは、任意のスケールの軸を持つ任意の単位に変換されます。 マッピング モードを設定しても、現在のウィンドウ、またはビューポートの設定は変わりません。 単位を変更するには、向き、およびスケーリングを呼び出す、[両](#setwindowext)と[される](#setviewportext)メンバー関数。

- 論理ユニットごとの MM_HIENGLISH は 0.001 インチに変換されます。 正の x が右側には正の y です。

- MM_HIMETRIC それぞれの論理単位は 0.01 ミリメートルに変換されます。 正の x が右側には正の y です。

- MM_ISOTROPIC 論理ユニットが均等にスケーリングされた軸上で任意の単位に変換されます。つまり、x 軸に沿って 1 単位は、y 軸に沿って 1 単位です。 使用して、`SetWindowExt`と`SetViewportExt`メンバー関数は、目的のユニットと軸の方向を指定します。 GDI は、必要に応じて調整をユニットが同じサイズのまま、x と y のことを確認します。

- MM_LOENGLISH それぞれの論理単位は 0.01 インチに変換されます。 正の x が右側には正の y です。

- 論理ユニットごとの MM_LOMETRIC は 0.1 ミリメートルに変換されます。 正の x が右側には正の y です。

- MM_TEXT 各論理ユニットは、1 台のデバイスのピクセルに変換されます。 正の x が右側には正の y は停止されます。

- MM_TWIPS 各論理ユニットは、点の 1 対 20 に変換されます。 (ポイントは、1/72 インチであるため、twip が 1/1440 インチです。)正の x が右側には正の y です。

### <a name="return-value"></a>戻り値

以前のマッピング モード。

### <a name="remarks"></a>Remarks

マップ モードは、論理ユニットをデバイス単位; に変換するために使用するメジャーの単位を定義します。デバイスの x 軸と y 軸の方向も定義します。 GDI は、適切なデバイス座標論理座標に変換するのにマップ モードを使用します。 MM_TEXT モードには、1 ユニットが 1 ピクセル デバイス ピクセル単位で動作するアプリケーションができます。 1 ピクセルの物理サイズでは、デバイスによって異なります。

MM_HIENGLISH、MM_HIMETRIC、MM_LOENGLISH、MM_LOMETRIC、および MM_TWIPS モードは、物理的に意味のある単位 (ミリメートルやインチ) などを描画する必要がありますアプリケーションに役立ちます。 MM_ISOTROPIC モードは、縦横比 1:1、により、イメージの正確な形状を維持する必要がある場合に便利です。 MM_ANISOTROPIC モードでは、個別に調整される x 座標と y 座標を使用します。

> [!NOTE]
>  呼び出す場合[SetLayout](#setlayout) DC (デバイス コンテキスト) を右から左のレイアウトに変更する`SetLayout`にマッピング モードが自動的に変更します。

### <a name="example"></a>例

  例をご覧ください[付け](../../mfc/reference/cview-class.md#onpreparedc)します。

##  <a name="setmapperflags"></a>  CDC::SetMapperFlags

物理フォントの論理フォントを変換するときに、フォント マッパーで使用されるメソッドを変更します。

```
DWORD SetMapperFlags(DWORD dwFlag);
```

### <a name="parameters"></a>パラメーター

*dwFlag*<br/>
フォント マッパーがフォントの側面の高さと幅、デバイスを照合しようとしたかどうかを指定します。 この値が ASPECT_FILTERING の場合は、マッパーは x と y の比率を正確に一致の指定したデバイスのみのフォントを選択します。

### <a name="return-value"></a>戻り値

フォント マッパー フラグの以前の値。

### <a name="remarks"></a>Remarks

アプリケーションで使用できます`SetMapperFlags`させる、指定されたデバイスの縦横比と一致する物理フォントのみを選択しようとするフォント マッパー。

ラスター フォントだけを使用するアプリケーションを使用できる、`SetMapperFlags`フォント マッパーで選択されているフォントが魅力的なと、指定されたデバイスで読み取り可能であることを確認する関数。 通常、拡張性の高い (TrueType) フォントを使用するアプリケーションは使用しないでください`SetMapperFlags`します。

物理フォントの論理フォントの仕様に一致する縦横比がなければ、GDI が新しい縦横比を選択し、この新しい縦横比と一致するフォントを選択します。

##  <a name="setmiterlimit"></a>  CDC::SetMiterLimit

デバイス コンテキストのマイター結合の長さの制限を設定します。

```
BOOL SetMiterLimit(float fMiterLimit);
```

### <a name="parameters"></a>パラメーター

*fMiterLimit*<br/>
デバイス コンテキストの新しいマイタ制限値を指定します。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

マイター長は、結合の外側の線の壁の積集合を結合の内側の線の壁の積集合からの距離として定義されます。 マイター リミットは、線の幅にマイター長の最大許容比率です。 既定のマイター リミットは 10.0 です。

##  <a name="setoutputdc"></a>  CDC::SetOutputDC

出力デバイス コンテキストを設定するには、このメンバー関数を呼び出す`m_hDC`します。

```
virtual void SetOutputDC(HDC hDC);
```

### <a name="parameters"></a>パラメーター

*hDC*<br/>
Windows デバイス コンテキスト。

### <a name="remarks"></a>Remarks

このメンバー関数は、デバイス コンテキストに接続されていない場合にのみ呼び出すことができます、`CDC`オブジェクト。 このメンバー関数は、設定`m_hDC`デバイス コンテキストにはアタッチされませんが、`CDC`オブジェクト。

##  <a name="setpixel"></a>  CDC::SetPixel

指定された色の最も近いものを指定した時点で、ピクセルを設定*crColor*します。

```
COLORREF SetPixel(
    int x,
    int y,
    COLORREF crColor);

COLORREF SetPixel(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>パラメーター

*x*<br/>
論理で設定する点の x 座標を指定します。

*y*<br/>
論理で設定する点の y 座標を指定します。

*crColor*<br/>
点を描画するために使用する色を指定する COLORREF RGB 値。 参照してください[COLORREF](/windows/desktop/gdi/colorref)この値の説明については、Windows SDK に含まれています。

*ポイント*<br/>
設定する点の論理 x 座標と y 座標を指定します。 いずれかを渡すことができます、`POINT`構造または`CPoint`このパラメーターのオブジェクト。

### <a name="return-value"></a>戻り値

ポイントが実際に描画する色の RGB 値。 この値で指定されていると異なる場合*crColor*その色の概数を使用する場合。 関数には、(ポイントがクリッピング領域の外側にある場合) が失敗した場合、戻り値は-1 です。

### <a name="remarks"></a>Remarks

クリッピング領域で、ポイントがある必要があります。 クリッピング領域で、ポイントがない場合、関数はありません。

一部のデバイスでは、`SetPixel` 関数がサポートされていません。 デバイスをサポートしているかどうかを判断する`SetPixel`、呼び出し、`GetDeviceCaps`メンバー関数と RASTERCAPS インデックスと RC_BITBLT フラグの戻り値を確認します。

##  <a name="setpixelv"></a>  CDC::SetPixelV

指定した色の最も近いものを指定した座標のピクセルを設定します。

```
BOOL SetPixelV(
    int x,
    int y,
    COLORREF crColor);

BOOL SetPixelV(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>パラメーター

*x*<br/>
論理ユニットを設定する点の x 座標を指定します。

*y*<br/>
論理ユニットを設定する点の y 座標を指定します。

*crColor*<br/>
ポイントの描画に使用する色を指定します。

*ポイント*<br/>
設定する点の論理 x 座標と y 座標を指定します。 いずれかを渡すことができます、[ポイント](/windows/desktop/api/windef/ns-windef-tagpoint)データ構造体または[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)このパラメーターのオブジェクト。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

クリッピング領域と、デバイス画面の表示部分の両方で、ポイントがある必要があります。 すべてのデバイスでは、メンバー関数をサポートします。 詳細については、RC_BITBLT 機能を参照してください、`CDC::GetDeviceCaps`メンバー関数。 `SetPixelV` 高速`SetPixel`を実際に描画するポイントの色の値を返す必要はないためです。

##  <a name="setpolyfillmode"></a>  CDC::SetPolyFillMode

多角形の塗りつぶしモードを設定します。

```
int SetPolyFillMode(int nPolyFillMode);
```

### <a name="parameters"></a>パラメーター

*nPolyFillMode*<br/>
新しい塗りつぶしモードを指定します。 この値は、代替またはワインディングのいずれかにあります。 Windows の設定、既定のモードは代替です。

### <a name="return-value"></a>戻り値

成功した場合は以前の塗りつぶしモードそれ以外の場合 0 を返します。

### <a name="remarks"></a>Remarks

多角形の塗りつぶしモードは、代替は、システムは、各スキャン ラインに奇数し、偶数の多角形の辺の間の領域を塗りつぶします。 つまり、システムは、最初と 2 番目の側の間で、3 番目と 4 番目の側との間の領域を塗りつぶします。 このモードでは、既定値です。

多角形の塗りつぶしモードの頂点を結ぶときに、システムは、図が描いた領域を入力するかどうかを決定する方向を使用します。 多角形の場合は、各直線セグメントは、時計回りまたは反時計回りの方向で描画されます。 閉じた領域から、図の外側に描画される線が時計回りに直線セグメントを通過するたびにカウントがインクリメントされます。 行は、反時計回りの直線セグメントを通過して、ときに、カウントは減少します。 図形の外側の行に達したら、カウントが 0 以外の場合は、領域が入力されます。

##  <a name="setrop2"></a>  CDC::SetROP2

現在の描画モードを設定します。

```
int SetROP2(int nDrawMode);
```

### <a name="parameters"></a>パラメーター

*nDrawMode*<br/>
新しい描画モードを指定します。 次の値のいずれかを指定できます。

- R2_BLACK ピクセルは黒では常にします。

- R2_WHITE ピクセルは白では常にします。

- R2_NOP ピクセルは変更されません。

- R2_NOT ピクセルでは、画面の色の反転です。

- R2_COPYPEN ピクセルは、ペンの色です。

- R2_NOTCOPYPEN ピクセルでは、ペンの色の反転です。

- R2_MERGEPENNOT ピクセルがペンの色の組み合わせと画面の色の反転 (ピクセルの最終的な = (画面ピクセルではありません)、またはペン)。

- R2_MASKPENNOT ピクセルがペンの両方に共通する色の組み合わせと、画面の反転 (ピクセルの最終的な = (画面ピクセルではありません)、およびペン)。

- R2_MERGENOTPEN ピクセルが画面の色の組み合わせとペンの色の反転 (ピクセルの最終的な = (ペンではありません)、または画面ピクセル)。

- R2_MASKNOTPEN ピクセルが画面の両方に共通する色の組み合わせと、ペンの反転 (ピクセルの最終的な = (ペンではありません) と画面ピクセル)。

- R2_MERGEPEN ピクセルはペンの色、画面の色の組み合わせです (ピクセルの最終的な = ペンまたは画面ピクセル)。

- R2_NOTMERGEPEN ピクセルは R2_MERGEPEN の色の反転 (ピクセルの最終的な = なし (OR 画面ピクセルをペン))。

- R2_MASKPEN ピクセルは、ペンと画面の両方に共通の色の組み合わせです (ピクセルの最終的な = ペンと画面ピクセル)。

- R2_NOTMASKPEN ピクセルは R2_MASKPEN の色の反転 (ピクセルの最終的な = なし (ペンと画面ピクセル))。

- R2_XORPEN ピクセルは画面で、または両方ではなく、ペンでできる色の組み合わせです (ピクセルの最終的な = ペン XOR 画面ピクセル)。

- R2_NOTXORPEN ピクセルは R2_XORPEN の色の反転 (ピクセルの最終的な = なし (ペン XOR 画面ピクセル))。

### <a name="return-value"></a>戻り値

前の描画モード。

Windows SDK で指定された値のいずれかを指定することができます。

### <a name="remarks"></a>Remarks

描画モードでは、既に、表示画面上の色でペンの色と塗りつぶされたオブジェクトの内部を結合する方法を指定します。

描画モードはラスター デバイスだけです。ベクターのデバイスには適用されません。 描画モードは、AND、OR、および XOR (排他的 OR) は、二項演算子と単項演算がいないを使用して、2 つの変数のすべての可能なブール組み合わせを表すバイナリ ラスター オペレーション コードです。

##  <a name="setstretchbltmode"></a>  CDC::SetStretchBltMode

ビットマップの伸縮モードを設定、`StretchBlt`メンバー関数。

```
int SetStretchBltMode(int nStretchMode);
```

### <a name="parameters"></a>パラメーター

*nStretchMode*<br/>
ストレッチ モードを指定します。 次の値のいずれかを指定できます。

|[値]|説明|
|-----------|-----------------|
|BLACKONWHITE|排除し、既存のピクセルの色の値を使用して、論理 AND 演算を実行します。 モノクロ ビットマップは、このモードは白いピクセルが黒のピクセルを保持します。|
|COLORONCOLOR|ピクセル データを削除します。 このモードでは、その情報を保持しようとしないでピクセルの排除のすべての行を削除します。|
|ハーフトーン|先の四角形のピクセルのブロック元の四角形からピクセルにマップします。 ピクセルのコピー先のブロックの平均的な色では、ソース ピクセルの色を概算します。|
||ハーフトーン ストレッチ モードを設定した後、アプリケーションが Win32 関数を呼び出す必要があります[SetBrushOrgEx](/windows/desktop/api/wingdi/nf-wingdi-setbrushorgex)ブラシの原点を設定します。 これを行うに失敗した場合は、ブラシの不整合が発生します。|
|STRETCH_ANDSCANS|**Windows 95/98**:BLACKONWHITE と同じ|
|STRETCH_DELETESCANS|**Windows 95/98**:COLORONCOLOR と同じ|
|STRETCH_HALFTONE|**Windows 95/98**:ハーフトーンと同じです。|
|終了しました。|**Windows 95/98**:WHITEONBLACK と同じ|
|WHITEONBLACK|排除し、既存のピクセルの色の値を使用して、論理 OR 演算を実行します。 モノクロ ビットマップは、このモードは黒ピクセルが白のピクセルを保持します。|

### <a name="return-value"></a>戻り値

前の伸縮モード。 STRETCH_ANDSCANS、STRETCH_DELETESCANS、または終了したことができます。

### <a name="remarks"></a>Remarks

ビットマップの伸縮モードでは、関数を使用して圧縮されたビットマップから情報を削除する方法を定義します。

BLACKONWHITE (STRETCH_ANDSCANS) と WHITEONBLACK (終了した) モードは通常、モノクロ ビットマップのピクセルをフォア グラウンドを保持するために使用されます。 COLORONCOLOR (STRETCH_DELETESCANS) モードは通常、カラー ビットマップの色を保持するために使用されます。

ハーフトーン モードには、ソース イメージの他の 3 つのモードです。 より多くの処理が必要です。他よりも遅くなりますが、高品質のイメージを生成します。 またを注意`SetBrushOrgEx`ブラシの不整合を回避するために、ハーフトーン モードを設定した後に呼び出す必要があります。

追加の伸縮モードも、デバイス ドライバーの機能によって使用可能な場合があります。

##  <a name="settextalign"></a>  CDC::SetTextAlign

テキストの配置フラグを設定します。

```
UINT SetTextAlign(UINT nFlags);
```

### <a name="parameters"></a>パラメーター

*nFlags*<br/>
テキスト配置フラグを指定します。 フラグをポイントし、テキストの外接する四角形の間のリレーションシップを指定します。 ポイントには、現在の位置またはテキスト出力関数によって指定された座標のいずれかを指定できます。 テキストの外接する四角形は、テキスト文字列内の隣接する文字セルによって定義されます。 *NFlags*パラメーターは、次の 3 つのカテゴリから 1 つまたは複数のフラグを指定できます。 各カテゴリの 1 つのみのフラグを選択します。 最初のカテゴリには、x 方向のテキストの配置に影響します。

- TA_CENTER 外接する四角形の水平方向の中心点を配置します。

- TA_LEFT 外接する四角形の左側にある、ポイントを配置します。 これは、既定の設定です。

- TA_RIGHT 外接する四角形の右側にある、ポイントを配置します。

2 番目のカテゴリには、y 方向のテキストの配置に影響します。

- TA_BASELINE では、選択したフォントのベース ライン ポイントを配置します。

- TA_BOTTOM 外接する四角形の下部でポイントを配置します。

- TA_TOP 点と、外接する四角形の上部を揃えます。 これは、既定の設定です。

3 番目のカテゴリは、テキストが書き込まれるときに、現在の位置を更新するかどうかを決定します。

- テキスト出力関数の呼び出し後は、現在の位置 TA_NOUPDATECP で更新されません。 これは、既定の設定です。

- テキスト出力関数を呼び出すたびに TA_UPDATECP 更新現在の x 位置。 新しい位置がテキストの外接する四角形の右側にあります。 このフラグ設定されている場合、呼び出しで指定された座標、`TextOut`メンバー関数は無視されます。

### <a name="return-value"></a>戻り値

前のテキスト配置設定、成功した場合です。 下位バイトが水平方向の設定を格納し、高位バイトには、垂直方向の設定が含まれていますそれ以外の場合 0 を返します。

### <a name="remarks"></a>Remarks

`TextOut`と`ExtTextOut`表示またはデバイス上のテキストの文字列を配置するときに、メンバー関数がこれらのフラグを使用します。 フラグは、特定の時点と、テキストの外接する四角形の間のリレーションシップを指定します。 このポイントの座標をパラメーターとして渡される、`TextOut`メンバー関数。 テキスト文字列の文字が隣接するセルでテキストに外接する四角形が形成されます。

##  <a name="settextcharacterextra"></a>  CDC::SetTextCharacterExtra

文字間隔の量を設定します。

```
int SetTextCharacterExtra(int nCharExtra);
```

### <a name="parameters"></a>パラメーター

*nCharExtra*<br/>
各文字に追加するには、(論理単位) で余分なスペースの量を指定します。 現在のマップ モードでない場合`MM_TEXT`、 *nCharExtra*が変換され、最も近いピクセルに丸められます。

### <a name="return-value"></a>戻り値

前の文字間隔の量。

### <a name="remarks"></a>Remarks

GDI は、デバイス コンテキストに 1 行のテキストを書き込む際に、改行文字を含む、各文字に、この間隔を追加します。 文字間隔の既定値は 0 です。

##  <a name="settextcolor"></a>  CDC::SetTextColor

テキストの色を指定した色に設定します。

```
virtual COLORREF SetTextColor(COLORREF crColor);
```

### <a name="parameters"></a>パラメーター

*crColor*<br/>
RGB 色の値として、テキストの色を指定します。

### <a name="return-value"></a>戻り値

前のテキストの色の RGB 値。

### <a name="remarks"></a>Remarks

このデバイス コンテキストおよび色の間で変換のビットマップとモノクロ デバイス コンテキストにテキストを書き込むときにこのテキストの色が使用されます。

デバイスは、指定した色を表すことはできません、システムは最も近い物理色にテキストの色を設定します。 文字の背景色がで指定された、`SetBkColor`と`SetBkMode`メンバー関数。

### <a name="example"></a>例

  例をご覧ください[CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor)します。

##  <a name="settextjustification"></a>  CDC::SetTextJustification

文字列の区切り文字にスペースを追加します。

```
int SetTextJustification(
    int nBreakExtra,
    int nBreakCount);
```

### <a name="parameters"></a>パラメーター

*nBreakExtra*<br/>
(論理単位) でテキストの行に追加する余分な領域の合計を指定します。 現在のマップ モードでない場合`MM_TEXT`、このパラメーターで指定された値は、現在のマッピング モードに変換され、最も近いデバイス単位に丸められます。

*nBreakCount*<br/>
行に改行文字の数を指定します。

### <a name="return-value"></a>戻り値

1 つの関数が成功した場合それ以外の場合 0 を返します。

### <a name="remarks"></a>Remarks

アプリケーションで使用できます、`GetTextMetrics`フォントを取得するメンバー関数が文字を中断します。

後に、`SetTextJustification`メンバー関数が呼び出されると、テキスト出力関数の呼び出し (など`TextOut`) 改行文字の指定した数の間で均等に指定された余分なスペースを配布します。 改行文字は、空白文字 (ASCII 32) では、通常が、その他の文字としてのフォントが定義できます。

メンバー関数は、`GetTextExtent`は通常使用`SetTextJustification`します。 `GetTextExtent` 配置する前に指定された行の幅を計算します。 アプリケーションで指定する領域の量を決定できます、 *nBreakExtra*パラメーターによって返される値を減算して`GetTextExtent`配置後の文字列の幅から。

`SetTextJustification`さまざまなフォントで複数の実行を含む行を配置する関数を使用できます。 この場合、行を段階的な部分に作成して配置し、それぞれの実行を個別に書き込み必要があります。

配置中に発生する丸め誤差、ため、システムは、現在のエラーを定義する実行中の誤差を保持します。 複数の実行を含む行を配置`GetTextExtent`自動的に次の実行の程度を計算するときにこのエラーの用語を使用します。 これにより、新しい実行に、エラーをブレンドするテキスト出力関数です。

各行が配置された後は、次の行に組み込まれていますを防ぐためにこのエラーの用語をクリアする必要があります。 用語を呼び出すことによってクリア`SetTextJustification`で*nBreakExtra*を 0 に設定します。

##  <a name="setviewportext"></a>  CDC::SetViewportExt

デバイス コンテキストのビューポートの x 範囲と y 範囲を設定します。

```
virtual CSize SetViewportExt(
    int cx,
    int cy);

CSize SetViewportExt(SIZE size);
```

### <a name="parameters"></a>パラメーター

*cx*<br/>
(デバイス単位) で、ビューポートの x 範囲を指定します。

*cy*<br/>
(デバイス単位) で、ビューポートの y 範囲を指定します。

*size*<br/>
(デバイス単位) で、ビューポートの x 範囲と y 範囲を指定します。

### <a name="return-value"></a>戻り値

ビューポートの前のエクステントを[CSize](../../atl-mfc-shared/reference/csize-class.md)オブジェクト。 エラーが発生、返されるの x 座標と y 座標`CSize`オブジェクトの両方が 0 に設定します。

### <a name="remarks"></a>Remarks

デバイス コンテキストのウィンドウと共に、ビューポートは、GDI が実際のデバイスの座標系のポイントに論理座標系の点をマップする方法を定義します。 つまり、GDI 論理座標デバイス座標に変換する方法を定義します。

次のマッピング モードを設定すると、呼び出し`SetWindowExt`と`SetViewportExt`は無視されます。

|MM_HIENGLISH|MM_LOMETRIC|
|-------------------|------------------|
|MM_HIMETRIC|MM_TEXT|
|MM_LOENGLISH|MM_TWIPS|

MM_ISOTROPIC モードを設定すると、アプリケーションで呼び出す必要があります、`SetWindowExt`メンバー関数を呼び出す前に`SetViewportExt`します。

### <a name="example"></a>例

  例をご覧ください[付け](../../mfc/reference/cview-class.md#onpreparedc)します。

##  <a name="setviewportorg"></a>  CDC::SetViewportOrg

デバイス コンテキストのビューポートの原点を設定します。

```
virtual CPoint SetViewportOrg(
    int x,
    int y);

CPoint SetViewportOrg(POINT point);
```

### <a name="parameters"></a>パラメーター

*x*<br/>
ビューポートの原点の (デバイス単位) での x 座標を指定します。 値は、デバイスの座標システムの範囲でなければなりません。

*y*<br/>
ビューポートの原点の (デバイス単位) での y 座標を指定します。 値は、デバイスの座標システムの範囲でなければなりません。

*ポイント*<br/>
ビューポートの原点を指定します。 値は、デバイスの座標システムの範囲でなければなりません。 いずれかを渡すことができます、`POINT`構造または`CPoint`このパラメーターのオブジェクト。

### <a name="return-value"></a>戻り値

ビューポート (デバイス座標) での以前の原点を`CPoint`オブジェクト。

### <a name="remarks"></a>Remarks

デバイス コンテキストのウィンドウと共に、ビューポートは、GDI が実際のデバイスの座標系のポイントに論理座標系の点をマップする方法を定義します。 つまり、GDI 論理座標デバイス座標に変換する方法を定義します。

ビューポートの原点の GDI で指定された論理座標システムでのポイント、ウィンドウの原点のマップ先デバイス座標システムで位置をマークする、`SetWindowOrg`メンバー関数。 GDI は、ウィンドウの原点をビューポートの原点にマップするために必要な同じプロセスに従って、その他のすべてのポイントをマップします。 たとえば、ウィンドウの原点を中心点を中心円のすべてのポイントは、ビューポートの原点を中心点を中心円になります。 同様に、ウィンドウの原点を通過する行のすべてのポイントは、ビューポートの原点を通る行になります。

### <a name="example"></a>例

  例をご覧ください[付け](../../mfc/reference/cview-class.md#onpreparedc)します。

##  <a name="setwindowext"></a>  CDC::SetWindowExt

デバイス コンテキストに関連付けられているウィンドウの x 範囲と y 範囲を設定します。

```
virtual CSize SetWindowExt(
    int cx,
    int cy);

CSize SetWindowExt(SIZE size);
```

### <a name="parameters"></a>パラメーター

*cx*<br/>
ウィンドウの (論理単位) で x の範囲を指定します。

*cy*<br/>
ウィンドウの (論理単位) で y の範囲を指定します。

*size*<br/>
X- と y のエクステント (論理単位) で、ウィンドウを指定します。

### <a name="return-value"></a>戻り値

前のウィンドウ (論理単位) でのエクステントを`CSize`オブジェクト。 エラーが発生する、返された x 座標と y 座標場合`CSize`オブジェクトの両方が 0 に設定します。

### <a name="remarks"></a>Remarks

デバイス コンテキストのビューポート、ウィンドウは、デバイスの座標系の点に、GDI が論理座標系の点をマップする方法を定義します。

次のマッピング モードを設定すると、呼び出し`SetWindowExt`と`SetViewportExt`関数は無視されます。

- MM_HIENGLISH

- MM_HIMETRIC

- MM_LOENGLISH

- MM_LOMETRIC

- MM_TEXT

- MM_TWIPS

MM_ISOTROPIC モードを設定すると、アプリケーションで呼び出す必要があります、`SetWindowExt`メンバー関数は呼び出しの前に`SetViewportExt`します。

### <a name="example"></a>例

  例をご覧ください[付け](../../mfc/reference/cview-class.md#onpreparedc)します。

##  <a name="setwindoworg"></a>  CDC::SetWindowOrg

デバイス コンテキストのウィンドウの原点を設定します。

```
CPoint SetWindowOrg(
    int x,
    int y);

CPoint SetWindowOrg(POINT point);
```

### <a name="parameters"></a>パラメーター

*x*<br/>
ウィンドウの新しい配信元の論理の x 座標を指定します。

*y*<br/>
ウィンドウの新しい配信元の論理の y 座標を指定します。

*ポイント*<br/>
ウィンドウの新しい配信元の論理座標を指定します。 いずれかを渡すことができます、`POINT`構造または`CPoint`このパラメーターのオブジェクト。

### <a name="return-value"></a>戻り値

前のウィンドウの原点を`CPoint`オブジェクト。

### <a name="remarks"></a>Remarks

デバイス コンテキストのビューポート、ウィンドウは、デバイスの座標系の点に、GDI が論理座標系の点をマップする方法を定義します。

ウィンドウの原点がで指定されたデバイス座標システムでのポイント、ビューポートの原点が gdi 元となる論理座標系で位置をマーク、`SetWindowOrg`関数。 GDI は、ウィンドウの原点をビューポートの原点にマップするために必要な同じプロセスに従って、その他のすべてのポイントをマップします。 たとえば、ウィンドウの原点を中心点を中心円のすべてのポイントは、ビューポートの原点を中心点を中心円になります。 同様に、ウィンドウの原点を通過する行のすべてのポイントは、ビューポートの原点を通る行になります。

##  <a name="setworldtransform"></a>  CDC::SetWorldTransform

ワールド空間と指定したデバイス コンテキストのページの領域の 2 次元の線形変換を設定します。 この変換を使用して、スケール、回転、傾斜、またはグラフィックスの出力を変換することができます。

```
BOOL SetWorldTransform(const XFORM& rXform);
```

### <a name="parameters"></a>パラメーター

*rXform*<br/>
参照、 [XFORM](/windows/desktop/api/wingdi/ns-wingdi-tagxform)変換データを含む構造体。

### <a name="return-value"></a>戻り値

成功した場合に、0 以外の値を返します。

失敗した場合は 0 を返します。

拡張エラー情報を取得するには呼び出します[GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360)します。

### <a name="remarks"></a>Remarks

このメソッドは、Windows GDI 関数をラップ[SetWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-setworldtransform)します。

##  <a name="startdoc"></a>  CDC::StartDoc

新しい印刷ジョブが開始されるデバイス ドライバーに通知し、後続のすべての`StartPage`と`EndPage`まで同じジョブの下での呼び出しをスプールする必要があります、`EndDoc`呼び出しが行われます。

```
int StartDoc(LPDOCINFO lpDocInfo);
int StartDoc(LPCTSTR lpszDocName);
```

### <a name="parameters"></a>パラメーター

*lpDocInfo*<br/>
指す、[持つ](/windows/desktop/api/wingdi/ns-wingdi-_docinfoa)ドキュメント ファイルの名前と出力ファイルの名前を含む構造体。

*lpszDocName*<br/>
ドキュメント ファイルの名前を含む文字列へのポインター。

### <a name="return-value"></a>戻り値

関数が成功した場合、戻り値は 0 より大きいです。 この値は、ドキュメントの印刷ジョブの識別子です。

関数が失敗した場合、戻り値は 0 に等しいまたはそれよりも小さいです。

### <a name="remarks"></a>Remarks

これにより、1 つのページよりも長いドキュメントを他のジョブと混在しないされます。

Windows 3.1 以降のバージョンでは、この関数は、STARTDOC プリンター エスケープを置き換えます。 この関数を使用して、他の印刷ジョブでは、複数のページを含むドキュメントが混在しないように。

`StartDoc` メタファイル内では使用されません。

### <a name="example"></a>例

このコード フラグメント通常使うプリンターを取得します。 印刷ジョブを開き、「こんにちは, World!」の 1 ページにスプール 。 このコードで印刷されるテキストは、プリンターの論理ユニットにスケーリングされていない、ため、出力テキストがありますこのような小文字で、結果は読み取ることができません。 など、関数のスケーリング CDC `SetMapMode`、 `SetViewportOrg`、および`SetWindowExt`、スケーリングを修正するために使用できます。

[!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]

##  <a name="startpage"></a>  CDC::StartPage

データを受信するプリンター ドライバーを準備するには、このメンバー関数を呼び出します。

```
int StartPage();
```

### <a name="return-value"></a>戻り値

以上の値を関数が成功した場合は 0 または負の値を使用している場合、エラーが発生しました。

### <a name="remarks"></a>Remarks

`StartPage` NEWFRAME と BANDINFO エスケープよりも優先されます。

印刷の呼び出しのシーケンスの概要については、次を参照してください。、 [StartDoc](#startdoc)メンバー関数。

システムを無効に、`ResetDC`メンバー関数は呼び出しの間で`StartPage`と`EndPage`します。

### <a name="example"></a>例

  例をご覧ください[CDC::StartDoc](#startdoc)します。

##  <a name="stretchblt"></a>  CDC::StretchBlt

コピー元の四角形から、必要に応じてコピー先の四角形に合うようにビットマップを拡大または縮小してコピーします。

```
BOOL StretchBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>パラメーター

*x*<br/>
コピー先の四角形の左上隅を示す X 座標を (論理単位で) 指定します。

*y*<br/>
コピー先の四角形の左上隅を示す Y 座標を (論理単位で) 指定します。

*nWidth*<br/>
コピー先の四角形の幅を (論理単位で) 指定します。

*nHeight*<br/>
コピー先の四角形の高さを (論理単位で) 指定します。

*pSrcDC*<br/>
コピー元のデバイス コンテキストを指定します。

*xSrc*<br/>
コピー元の四角形の左上隅を示す X 座標を (論理単位で) 指定します。

*ySrc*<br/>
コピー元の四角形の左上隅を示す Y 座標を (論理単位で) 指定します。

*nSrcWidth*<br/>
コピー元の四角形の幅を (論理単位で) 指定します。

*nSrcHeight*<br/>
コピー元の四角形の高さを (論理単位で) 指定します。

*dwRop*<br/>
実行するラスター オペレーションを指定します。 ラスター オペレーション コードにより、現在のブラシ、有効なコピー元のビットマップ、およびコピー先のビットマップが関連する出力操作における、GDI による色の組み合わせが定義されます。 このパラメーターには、次のいずれかの値を指定できます。

- すべての出力を黒黒になります。

- DSTINVERT では、コピー先のビットマップを反転します。

- MERGECOPY では、パターンとブール型 AND 演算子を使用して元のビットマップを組み合わせます。

- MERGEPAINT では、ブール型 OR 演算子を使用してコピー先のビットマップを反転されたコピー元ビットマップを結合します。

- NOTSRCCOPY では、先に、反転されたコピー元ビットマップをコピーします。

- NOTSRCERASE では、ブール型 OR 演算子を使用して送信先と送信元のビットマップを組み合わせた結果を反転します。

- PATCOPY パターンをコピー先ビットマップにコピーします。

- PATINVERT は、ブール型 XOR 演算子を使用して、パターンとコピー先のビットマップを組み合わせます。

- PATPAINT は、ブール型 OR 演算子を使用して、パターンと反転されたコピー元ビットマップを組み合わせます。 さらに、ブール型 OR 演算子を使用して、この演算の結果とコピー先ビットマップを組み合わせます。

- ブール型 AND 演算子を使用して送信先と送信元のビットマップのピクセルを SRCAND を結合します。

- SRCCOPY は、元のビットマップをコピー先ビットマップにコピーします。

- SRCERASE では、コピー先のビットマップを反転し、ソース ビットマップをブール型 AND 演算子を使用して、結果を結合します。

- ブール型 XOR 演算子を使用して送信先と送信元のビットマップのピクセルを SRCINVERT 結合です。

- ブール型 OR 演算子を使用して送信先と送信元のビットマップのピクセルを SRCPAINT を結合します。

- すべての出力を白 WHITENESS になります。

### <a name="return-value"></a>戻り値

ビットマップが描画された場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

この関数は、コピー先デバイス コンテキストの伸縮モード (`SetStretchBltMode` で設定) を使用して、ビットマップを拡大または縮小する方法を決定します。

`StretchBlt`関数で指定されたソース デバイスからビットマップを移動する*pSrcDC*メンバー関数が呼び出されるデバイス コンテキスト オブジェクトによって表される変換先のデバイスにします。 *XSrc*、 *ySrc*、 *nSrcWidth*、および*nSrcHeight*パラメーターは、左上隅と元の四角形のディメンションを定義. *X*、 *y*、 *nWidth*、および*パラメーター nHeight*パラメーターは、左上隅と先の四角形の寸法を指定します。 指定されたラスター オペレーション*dwRop*元のビットマップと移動先デバイス上のビットを結合する方法を定義します。

`StretchBlt`場合、関数は、ビットマップのミラー イメージを作成しますの症状、 *nSrcWidth*と*nWidth*または*nSrcHeight*と*パラメーター nHeight。* パラメーターは異なります。 場合*nSrcWidth*と*nWidth*符号が異なる関数が x 軸に沿ったビットマップのミラー イメージを作成します。 場合*nSrcHeight*と*パラメーター nHeight*符号が異なる、関数は、y 軸に沿ったビットマップのミラー イメージを作成します。


  `StretchBlt` 関数は、メモリ内のコピー元ビットマップを拡大または縮小し、その結果をコピー先にコピーします。 パターンを結果とマージする場合、そのパターンは、拡大されたコピー元ビットマップがコピー先にコピーされるまでマージされません。 ブラシを使用する場合、そのブラシは、コピー先デバイス コンテキストで選択されたブラシです。 コピー先の座標は、コピー先デバイス コンテキストに従って変換されます。コピー元の座標は、コピー元デバイス コンテキストに従って変換されます。

コピー先ビットマップ、コピー元ビットマップ、およびパターン ビットマップの色の形式が異なる場合は、`StretchBlt` によって、コピー元ビットマップとパターン ビットマップが、コピー先ビットマップに合わせて変換されます。 変換では、コピー先デバイス コンテキストの前景色と背景色が使用されます。

モノクロ ビットマップをカラーに変換する必要がある場合、`StretchBlt` は白のビット (1) を背景色に、黒のビット (0) を前景色に設定します。 カラーをモノクロに変換するには、背景色に一致するピクセルを白 (1) に設定し、その他のすべてのピクセルを黒 (0) に設定します。 カラーのデバイス コンテキストの前景色と背景色は使用されます。

一部のデバイスでは、`StretchBlt` 関数がサポートされていません。 デバイスをサポートしているかどうかを判断する`StretchBlt`、呼び出し、`GetDeviceCaps`メンバー関数と RASTERCAPS インデックスと RC_STRETCHBLT フラグの戻り値を確認します。

##  <a name="strokeandfillpath"></a>  CDC::StrokeAndFillPath

パスの任意の開いている図形を閉じて、現在のペンを使用して、パスの外枠を描画する現在のブラシを使用してその内部を塗りつぶします。

```
BOOL StrokeAndFillPath();
```

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

デバイス コンテキストでは、閉じたパスを含める必要があります。 `StrokeAndFillPath`メンバー関数はパスにあるすべての開いている図形を閉じると同じ効果があり、ペンの幅が線の描画と塗りつぶされた領域があっても、ストロークの領域が重複しないことを除いて、個別にパスを入力します。

##  <a name="strokepath"></a>  CDC::StrokePath

現在のペンを使用して、指定されたパスを表示します。

```
BOOL StrokePath();
```

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

デバイス コンテキストでは、閉じたパスを含める必要があります。

##  <a name="tabbedtextout"></a>  CDC::TabbedTextOut

タブ ストップの位置の配列で指定した値にタブを展開する、指定した位置に文字の文字列を書き込むには、このメンバー関数を呼び出します。

```
virtual CSize TabbedTextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);

CSize TabbedTextOut(
    int x,
    int y,
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
```

### <a name="parameters"></a>パラメーター

*x*<br/>
文字列の開始点の論理の x 座標を指定します。

*y*<br/>
論理で文字列の開始点の y 座標を指定します。

*lpszString*<br/>
描画する文字列を指します。 文字の配列へのポインターを渡すことができます、 [CString](../../atl-mfc-shared/reference/cstringt-class.md)このパラメーターのオブジェクト。

*nCount*<br/>
文字列の文字数を指定します。 場合*nCount* -1 で、長さが計算されます。

*nTabPositions*<br/>
タブ ストップの位置の配列内の値の数を指定します。

*いる*<br/>
(論理単位) でのタブ ストップの位置を格納する配列を指します。 タブ ストップを昇順に並べ替え; 並べ替える必要があります。x の最小値、配列の最初の項目があります。

*nTabOrigin*<br/>
(論理単位) で元のタブの展開の開始位置の x 座標を指定します。

*str*<br/>
A`CString`の指定した文字を含むオブジェクト。

### <a name="return-value"></a>戻り値

(論理単位) で文字列としての寸法を`CSize`オブジェクト。

### <a name="remarks"></a>Remarks

現在選択されているフォントでテキストが書き込まれます。 場合*nTabPositions*は 0 と*いる*が null の場合、タブは、平均文字幅の 8 倍に拡張されます。

場合*nTabPositions* 1、位置はの最初の値で指定された距離で区切られます タブには、*いる*配列。 場合、*いる*配列には、1 つ以上の値が含まれています、タブ ストップがで指定された数まで、配列内の各値の設定は*nTabPositions*します。 *NTabOrigin*パラメーターにより、アプリケーションが呼び出す、`TabbedTextOut`複数回に 1 行の関数。 アプリケーションを呼び出す場合、関数は複数回で、 *nTabOrigin* 、関数は、すべてのタブで指定された位置を基準を展開するたびに同じ値に設定*nTabOrigin*します。

既定では、関数は現在位置を使用することも、更新することもありません。 アプリケーションが呼び出すことができますが、関数を呼び出すときに、現在の位置を更新するアプリケーションが必要な場合、[呼び出された](#settextalign)メンバー関数を*nFlags* TA_UPDATECP に設定します。 このフラグを設定すると場合、Windows は無視されます、 *x*と*y*に後続の呼び出しでパラメーター `TabbedTextOut`、代わりに、現在の位置を使用します。

##  <a name="textout"></a>  CDC::TextOut

現在選択されているフォントを使用して、文字列を指定位置から書き込みます。

```
virtual BOOL TextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount);

BOOL TextOut(
    int x,
    int y,
    const CString& str);
```

### <a name="parameters"></a>パラメーター

*x*<br/>
テキストの始点の論理的な X 座標を指定します。

*y*<br/>
テキストの始点の論理的な Y 座標を指定します。

*lpszString*<br/>
描画される文字列を指します。

*nCount*<br/>
文字列の文字数を指定します。

*str*<br/>
描画される文字が含まれる `CString` オブジェクト。

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

文字の起点は文字セルの左上隅です。 既定では、関数は現在位置を使用することも、更新することもありません。

アプリケーションを呼び出すときに、現在の位置を更新する必要があるかどうか`TextOut`、アプリケーションが呼び出すことができます、`SetTextAlign`メンバー関数を*nFlags* TA_UPDATECP に設定します。 このフラグを設定すると場合、Windows は無視されます、 *x*と*y*に後続の呼び出しでパラメーター `TextOut`、代わりに、現在の位置を使用します。

### <a name="example"></a>例

  例をご覧ください[cdc::beginpath](#beginpath)します。

##  <a name="transparentblt"></a>  CDC::TransparentBlt

コピー先のデバイス コンテキストに、指定したソース デバイス コンテキストからのピクセルの四角形に対応する色データのビット ブロック転送するには、このメンバー関数を呼び出します。

```
BOOL TransparentBlt(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    UINT clrTransparent);
```

### <a name="parameters"></a>パラメーター

*xDest*<br/>
論理ユニットは、先の四角形の左上隅の x 座標を指定します。

*yDest*<br/>
論理ユニットは、先の四角形の左上隅の y 座標を指定します。

*nDestWidth*<br/>
論理ユニットは、先の四角形の幅を指定します。

*nDestHeight*<br/>
論理ユニットは、先の四角形の高さを指定します。

*pSrcDC*<br/>
元のデバイス コンテキストへのポインター。

*xSrc*<br/>
論理ユニットは、元の四角形の x 座標を指定します。

*ySrc*<br/>
論理ユニットは、元の四角形の y 座標を指定します。

*nSrcWidth*<br/>
論理ユニットは、元の四角形の幅を指定します。

*nSrcHeight*<br/>
論理ユニットは、元の四角形の高さを指定します。

*clrTransparent*<br/>
コピー元のビットマップが透明として扱うの RGB 色。

### <a name="return-value"></a>戻り値

成功した場合は TRUE、それ以外の場合は FALSE。

### <a name="remarks"></a>Remarks

`TransparentBlt` 透過性は、します。は、RGB 色が示される*clrTransparent*転送の透過的なレンダリングします。

詳細については、次を参照してください。 [TransparentBlt](/windows/desktop/api/wingdi/nf-wingdi-transparentblt) Windows SDK に含まれています。

##  <a name="updatecolors"></a>  CDC::UpdateColors

更新プログラム現在を照合することによって、デバイス コンテキストのクライアント領域は、システム パレットをピクセル単位でのクライアント領域の色します。

```
void UpdateColors();
```

### <a name="remarks"></a>Remarks

実現論理パレットの非アクティブなウィンドウを呼び出すことが`UpdateColors`システム パレットが変更されたときに、クライアント領域を再描画する代わりにします。

色パレットの使用に関する詳細については、次を参照してください。[この](/windows/desktop/api/wingdi/nf-wingdi-updatecolors)Windows SDK に含まれています。

`UpdateColors`メンバー関数は通常、更新クライアント領域の領域を再描画するよりも高速です。 ただし、関数は、システム パレットを変更する前に、各ピクセルの色に基づいた色変換を実行するため、この関数を呼び出すたびにいくつかの色の精度が失われる結果します。

##  <a name="widenpath"></a>  CDC::WidenPath

パスがデバイス コンテキストに現在選択されているペンを使用して描画された場合に描画される領域として、現在のパスを再定義します。

```
BOOL WidenPath();
```

### <a name="return-value"></a>戻り値

正常終了した場合は 0 以外を返します。それ以外の場合は 0 を返します。

### <a name="remarks"></a>Remarks

この関数が成功すると、現在のペンが幾何学的ペンの 2 つ目のバージョンで作成された場合にのみ`CreatePen`メンバー関数は、ペンがの最初のバージョンで作成された場合または`CreatePen`1 以上のデバイス単位で、幅をします。 デバイス コンテキストでは、閉じたパスを含める必要があります。 任意のベジエ曲線のパスでは、直線のおおよその拡張の曲線のシーケンスに変換されます。 そのため、ベジエ曲線内に残っていない後にパス`WidenPath`が呼び出されます。

## <a name="see-also"></a>関連項目

[CObject クラス](../../mfc/reference/cobject-class.md)<br/>
[階層図](../../mfc/hierarchy-chart.md)<br/>
[CPaintDC クラス](../../mfc/reference/cpaintdc-class.md)<br/>
[CWindowDC クラス](../../mfc/reference/cwindowdc-class.md)<br/>
[CClientDC クラス](../../mfc/reference/cclientdc-class.md)<br/>
[CMetaFileDC クラス](../../mfc/reference/cmetafiledc-class.md)
