---
title: TN035:Visual C での複数のリソース ファイルとヘッダー ファイルの使用
ms.date: 11/04/2016
f1_keywords:
- vc.resources
helpviewer_keywords:
- resource files, multiple
- TN035
ms.assetid: 1f08ce5e-a912-44cc-ac56-7dd93ad73fb6
ms.openlocfilehash: 0493dd45caf5eb78da435987a4590442a908a5a3
ms.sourcegitcommit: 72583d30170d6ef29ea5c6848dc00169f2c909aa
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/18/2019
ms.locfileid: "58772765"
---
# <a name="tn035-using-multiple-resource-files-and-header-files-with-visual-c"></a>TN035:Visual C での複数のリソース ファイルとヘッダー ファイルの使用

> [!NOTE]
>  次のテクニカル ノートは、最初にオンライン ドキュメントの一部とされてから更新されていません。 結果として、一部のプロシージャおよびトピックが最新でないか、不正になります。 最新の情報について、オンライン ドキュメントのキーワードで関係のあるトピックを検索することをお勧めします。

このノートでは、Visual C++ のリソース エディターが、単一プロジェクト内または複数のプロジェクト間で共有されている複数のリソース ファイルとヘッダー ファイルをサポートする方法と、そのサポートを活用する方法について説明します。 このノートでは、次の質問に回答します。

- 複数のリソース ファイルやヘッダー ファイル、プロジェクトとその方法に分割する場合がありますと

- 一般的なヘッダーをどのように共有します。2 つの H ファイルです。RC ファイル

- プロジェクト リソースを複数に分割するにはどうの操作を行います。RC ファイル

- (およびツール) 管理すれば間の依存関係をビルドします。RC では、します。CPP と。H ファイル

プロジェクトに追加のリソース ファイルを追加した場合は、追加されたファイル内のリソースを ClassWizard が認識しないことに注意してください。

このノートは、上記の質問に回答するために次のように構成されています。

- **どの Visual C 管理リソース ファイルとヘッダー ファイルの概要**Visual C でのリソースには設定が含まれていますコマンドが複数のリソース ファイルと同じプロジェクト内のヘッダー ファイルを使用するを使用する方法の概要を説明します。

- **AppWizard で作成したの分析です。RC とします。H ファイル**AppWizard で作成したアプリケーションで使用される複数のリソースとヘッダー ファイルを検索します。 これらのファイルは、プロジェクトに追加する可能性のあるリソース ファイルやヘッダー ファイルの適切なモデルとして機能します。

- **追加のヘッダー ファイルを含む**複数のヘッダー ファイルをインクルードして、操作を行う方法の詳細を提供しますについて説明します。

- **2 つのヘッダー ファイルを共有します。RC ファイル**複数間で 1 つのヘッダー ファイルを共有する方法を示しています。別々 のプロジェクトや、同じプロジェクト内の RC ファイル。

- **同じプロジェクト内の複数のリソース ファイルを使用して**プロジェクトを複数に分割する場所について説明します。RC ファイル、および操作を行う方法の詳細を提供します。

- **Visual C ファイルを編集できないの強制**Visual C が編集およびカスタム リソースを誤って再フォーマットしていないことを確認することできる方法も説明します。

- **複数の Visual C で編集したによって共有されるシンボルを管理します。RC ファイル**複数間で同じシンボルを共有する方法について説明します。RC ファイルと重複する ID 数値を割り当てることを回避する方法。

- **間の依存関係を管理します。RC では、します。CPP と。H ファイル**Visual C が不要な再コンパイルを回避する方法について説明します。リソース シンボル ファイルに依存する CPP ファイル。

- **どの Visual C 管理セットが含まれています情報**Visual C の追跡方法 (入れ子になった) 複数に関する技術的な詳細を提供します。RC ファイルと複数のヘッダー ファイルを #include によってインクルードされた、します。RC ファイルです。

**リソース ファイルとヘッダー ファイルを管理する方法の Visual C の概要**

Visual C++ では、単一の .RC リソース ファイルとそれに対応する .H ヘッダー ファイルを、緊密に結合されたファイル ペアとして管理します。 .RC ファイル内でリソースを編集および保存すると、対応する .H ファイル内でシンボルを間接的に編集および保存することになります。 (Visual C++ の MDI ユーザー インターフェイスを使用して) 一度に複数の .RC ファイルを開いて編集することができますが、任意の .RC ファイルを対象として、ただ 1 つの対応するヘッダー ファイルを間接的に編集していることになります。

**シンボル ヘッダー ファイル**

既定では、リソース ファイル (たとえば、MYAPP.RC) の名前にかかわりなく、Visual C++ は対応するヘッダー ファイルに必ず RESOURCE.H という名前を付けます。 使用して、**リソース ファイルのインクルード**コマンドから、**ビュー** Visual C で、メニューでシンボル ヘッダー ファイルのファイルを更新してこのヘッダー ファイルの名前を変更することができます、 **には設定が含まれています** ダイアログ ボックス。

**読み取り専用シンボル ディレクティブ**

Visual C++ はどの特定の .RC ファイルに対しても 1 つのヘッダー ファイルのみを編集しますが、Visual C++ では追加の読み取り専用ヘッダー ファイル内で定義されているシンボルへの参照をサポートします。 使用して、**リソース ファイルのインクルード**コマンドを**ビュー** ] メニューの [Visual C では、読み取り専用として追加の読み取り専用ヘッダー ファイルの任意の数を指定できます。 "読み取り専用" という制限は .RC ファイル内で新しいリソースを追加するときに、読み取り専用ヘッダー ファイル内で定義されたシンボルを使用できること、ただし、リソースを削除した場合でも、シンボルは引き続き読み取り専用ヘッダー ファイル内で定義されたままになることを意味します。 読み取り専用シンボルに対して割り当てられた数値を変更することはできません。

**コンパイル時ディレクティブ**

Visual C++ ではリソース ファイルの入れ子、つまり .RC ファイルの中で #include を使用し、他の .RC ファイルをインクルードする方法をサポートしています。 Visual C++ を使用して特定の .RC ファイルを編集すると、#include によってインクルードされたファイル内のどのリソースも表示されません。 ただし、その .RC ファイルをコンパイルするときに、#include によってインクルードされたファイルもコンパイルされます。 使用して、**リソースが含まれています**コマンドから、**ビュー** ] メニューの [Visual C では、任意の数を指定できます # インクルードします。RC ファイルをそのままコンパイル時に追加します。

動作に注意してください。 Visual c に読み取る場合、します。RC ファイルを # 他の include します。RC ファイルを*いない*コンパイル時ディレクティブとして指定します。 この状況は、以前にテキスト エディターを使用して手動で保守していた .RC ファイルを、Visual C++ に読み込む場合に発生する可能性があります。 Visual C++ は インクルードされた .RC ファイルを読み取る場合は、インクルードされたリソースを親 .RC ファイルにマージします。 親 .RC ファイルを保存するときに、#include ステートメントは実際には、インクルードされたリソースで置き換えられます。 削除する必要がありますこのマージが発生するしたくない場合、#、親からのステートメントの include します。RC ファイル*以前*Visual C; に読み込むことにし、Visual C を使用して再度追加同じ #include ステートメントは、コンパイル時ディレクティブ。

Visual C に保存します。RC ファイル設定が含まれています (シンボル ヘッダー ファイルや読み取り専用シンボル ディレクティブでは、コンパイル時) の情報 #include ディレクティブ*と*TEXTINCLUDE リソース。 TEXTINCLUDE リソース、通常どおりに使用すると、対処する必要はありませんが、実装の詳細についてで[方法 Visual C は管理設定が含まれています情報](#_mfcnotes_tn035_set_includes)します。

**AppWizard で作成したの分析です。RC とします。H ファイル**

AppWizard が生成したアプリケーション コードを調べると、Visual C++ が複数のリソース ファイルとヘッダー ファイルを管理する方法を把握できます。 以下で検討するコードは、既定のオプションを使用して AppWizard で生成した MYAPP アプリケーションから抜粋したものです。

AppWizard で作成したアプリケーションは、次の図に要約するように、複数のリソース ファイルと複数のヘッダー ファイルを使用します。

```
RESOURCE.H     AFXRES.H
\       /
\     /
    MYAPP.RC
|
|
    RES\MYAPP.RC2
    AFXRES.RC
    AFXPRINT.RC
```

Visual C++ の [ファイル] - [インクルード ファイルの設定] コマンドを使用して、これら複数のファイルの関係を表示できます。

MYAPP します。RC、Visual C を使用して編集できるアプリケーション リソース ファイル。

RESOURCE.H は、アプリケーション固有のヘッダー ファイルです。 Visual C++ のヘッダー ファイルの既定の名前付けに整合した方法で、このファイルに対して AppWizard によって必ず RESOURCE.H という名前が付けられます。 このヘッダー ファイルに対応する #include は、リソース ファイル (MYAPP.RC) 内の最初のステートメントです。

```
//Microsoft Visual C++ generated resource script
//
#include "resource.h"
```

RES\MYAPP します。Visual C では編集できませんが、最終的にコンパイルされる対象 RC2 を含むリソース。EXE ファイルです。 Visual C++ は (このリリースの新しい機能である) バージョン リソースを含め、標準のリソースすべてを編集できるため、AppWizard は既定ではこのようなリソースを作成しません。 開発者が独自のカスタム形式リソースをこのファイルに追加しようとする場合は、AppWizard によって空のファイルが生成されます。

カスタム形式リソースを使用する場合は、そのリソースを RES\MYAPP.RC2 に追加し、Visual C++ のテキスト エディターを使用して編集することができます。

AFXRES.RC と AFXPRINT.RC には、フレームワークの一部の機能で必要とされる標準的なリソースが含まれます。 RES\MYAPP.RC2 と同様に、フレームワークによって提供されるこれらの 2 つは MYAPP.RC の最後にインクルードされるリソース ファイルです。またこれらは、[インクルード ファイルの設定] ダイアログ ボックスの [コンパイル時に追加するファイル] で指定されます。 したがって、Visual C++ で MYAPP.RC を編集するときに、これらのフレームワーク リソースを直接表示または編集することはありませんが、これらはアプリケーションのバイナリ .RES ファイルと最終的な .EXE ファイルにコンパイルされます。 詳細については、それらの修正の手順も含め、標準的なフレームワーク リソースを参照してください。[テクニカル ノート 23](../mfc/tn023-standard-mfc-resources.md)します。

AFXRES.H は、フレームワークによって使用され、特に AFXRES.RC 内で使用される、`ID_FILE_NEW` のような標準的なシンボルを定義します。 また、AFXRES.H 内の #include で指定されている WINRES.H には、WINDOWS.H のサブセットが含まれていて、これらは AFXRES.RC と同様、Visual C++ によって生成される .RC ファイルで必要とされるものです。 AFXRES.H 内で定義されたシンボルは、アプリケーションのリソース ファイル (MYAPP.RC) を編集するときに使用できます。 たとえば、`ID_FILE_NEW` は MYAPP.RC 内のメニュー リソースにある File New メニュー項目に関連して使用されます。 フレームワークで定義されたこれらのシンボルを変更または削除することはできません。

## <a name="_mfcnotes_tn035_including"></a> 追加のヘッダー ファイルを含む

AppWizard で作成したアプリケーションには、2 つのヘッダー ファイルが含まれます。リソースです。H およびコマします。H. RESOURCE.H のみがアプリケーション固有です。 次の状況では、追加の読み取り専用なヘッダー ファイルをインクルードする必要が生じることがあります。

ヘッダー ファイルは、外部ソースから提供することがあります。または、複数のプロジェクト間でヘッダー ファイルを共有するか、同じプロジェクトの複数の部分で共有することもあります。

ヘッダー ファイルには形式とコメントがあり、そのファイルを保存するときに、Visual C++ がこれらに変更を加えるか除外することは望ましくありません。 たとえば、次のようにシンボル算術演算を使用する #define を保持したいとします。

```
#define RED 0
#define BLUE 1
#define GREEN 2
#define ID_COLOR_BUTTON 1001
#define ID_RED_BUTTON (ID_COLOR_BUTTON + RED)
#define ID_BLUE_BUTTON (ID_COLOR_BUTTON + BLUE)
#define ID_GREEN_BUTTON (ID_COLOR_BUTTON + GREEN)
```

使用して追加の読み取り専用ヘッダー ファイルを含めることができます、**リソース ファイルのインクルード**を指定するコマンド、# として 2 つ目の読み取り専用シンボル ディレクティブとしてステートメントを include:

```
#include "afxres.h"
#include "second.h"
```

ファイル関係の新しい図は次のようになります。

```
    AFXRES.H
RESOURCE.H     SECOND.H
\       /
\     /
    MYAPP.RC
|
|
    RES\MYAPP.RC2
    AFXRES.RC
    AFXPRINT.RC
```

**2 つのヘッダー ファイルを共有します。RC ファイル**

異なるプロジェクト内、または多くの状況では同じプロジェクト内にある、2 つの .RC ファイル間で 1 つのヘッダー ファイルを共有したいと考えることがあります。 この作業を行うには、既に説明した [読み取り専用ヘッダー ファイル] の手法を両方の .RC ファイルに適用します。 2 つの .RC ファイルが別のアプリケーション (別のプロジェクト) に対応している場合は、結果は次の図に示すとおりです。

```
    RESOURCE.H AFXRES.H   RESOURCE.H
(for MYAPP1) SECOND.H   (for MYAPP2)
\       /     \       /
\     /       \     /
    MYAPP1.RC MYAPP2.RC */    \        /     \ */      \      /       \
RES\MYAPP1.RC2  AFXRES.RC     RES\MYAPP2.RC2
    AFXPRINT.RC
```

2 番目のヘッダー ファイルが、同じアプリケーション (プロジェクト) 内の 2 つの .RC ファイルによって共有される状況は、後で説明します。

**同じプロジェクト内の複数のリソース ファイルの使用**

Visual C++ およびリソース コンパイラは、1 つの .RC ファイル内で #include を使用して別の .RC ファイルをインクルードする方法で、同じプロジェクト内で複数の .RC ファイルをサポートします。 複数の入れ子も許可されます。 プロジェクトのリソースを複数の .RC ファイルに分割するさまざまな理由があります。

- リソース ファイルを複数の .RC ファイルに分割した場合は、複数のプロジェクト チーム メンバーの間で多数のリソースを容易に管理できるようになります。 ファイルのチェックアウトおよび変更のチェックインの目的でソース管理パッケージを使用する場合は、リソースを複数の .RC ファイルに分割すると、リソースに対する変更の管理全体をより詳細に制御できるようになります。

- #ifdef、#endif、#define のようなプリプロセッサ ディレクティブを使用する場合は、リソースの一部を対象として、リソース コンパイラによってコンパイルされる読み取り専用リソースの中にそれらを分離する必要があります。

- Visual C++ の中で、複数のコンポーネント .RC ファイルの読み込みと保存は、1 つの複合 .RC ファイルより高速に実行されます。

- テキスト エディターを使用して、人間が認識できる形式のリソースを維持することを希望する場合は、Visual C++ で編集する .RC ファイルとは別の .RC ファイルを用意し、その中で維持する必要があります。

- ユーザー定義のリソースを、別の特殊なデータ エディターで解釈できるバイナリまたはテキスト形式で保持する必要がある場合は、別の .RC ファイルでそのリソースを維持する必要があります。その結果、Visual C++ が形式を 16 進データに変更することはありません。 します。MFC Advanced Concepts サンプル内の WAV (サウンド) ファイル リソース[SPEAKN](../overview/visual-cpp-samples.md)例があります。

[インクルード ファイルの設定] ダイアログ ボックス内の [コンパイル時に追加するファイル] で、SECOND.RC の #include を指定できます。

```
#include "res\myapp.rc2"  // non-Visual C++ edited resources
#include "second.rc"  // THE SECOND .RC FILE

#include "afxres.rc"  // Standard components
#include "afxprint.rc"  // printing/print preview resources
```

結果は次の図のようになります。

```
RESOURCE.H     AFXRES.H
\       /
\     /
    MYAPP.RC
|
|
    RES\MYAPP.RC2
    SECOND.RC
    AFXRES.RC
    AFXPRINT.RC
```

[コンパイル時に追加するファイル] を使用して、Visual C++ で編集可能なリソースと編集不可能なリソースを複数の .RC ファイルに編成することができます。ここで、"マスター" の MYAPP.RC は、他の .RC ファイルの #include を行うだけで、それ以外は何もしません。 Visual C++ プロジェクト .MAK ファイルを使用する場合は、プロジェクト内に "マスター" .RC ファイルをインクルードする必要があります。その結果、その中でインクルードされているすべてのリソースがアプリケーションにコンパイルされます。

**編集不可能な Visual C ファイルの適用**

AppWizard で作成した RES\MYAPP します。RC2 ファイル操作を行うリソースを含むファイルの例は、*いない*Visual C で誤って読み取りし、それを記述する書式設定情報が失われることバックアップします。 このような事態を防止するには、RES\MYAPP.RC2 ファイルの先頭に次の行を記述します。

```
#ifdef APSTUDIO_INVOKED
#error this file is not editable by Visual C++
#endif //APSTUDIO_INVOKED
```

Visual C をコンパイルするとします。RC ファイル定義`APSTUDIO_INVOKED`だけでなく`RC_INVOKED`します。 仮に AppWizard で作成したファイル構造が破損していて、Visual C++ が上記の #error 行を読み取った場合は、Visual C++ は致命的なエラーを報告し、.RC ファイルの読み取りを中止します。

**複数の Visual C で編集したによって共有されるシンボルを管理します。RC ファイル**

リソースを複数の .RC ファイルに分割し、それらを Visual C++ で個別に編集する場合は、2 つの問題が生じます。

- 複数の .RC ファイル間で同じシンボルを共有したいと考えることがあります。

- 個別のリソース (シンボル) に同じ ID 数値を割り当てることを避けるために、Visual C++ を支援する必要があります。

次の図に、最初の問題に対処するための .RC ファイルと .H ファイルの構成を示します。

```
    MYAPP.RC */         \ */           \
MYSTRS.H   / MYSHARED.H  \  MYMENUS.H
\    /    /      \   \    \
\  /    /        \   \    \
    MYSTRS.RC MYMENUS.RC
```

この例では、文字列リソースを 1 つのリソース ファイル、MYSTRS.RC に保存し、メニューを別のファイル、MYMENUS.RC で保持します。 コマンドなどに対応する一部のシンボルは、2 つのファイル間で共有する必要が生じることがあります。 たとえば、ID_TOOLS_SPELL は、[ツール] メニューの [スペル] 項目に対応するメニュー コマンド ID である可能性があります。または、これは、アプリケーションのメイン ウィンドウのステータス バー内で、フレームワークによって表示されるコマンド プロンプトの文字列 ID である可能性もあります。

ID_TOOLS_SPELL シンボルは、共有ヘッダー ファイル、MYSHARED.H 内で保持されます。 開発者はテキスト エディターを使用し、この共有ヘッダー ファイルを手動で保守します。Visual C++ がこのファイルを直接編集することはありません。 2 つのリソースで MYSTRS をファイルします。RC および MYMENUS します。指定する RC、#include MYSHARED します。MYAPP の読み取り専用のディレクティブで H します。RC を使用して、**リソースが含まれています**コマンド、前述のとおりです。

シンボルを使用してリソースを識別しようとする前に、どのシンボルを共有する予定なのか予測すると便利です。 シンボルを共有ヘッダー ファイルに追加します.RC ファイルに対応する [読み取り専用のヘッダー ファイル] の中でまだ共有ヘッダー ファイルをインクルードしていない場合は、そのシンボルを使用する前に、#include を指定します。 シンボルをこの方法で共有することを想定していない場合は、たとえばシンボルを MYSTRS.RC 内で使用する前に、シンボルに対応する #define ステートメントを (テキスト エディターを使用して) 手動で MYMENUS.H から MYSHARED.H に移動する必要が生じます。

複数の .RC ファイル内でシンボルを管理する場合も、個別のリソース (シンボル) に対して同じ ID 数値を割り当てることを防止するために、Visual C++ を支援する必要があります。 特定の .RC ファイルに対して、Visual C++ は 4 つの ID ドメインのそれぞれで、インクリメンタル形式で ID を割り当てます。 複数の編集セッションの間も、Visual C++ は .RC ファイルに対応するシンボル ヘッダー ファイルの各ドメインで自らが最後に割り当てた ID を追跡しています。 次に、空の (新しい) .RC ファイルに対応する APS_NEXT の値を示します。

```
#define _APS_NEXT_RESOURCE_VALUE  101
#define _APS_NEXT_COMMAND_VALUE   40001
#define _APS_NEXT_CONTROL_VALUE   1000
#define _APS_NEXT_SYMED_VALUE     101
```

`_APS_NEXT_RESOURCE_VALUE` ダイアログ リソース、メニュー リソースなどのために使用する次のシンボル値です。 リソース シンボル値の有効な値の範囲は 1 ～ 0x6FFF です。

`_APS_NEXT_COMMAND_VALUE` コマンドの識別に使用される次のシンボル値です。 コマンド シンボル値の有効な値の範囲は 0x8000 ～ xDFFF です。

`_APS_NEXT_CONTROL_VALUE` ダイアログ コントロールの使用 [次へ] のシンボル値です。 ダイアログ コントロール値の有効な値の範囲は 8 ～ 0xDFFF です。

`_APS_NEXT_SYMED_VALUE` シンボル値を手動で割り当てるときに発行される次のシンボル値は、シンボル ブラウザーで新しいコマンドを使用しています。

Visual C++ は、新しい .RC ファイルを作成するときに、最小の有効な値より少し大きい値を使用して割り当てを開始します。 AppWizard も、これらの値を、MFC アプリケーションに適切な値より少し大きい値に初期化します。 ID 値の範囲の詳細については、次を参照してください。[テクニカル ノート 20](../mfc/tn020-id-naming-and-numbering-conventions.md)します。

同じプロジェクトであっても、新しいリソース ファイルを作成するたびに Visual C を定義、同じようになりました`_APS_NEXT_`値。 これは、たとえば 2 つの異なる .RC ファイルの中で複数のダイアログを追加する場合に、異なるダイアログに対して #define の同じ値が割り当てられる可能性が非常に高いことを意味します。 たとえば、最初の .RC ファイル内の IDD_MY_DLG1 は、2 番目の .RC ファイル内にあるIDD_MY_DLG2 と同じ番号 101 を割り当てられる可能性があります。

これを回避するには、各 .RC ファイル内の 4 つの ID ドメインのそれぞれで、個別の数値範囲を予約する必要があります。 これには、手動で更新、`_APS_NEXT`のそれぞれの値、します。RC ファイル**する前に**リソースの追加を開始します。 たとえば場合、最初。RC ファイルは、既定値を使用して`_APS_NEXT`値は、以下の割り当てをすることもできますし、`_APS_NEXT`が 2 番目の値。RC ファイル:

```
#define _APS_NEXT_RESOURCE_VALUE  2000
#define _APS_NEXT_COMMAND_VALUE   42000
#define _APS_NEXT_CONTROL_VALUE   2000
#define _APS_NEXT_SYMED_VALUE     2000
```

もちろん、Visual C++ が最初の .RC ファイル内で多数の ID を割り当て、その結果、2 番目の .RC ファイル用に予約した ID 数値との重複が始まる可能性はあります。 この現象が発生しないように、十分に大きい範囲を予約する必要があります。

**間の依存関係を管理します。RC では、します。CPP と。H ファイル**

Visual C++ は .RC ファイルを保存するときに、シンボルに対する変更を、対応する RESOURCE.H ファイルに保存します。 .RC ファイル内のリソースを参照するあらゆる .CPP ファイルは、RESOURCE.H ファイルの #include を行う必要があります。これは通常、プロジェクトのマスター ヘッダー ファイル内で行うことになります。 この結果、ソース ファイル内でヘッダーの依存関係をスキャンする開発環境の内部プロジェクト管理が原因で、望ましくない副作用につながります。 Visual C++ 内で新しいシンボルを追加するたびに、RESOURCE.H の #include を行うすべての .CPP ファイルを再コンパイルする必要が生じます。

Visual C++ では、RESOURCE.H ファイルの最初の行として次のコメントを含めることにより、RESOURCE.H の依存関係を回避できます。

```
//{{NO_DEPENDENCIES}}
```

開発環境では RESOURCE.H に対する変更を無視することによってこのコメントを解釈し、依存先の .CPP ファイルの再コンパイルを不要にします。

Visual C++ は .RC ファイルを保存するときに必ず、.RC ファイルに//{{NO_DEPENDENCIES}} コメント行を追加します。 特定の状況では、RESOURCE.H に対するビルド依存関係を回避することが原因で、リンク時に検出されない実行時エラーが発生する可能性があります。 たとえば、再コンパイルされないリソースを .CPP ファイルが参照している状況で、シンボル ブラウザーを使用して、リソースのシンボルに対して割り当てられる数値を変更する場合は、そのリソースを正しく見つけることができず、アプリケーションの実行時にリソースが読み込まれません。 このような場合は、する必要があります明示的に再コンパイルするいずれか。わかっている CPP ファイルは、リソースのシンボルの変更の影響を受けます。H または選択**すべてリビルド**します。 特定のリソース グループのシンボル値を頻繁に変更する必要があれば、おそらくに表示されますより便利でこれらのシンボルを別の読み取り専用ヘッダー ファイルに分割する方が安全上のセクションで説明した[など追加のヘッダー ファイル](#_mfcnotes_tn035_including)します。

## <a name="_mfcnotes_tn035_set_includes"></a> Visual C を管理する方法はセットが含まれる情報**

前述のように、[ファイル] メニューの [インクルード ファイルの設定] コマンドで 3 種類の情報を指定できます。

- [シンボル用のヘッダー ファイル]

- [読み取り専用ヘッダー ファイル]

- [コンパイル時に追加するファイル]

次に、Visual C++ がこれらの情報を .RC ファイル内で保持する方法について説明します。 Visual C++ を使用するうえでこの情報は必須ではありませんが、[インクルード ファイルの設定] に関する理解を深め、より自信を持ってこの機能を使用できるようになる可能性があります。

格納されているは、上記の 3 種類の情報の設定が含まれていますが、します。2 つの形式の RC ファイル:(1) #include include またはその他のディレクティブ解釈可能なリソース コンパイラでは、および (2) と特殊な TEXTINCLUDE のリソースが Visual C でのみ解釈します。

TEXTINCLUDE リソースの目的は、Visual C の内で容易に表現する形式で含める設定情報を安全に格納する**設定が含まれています** ダイアログ ボックス。 TEXTINCLUDE は、*リソースの種類*Visual C で定義されています。 Visual C++ は、リソース ID 番号 1、2、および 3 を持つ、3 つの特定の TEXTINCLUDE リソースを認識します。

|TEXTINCLUDE のリソース ID|[インクルード ファイルの設定] 情報の種類|
|-----------------------------|--------------------------------------|
|1|[シンボル用のヘッダー ファイル]|
|2|[読み取り専用ヘッダー ファイル]|
|3|[コンパイル時に追加するファイル]|

[インクルード ファイルの設定] 情報のそれぞれは、以下で説明するように、AppWizard で作成した既定の MYAPP.RC および RESOURCE.H ファイルによって表現されます。 BEGIN および END ブロックの間にある追加の \0 および "" トークンは、0 で終端された文字列と二重引用符のそれぞれを指定する RC の構文にとって必須です。

## <a name="symbol-header-file"></a>[シンボル用のヘッダー ファイル]

リソース コンパイラによって解釈される [シンボル用のヘッダー ファイル] 情報の形式は、単純な #include ステートメントです。

```
#include "resource.h"
```

対応する TEXTINCLUDE リソースは次のとおりです。

```
1 TEXTINCLUDE DISCARDABLE
BEGIN
"resource.h\0"
END
```

## <a name="read-only-symbol-directives"></a>[読み取り専用ヘッダー ファイル]

[読み取り専用ヘッダー ファイル] は、リソース コンパイラによる解釈が可能な次の形式で、MYAPP.RC の先頭でインクルードされます。

```
#include "afxres.h"
```

対応する TEXTINCLUDE リソースは次のとおりです。

```
2 TEXTINCLUDE DISCARDABLE
BEGIN
   "#include ""afxres.h""\r\n"
   "\0"
END
```

## <a name="compile-time-directives"></a>[コンパイル時に追加するファイル]

[コンパイル時に追加するファイル] は、リソース コンパイラによる解釈が可能な次の形式で、MYAPP.RC の最後でインクルードされます。

```
#ifndef APSTUDIO_INVOKED
///////////////////////
//
// From TEXTINCLUDE 3
//
#include "res\myapp.rc2"  // non-Visual C++ edited resources

#include "afxres.rc"  // Standard components
#include "afxprint.rc"  // printing/print preview resources
#endif  // not APSTUDIO_INVOKED
```

#ifndef APSTUDIO_INVOKED ディレクティブは、[コンパイル時に追加するファイル] をスキップするように Visual C++ に指示します。

対応する TEXTINCLUDE リソースは次のとおりです。

```
3 TEXTINCLUDE DISCARDABLE
BEGIN
"#include ""res\myapp.rc2""  // non-Visual C++ edited resources\r\n"
"\r\n"
"#include ""afxres.rc""  // Standard components\r\n"
"#include ""afxprint.rc""  // printing/print preview resources\r\n"
"\0"
END
```

## <a name="see-also"></a>関連項目

[番号順テクニカル ノート](../mfc/technical-notes-by-number.md)<br/>
[カテゴリ別テクニカル ノート](../mfc/technical-notes-by-category.md)
